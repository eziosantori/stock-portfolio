var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/puppeteer/lib/Errors.js
var require_Errors = __commonJS({
  "node_modules/puppeteer/lib/Errors.js"(exports, module2) {
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var TimeoutError = class extends CustomError {
    };
    module2.exports = {
      TimeoutError
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module2) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module2) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/supports-color/node_modules/has-flag/index.js
var require_has_flag = __commonJS({
  "node_modules/supports-color/node_modules/has-flag/index.js"(exports, module2) {
    "use strict";
    module2.exports = (flag, argv = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv.indexOf(prefix + flag);
      const terminatorPosition = argv.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag();
    var { env } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env) {
      if (env.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env) {
        if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env) {
        const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env.TERM_PROGRAM) {
          case "iTerm.app":
            return version >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env) {
        return 1;
      }
      return min;
    }
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/debug/src/node.js
var require_node = __commonJS({
  "node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} [0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log(...args) {
      return process.stderr.write(util.format(...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      const keys = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common()(exports);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node();
    }
  }
});

// node_modules/puppeteer/lib/helper.js
var require_helper = __commonJS({
  "node_modules/puppeteer/lib/helper.js"(exports, module2) {
    var { TimeoutError } = require_Errors();
    var debugError = require_src()(`puppeteer:error`);
    var Helper = class {
      static evaluationString(fun, ...args) {
        if (Helper.isString(fun)) {
          assert(args.length === 0, "Cannot evaluate a string with arguments");
          return fun;
        }
        return `(${fun})(${args.map(serializeArgument).join(",")})`;
        function serializeArgument(arg) {
          if (Object.is(arg, void 0))
            return "undefined";
          return JSON.stringify(arg);
        }
      }
      static getExceptionMessage(exceptionDetails) {
        if (exceptionDetails.exception)
          return exceptionDetails.exception.description || exceptionDetails.exception.value;
        let message = exceptionDetails.text;
        if (exceptionDetails.stackTrace) {
          for (const callframe of exceptionDetails.stackTrace.callFrames) {
            const location = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
            const functionName = callframe.functionName || "<anonymous>";
            message += `
    at ${functionName} (${location})`;
          }
        }
        return message;
      }
      static valueFromRemoteObject(remoteObject) {
        assert(!remoteObject.objectId, "Cannot extract value when objectId is given");
        if (remoteObject.unserializableValue) {
          if (remoteObject.type === "bigint" && typeof BigInt !== "undefined")
            return BigInt(remoteObject.unserializableValue.replace("n", ""));
          switch (remoteObject.unserializableValue) {
            case "-0":
              return -0;
            case "NaN":
              return NaN;
            case "Infinity":
              return Infinity;
            case "-Infinity":
              return -Infinity;
            default:
              throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
          }
        }
        return remoteObject.value;
      }
      static async releaseObject(client, remoteObject) {
        if (!remoteObject.objectId)
          return;
        await client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
          debugError(error);
        });
      }
      static installAsyncStackHooks(classType) {
        for (const methodName of Reflect.ownKeys(classType.prototype)) {
          const method = Reflect.get(classType.prototype, methodName);
          if (methodName === "constructor" || typeof methodName !== "string" || methodName.startsWith("_") || typeof method !== "function" || method.constructor.name !== "AsyncFunction")
            continue;
          Reflect.set(classType.prototype, methodName, function(...args) {
            const syncStack = new Error();
            return method.call(this, ...args).catch((e) => {
              const stack = syncStack.stack.substring(syncStack.stack.indexOf("\n") + 1);
              const clientStack = stack.substring(stack.indexOf("\n"));
              if (e instanceof Error && e.stack && !e.stack.includes(clientStack))
                e.stack += "\n  -- ASYNC --\n" + stack;
              throw e;
            });
          });
        }
      }
      static addEventListener(emitter, eventName, handler2) {
        emitter.on(eventName, handler2);
        return { emitter, eventName, handler: handler2 };
      }
      static removeEventListeners(listeners) {
        for (const listener of listeners)
          listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
      }
      static isString(obj) {
        return typeof obj === "string" || obj instanceof String;
      }
      static isNumber(obj) {
        return typeof obj === "number" || obj instanceof Number;
      }
      static promisify(nodeFunction) {
        function promisified(...args) {
          return new Promise((resolve, reject) => {
            function callback(err, ...result) {
              if (err)
                return reject(err);
              if (result.length === 1)
                return resolve(result[0]);
              return resolve(result);
            }
            nodeFunction.call(null, ...args, callback);
          });
        }
        return promisified;
      }
      static waitForEvent(emitter, eventName, predicate, timeout) {
        let eventTimeout, resolveCallback, rejectCallback;
        const promise = new Promise((resolve, reject) => {
          resolveCallback = resolve;
          rejectCallback = reject;
        });
        const listener = Helper.addEventListener(emitter, eventName, (event) => {
          if (!predicate(event))
            return;
          cleanup();
          resolveCallback(event);
        });
        if (timeout) {
          eventTimeout = setTimeout(() => {
            cleanup();
            rejectCallback(new TimeoutError("Timeout exceeded while waiting for event"));
          }, timeout);
        }
        function cleanup() {
          Helper.removeEventListeners([listener]);
          clearTimeout(eventTimeout);
        }
        return promise;
      }
      static async waitWithTimeout(promise, taskName, timeout) {
        let reject;
        const timeoutError = new TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
        const timeoutPromise = new Promise((resolve, x) => reject = x);
        const timeoutTimer = setTimeout(() => reject(timeoutError), timeout);
        try {
          return await Promise.race([promise, timeoutPromise]);
        } finally {
          clearTimeout(timeoutTimer);
        }
      }
    };
    function assert(value, message) {
      if (!value)
        throw new Error(message);
    }
    module2.exports = {
      helper: Helper,
      assert,
      debugError
    };
  }
});

// node_modules/puppeteer/lib/Accessibility.js
var require_Accessibility = __commonJS({
  "node_modules/puppeteer/lib/Accessibility.js"(exports, module2) {
    var Accessibility = class {
      constructor(client) {
        this._client = client;
      }
      async snapshot(options = {}) {
        const {
          interestingOnly = true,
          root = null
        } = options;
        const { nodes } = await this._client.send("Accessibility.getFullAXTree");
        let backendNodeId = null;
        if (root) {
          const { node } = await this._client.send("DOM.describeNode", { objectId: root._remoteObject.objectId });
          backendNodeId = node.backendNodeId;
        }
        const defaultRoot = AXNode.createTree(nodes);
        let needle = defaultRoot;
        if (backendNodeId) {
          needle = defaultRoot.find((node) => node._payload.backendDOMNodeId === backendNodeId);
          if (!needle)
            return null;
        }
        if (!interestingOnly)
          return serializeTree(needle)[0];
        const interestingNodes = new Set();
        collectInterestingNodes(interestingNodes, defaultRoot, false);
        if (!interestingNodes.has(needle))
          return null;
        return serializeTree(needle, interestingNodes)[0];
      }
    };
    function collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl))
        collection.add(node);
      if (node.isLeafNode())
        return;
      insideControl = insideControl || node.isControl();
      for (const child of node._children)
        collectInterestingNodes(collection, child, insideControl);
    }
    function serializeTree(node, whitelistedNodes) {
      const children = [];
      for (const child of node._children)
        children.push(...serializeTree(child, whitelistedNodes));
      if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
      const serializedNode = node.serialize();
      if (children.length)
        serializedNode.children = children;
      return [serializedNode];
    }
    var AXNode = class {
      constructor(payload) {
        this._payload = payload;
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._name = this._payload.name ? this._payload.name.value : "";
        this._role = this._payload.role ? this._payload.role.value : "Unknown";
        this._cachedHasFocusableChild;
        for (const property of this._payload.properties || []) {
          if (property.name === "editable") {
            this._richlyEditable = property.value.value === "richtext";
            this._editable = true;
          }
          if (property.name === "focusable")
            this._focusable = property.value.value;
          if (property.name === "expanded")
            this._expanded = property.value.value;
        }
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      find(predicate) {
        if (predicate(this))
          return this;
        for (const child of this._children) {
          const result = child.find(predicate);
          if (result)
            return result;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this._role;
        if (role === "Ignored")
          return false;
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name;
      }
      serialize() {
        const properties = new Map();
        for (const property of this._payload.properties || [])
          properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.name)
          properties.set("name", this._payload.name.value);
        if (this._payload.value)
          properties.set("value", this._payload.value.value);
        if (this._payload.description)
          properties.set("description", this._payload.description.value);
        const node = {
          role: this._role
        };
        const userStringProperties = [
          "name",
          "value",
          "description",
          "keyshortcuts",
          "roledescription",
          "valuetext"
        ];
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty))
            continue;
          node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = [
          "disabled",
          "expanded",
          "focused",
          "modal",
          "multiline",
          "multiselectable",
          "readonly",
          "required",
          "selected"
        ];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && this._role === "WebArea")
            continue;
          const value = properties.get(booleanProperty);
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const tristateProperties = [
          "checked",
          "pressed"
        ];
        for (const tristateProperty of tristateProperties) {
          if (!properties.has(tristateProperty))
            continue;
          const value = properties.get(tristateProperty);
          node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
        }
        const numericalProperties = [
          "level",
          "valuemax",
          "valuemin"
        ];
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty))
            continue;
          node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = [
          "autocomplete",
          "haspopup",
          "invalid",
          "orientation"
        ];
        for (const tokenProperty of tokenProperties) {
          const value = properties.get(tokenProperty);
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        return node;
      }
      static createTree(payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
          nodeById.set(payload.nodeId, new AXNode(payload));
        for (const node of nodeById.values()) {
          for (const childId of node._payload.childIds || [])
            node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
      }
    };
    module2.exports = { Accessibility };
  }
});

// node_modules/puppeteer/lib/Events.js
var require_Events = __commonJS({
  "node_modules/puppeteer/lib/Events.js"(exports, module2) {
    var Events = {
      Page: {
        Close: "close",
        Console: "console",
        Dialog: "dialog",
        DOMContentLoaded: "domcontentloaded",
        Error: "error",
        PageError: "pageerror",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished",
        FrameAttached: "frameattached",
        FrameDetached: "framedetached",
        FrameNavigated: "framenavigated",
        Load: "load",
        Metrics: "metrics",
        Popup: "popup",
        WorkerCreated: "workercreated",
        WorkerDestroyed: "workerdestroyed"
      },
      Browser: {
        TargetCreated: "targetcreated",
        TargetDestroyed: "targetdestroyed",
        TargetChanged: "targetchanged",
        Disconnected: "disconnected"
      },
      BrowserContext: {
        TargetCreated: "targetcreated",
        TargetDestroyed: "targetdestroyed",
        TargetChanged: "targetchanged"
      },
      NetworkManager: {
        Request: Symbol("Events.NetworkManager.Request"),
        Response: Symbol("Events.NetworkManager.Response"),
        RequestFailed: Symbol("Events.NetworkManager.RequestFailed"),
        RequestFinished: Symbol("Events.NetworkManager.RequestFinished")
      },
      FrameManager: {
        FrameAttached: Symbol("Events.FrameManager.FrameAttached"),
        FrameNavigated: Symbol("Events.FrameManager.FrameNavigated"),
        FrameDetached: Symbol("Events.FrameManager.FrameDetached"),
        LifecycleEvent: Symbol("Events.FrameManager.LifecycleEvent"),
        FrameNavigatedWithinDocument: Symbol("Events.FrameManager.FrameNavigatedWithinDocument"),
        ExecutionContextCreated: Symbol("Events.FrameManager.ExecutionContextCreated"),
        ExecutionContextDestroyed: Symbol("Events.FrameManager.ExecutionContextDestroyed")
      },
      Connection: {
        Disconnected: Symbol("Events.Connection.Disconnected")
      },
      CDPSession: {
        Disconnected: Symbol("Events.CDPSession.Disconnected")
      }
    };
    module2.exports = { Events };
  }
});

// node_modules/puppeteer/node_modules/mime/Mime.js
var require_Mime = __commonJS({
  "node_modules/puppeteer/node_modules/mime/Mime.js"(exports, module2) {
    "use strict";
    function Mime() {
      this._types = Object.create(null);
      this._extensions = Object.create(null);
      for (let i = 0; i < arguments.length; i++) {
        this.define(arguments[i]);
      }
      this.define = this.define.bind(this);
      this.getType = this.getType.bind(this);
      this.getExtension = this.getExtension.bind(this);
    }
    Mime.prototype.define = function(typeMap, force) {
      for (let type in typeMap) {
        let extensions = typeMap[type].map(function(t) {
          return t.toLowerCase();
        });
        type = type.toLowerCase();
        for (let i = 0; i < extensions.length; i++) {
          const ext = extensions[i];
          if (ext[0] === "*") {
            continue;
          }
          if (!force && ext in this._types) {
            throw new Error('Attempt to change mapping for "' + ext + '" extension from "' + this._types[ext] + '" to "' + type + '". Pass `force=true` to allow this, otherwise remove "' + ext + '" from the list of extensions for "' + type + '".');
          }
          this._types[ext] = type;
        }
        if (force || !this._extensions[type]) {
          const ext = extensions[0];
          this._extensions[type] = ext[0] !== "*" ? ext : ext.substr(1);
        }
      }
    };
    Mime.prototype.getType = function(path) {
      path = String(path);
      let last = path.replace(/^.*[/\\]/, "").toLowerCase();
      let ext = last.replace(/^.*\./, "").toLowerCase();
      let hasPath = last.length < path.length;
      let hasDot = ext.length < last.length - 1;
      return (hasDot || !hasPath) && this._types[ext] || null;
    };
    Mime.prototype.getExtension = function(type) {
      type = /^\s*([^;\s]*)/.test(type) && RegExp.$1;
      return type && this._extensions[type.toLowerCase()] || null;
    };
    module2.exports = Mime;
  }
});

// node_modules/puppeteer/node_modules/mime/types/standard.js
var require_standard = __commonJS({
  "node_modules/puppeteer/node_modules/mime/types/standard.js"(exports, module2) {
    module2.exports = { "application/andrew-inset": ["ez"], "application/applixware": ["aw"], "application/atom+xml": ["atom"], "application/atomcat+xml": ["atomcat"], "application/atomdeleted+xml": ["atomdeleted"], "application/atomsvc+xml": ["atomsvc"], "application/atsc-dwd+xml": ["dwd"], "application/atsc-held+xml": ["held"], "application/atsc-rsat+xml": ["rsat"], "application/bdoc": ["bdoc"], "application/calendar+xml": ["xcs"], "application/ccxml+xml": ["ccxml"], "application/cdfx+xml": ["cdfx"], "application/cdmi-capability": ["cdmia"], "application/cdmi-container": ["cdmic"], "application/cdmi-domain": ["cdmid"], "application/cdmi-object": ["cdmio"], "application/cdmi-queue": ["cdmiq"], "application/cu-seeme": ["cu"], "application/dash+xml": ["mpd"], "application/davmount+xml": ["davmount"], "application/docbook+xml": ["dbk"], "application/dssc+der": ["dssc"], "application/dssc+xml": ["xdssc"], "application/ecmascript": ["es", "ecma"], "application/emma+xml": ["emma"], "application/emotionml+xml": ["emotionml"], "application/epub+zip": ["epub"], "application/exi": ["exi"], "application/express": ["exp"], "application/fdt+xml": ["fdt"], "application/font-tdpfr": ["pfr"], "application/geo+json": ["geojson"], "application/gml+xml": ["gml"], "application/gpx+xml": ["gpx"], "application/gxf": ["gxf"], "application/gzip": ["gz"], "application/hjson": ["hjson"], "application/hyperstudio": ["stk"], "application/inkml+xml": ["ink", "inkml"], "application/ipfix": ["ipfix"], "application/its+xml": ["its"], "application/java-archive": ["jar", "war", "ear"], "application/java-serialized-object": ["ser"], "application/java-vm": ["class"], "application/javascript": ["js", "mjs"], "application/json": ["json", "map"], "application/json5": ["json5"], "application/jsonml+json": ["jsonml"], "application/ld+json": ["jsonld"], "application/lgr+xml": ["lgr"], "application/lost+xml": ["lostxml"], "application/mac-binhex40": ["hqx"], "application/mac-compactpro": ["cpt"], "application/mads+xml": ["mads"], "application/manifest+json": ["webmanifest"], "application/marc": ["mrc"], "application/marcxml+xml": ["mrcx"], "application/mathematica": ["ma", "nb", "mb"], "application/mathml+xml": ["mathml"], "application/mbox": ["mbox"], "application/mediaservercontrol+xml": ["mscml"], "application/metalink+xml": ["metalink"], "application/metalink4+xml": ["meta4"], "application/mets+xml": ["mets"], "application/mmt-aei+xml": ["maei"], "application/mmt-usd+xml": ["musd"], "application/mods+xml": ["mods"], "application/mp21": ["m21", "mp21"], "application/mp4": ["mp4s", "m4p"], "application/msword": ["doc", "dot"], "application/mxf": ["mxf"], "application/n-quads": ["nq"], "application/n-triples": ["nt"], "application/node": ["cjs"], "application/octet-stream": ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"], "application/oda": ["oda"], "application/oebps-package+xml": ["opf"], "application/ogg": ["ogx"], "application/omdoc+xml": ["omdoc"], "application/onenote": ["onetoc", "onetoc2", "onetmp", "onepkg"], "application/oxps": ["oxps"], "application/p2p-overlay+xml": ["relo"], "application/patch-ops-error+xml": ["xer"], "application/pdf": ["pdf"], "application/pgp-encrypted": ["pgp"], "application/pgp-signature": ["asc", "sig"], "application/pics-rules": ["prf"], "application/pkcs10": ["p10"], "application/pkcs7-mime": ["p7m", "p7c"], "application/pkcs7-signature": ["p7s"], "application/pkcs8": ["p8"], "application/pkix-attr-cert": ["ac"], "application/pkix-cert": ["cer"], "application/pkix-crl": ["crl"], "application/pkix-pkipath": ["pkipath"], "application/pkixcmp": ["pki"], "application/pls+xml": ["pls"], "application/postscript": ["ai", "eps", "ps"], "application/provenance+xml": ["provx"], "application/pskc+xml": ["pskcxml"], "application/raml+yaml": ["raml"], "application/rdf+xml": ["rdf", "owl"], "application/reginfo+xml": ["rif"], "application/relax-ng-compact-syntax": ["rnc"], "application/resource-lists+xml": ["rl"], "application/resource-lists-diff+xml": ["rld"], "application/rls-services+xml": ["rs"], "application/route-apd+xml": ["rapd"], "application/route-s-tsid+xml": ["sls"], "application/route-usd+xml": ["rusd"], "application/rpki-ghostbusters": ["gbr"], "application/rpki-manifest": ["mft"], "application/rpki-roa": ["roa"], "application/rsd+xml": ["rsd"], "application/rss+xml": ["rss"], "application/rtf": ["rtf"], "application/sbml+xml": ["sbml"], "application/scvp-cv-request": ["scq"], "application/scvp-cv-response": ["scs"], "application/scvp-vp-request": ["spq"], "application/scvp-vp-response": ["spp"], "application/sdp": ["sdp"], "application/senml+xml": ["senmlx"], "application/sensml+xml": ["sensmlx"], "application/set-payment-initiation": ["setpay"], "application/set-registration-initiation": ["setreg"], "application/shf+xml": ["shf"], "application/sieve": ["siv", "sieve"], "application/smil+xml": ["smi", "smil"], "application/sparql-query": ["rq"], "application/sparql-results+xml": ["srx"], "application/srgs": ["gram"], "application/srgs+xml": ["grxml"], "application/sru+xml": ["sru"], "application/ssdl+xml": ["ssdl"], "application/ssml+xml": ["ssml"], "application/swid+xml": ["swidtag"], "application/tei+xml": ["tei", "teicorpus"], "application/thraud+xml": ["tfi"], "application/timestamped-data": ["tsd"], "application/toml": ["toml"], "application/trig": ["trig"], "application/ttml+xml": ["ttml"], "application/ubjson": ["ubj"], "application/urc-ressheet+xml": ["rsheet"], "application/urc-targetdesc+xml": ["td"], "application/voicexml+xml": ["vxml"], "application/wasm": ["wasm"], "application/widget": ["wgt"], "application/winhlp": ["hlp"], "application/wsdl+xml": ["wsdl"], "application/wspolicy+xml": ["wspolicy"], "application/xaml+xml": ["xaml"], "application/xcap-att+xml": ["xav"], "application/xcap-caps+xml": ["xca"], "application/xcap-diff+xml": ["xdf"], "application/xcap-el+xml": ["xel"], "application/xcap-ns+xml": ["xns"], "application/xenc+xml": ["xenc"], "application/xhtml+xml": ["xhtml", "xht"], "application/xliff+xml": ["xlf"], "application/xml": ["xml", "xsl", "xsd", "rng"], "application/xml-dtd": ["dtd"], "application/xop+xml": ["xop"], "application/xproc+xml": ["xpl"], "application/xslt+xml": ["*xsl", "xslt"], "application/xspf+xml": ["xspf"], "application/xv+xml": ["mxml", "xhvml", "xvml", "xvm"], "application/yang": ["yang"], "application/yin+xml": ["yin"], "application/zip": ["zip"], "audio/3gpp": ["*3gpp"], "audio/adpcm": ["adp"], "audio/amr": ["amr"], "audio/basic": ["au", "snd"], "audio/midi": ["mid", "midi", "kar", "rmi"], "audio/mobile-xmf": ["mxmf"], "audio/mp3": ["*mp3"], "audio/mp4": ["m4a", "mp4a"], "audio/mpeg": ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"], "audio/ogg": ["oga", "ogg", "spx", "opus"], "audio/s3m": ["s3m"], "audio/silk": ["sil"], "audio/wav": ["wav"], "audio/wave": ["*wav"], "audio/webm": ["weba"], "audio/xm": ["xm"], "font/collection": ["ttc"], "font/otf": ["otf"], "font/ttf": ["ttf"], "font/woff": ["woff"], "font/woff2": ["woff2"], "image/aces": ["exr"], "image/apng": ["apng"], "image/avif": ["avif"], "image/bmp": ["bmp"], "image/cgm": ["cgm"], "image/dicom-rle": ["drle"], "image/emf": ["emf"], "image/fits": ["fits"], "image/g3fax": ["g3"], "image/gif": ["gif"], "image/heic": ["heic"], "image/heic-sequence": ["heics"], "image/heif": ["heif"], "image/heif-sequence": ["heifs"], "image/hej2k": ["hej2"], "image/hsj2": ["hsj2"], "image/ief": ["ief"], "image/jls": ["jls"], "image/jp2": ["jp2", "jpg2"], "image/jpeg": ["jpeg", "jpg", "jpe"], "image/jph": ["jph"], "image/jphc": ["jhc"], "image/jpm": ["jpm"], "image/jpx": ["jpx", "jpf"], "image/jxr": ["jxr"], "image/jxra": ["jxra"], "image/jxrs": ["jxrs"], "image/jxs": ["jxs"], "image/jxsc": ["jxsc"], "image/jxsi": ["jxsi"], "image/jxss": ["jxss"], "image/ktx": ["ktx"], "image/ktx2": ["ktx2"], "image/png": ["png"], "image/sgi": ["sgi"], "image/svg+xml": ["svg", "svgz"], "image/t38": ["t38"], "image/tiff": ["tif", "tiff"], "image/tiff-fx": ["tfx"], "image/webp": ["webp"], "image/wmf": ["wmf"], "message/disposition-notification": ["disposition-notification"], "message/global": ["u8msg"], "message/global-delivery-status": ["u8dsn"], "message/global-disposition-notification": ["u8mdn"], "message/global-headers": ["u8hdr"], "message/rfc822": ["eml", "mime"], "model/3mf": ["3mf"], "model/gltf+json": ["gltf"], "model/gltf-binary": ["glb"], "model/iges": ["igs", "iges"], "model/mesh": ["msh", "mesh", "silo"], "model/mtl": ["mtl"], "model/obj": ["obj"], "model/step+xml": ["stpx"], "model/step+zip": ["stpz"], "model/step-xml+zip": ["stpxz"], "model/stl": ["stl"], "model/vrml": ["wrl", "vrml"], "model/x3d+binary": ["*x3db", "x3dbz"], "model/x3d+fastinfoset": ["x3db"], "model/x3d+vrml": ["*x3dv", "x3dvz"], "model/x3d+xml": ["x3d", "x3dz"], "model/x3d-vrml": ["x3dv"], "text/cache-manifest": ["appcache", "manifest"], "text/calendar": ["ics", "ifb"], "text/coffeescript": ["coffee", "litcoffee"], "text/css": ["css"], "text/csv": ["csv"], "text/html": ["html", "htm", "shtml"], "text/jade": ["jade"], "text/jsx": ["jsx"], "text/less": ["less"], "text/markdown": ["markdown", "md"], "text/mathml": ["mml"], "text/mdx": ["mdx"], "text/n3": ["n3"], "text/plain": ["txt", "text", "conf", "def", "list", "log", "in", "ini"], "text/richtext": ["rtx"], "text/rtf": ["*rtf"], "text/sgml": ["sgml", "sgm"], "text/shex": ["shex"], "text/slim": ["slim", "slm"], "text/spdx": ["spdx"], "text/stylus": ["stylus", "styl"], "text/tab-separated-values": ["tsv"], "text/troff": ["t", "tr", "roff", "man", "me", "ms"], "text/turtle": ["ttl"], "text/uri-list": ["uri", "uris", "urls"], "text/vcard": ["vcard"], "text/vtt": ["vtt"], "text/xml": ["*xml"], "text/yaml": ["yaml", "yml"], "video/3gpp": ["3gp", "3gpp"], "video/3gpp2": ["3g2"], "video/h261": ["h261"], "video/h263": ["h263"], "video/h264": ["h264"], "video/iso.segment": ["m4s"], "video/jpeg": ["jpgv"], "video/jpm": ["*jpm", "jpgm"], "video/mj2": ["mj2", "mjp2"], "video/mp2t": ["ts"], "video/mp4": ["mp4", "mp4v", "mpg4"], "video/mpeg": ["mpeg", "mpg", "mpe", "m1v", "m2v"], "video/ogg": ["ogv"], "video/quicktime": ["qt", "mov"], "video/webm": ["webm"] };
  }
});

// node_modules/puppeteer/node_modules/mime/types/other.js
var require_other = __commonJS({
  "node_modules/puppeteer/node_modules/mime/types/other.js"(exports, module2) {
    module2.exports = { "application/prs.cww": ["cww"], "application/vnd.1000minds.decision-model+xml": ["1km"], "application/vnd.3gpp.pic-bw-large": ["plb"], "application/vnd.3gpp.pic-bw-small": ["psb"], "application/vnd.3gpp.pic-bw-var": ["pvb"], "application/vnd.3gpp2.tcap": ["tcap"], "application/vnd.3m.post-it-notes": ["pwn"], "application/vnd.accpac.simply.aso": ["aso"], "application/vnd.accpac.simply.imp": ["imp"], "application/vnd.acucobol": ["acu"], "application/vnd.acucorp": ["atc", "acutc"], "application/vnd.adobe.air-application-installer-package+zip": ["air"], "application/vnd.adobe.formscentral.fcdt": ["fcdt"], "application/vnd.adobe.fxp": ["fxp", "fxpl"], "application/vnd.adobe.xdp+xml": ["xdp"], "application/vnd.adobe.xfdf": ["xfdf"], "application/vnd.ahead.space": ["ahead"], "application/vnd.airzip.filesecure.azf": ["azf"], "application/vnd.airzip.filesecure.azs": ["azs"], "application/vnd.amazon.ebook": ["azw"], "application/vnd.americandynamics.acc": ["acc"], "application/vnd.amiga.ami": ["ami"], "application/vnd.android.package-archive": ["apk"], "application/vnd.anser-web-certificate-issue-initiation": ["cii"], "application/vnd.anser-web-funds-transfer-initiation": ["fti"], "application/vnd.antix.game-component": ["atx"], "application/vnd.apple.installer+xml": ["mpkg"], "application/vnd.apple.keynote": ["key"], "application/vnd.apple.mpegurl": ["m3u8"], "application/vnd.apple.numbers": ["numbers"], "application/vnd.apple.pages": ["pages"], "application/vnd.apple.pkpass": ["pkpass"], "application/vnd.aristanetworks.swi": ["swi"], "application/vnd.astraea-software.iota": ["iota"], "application/vnd.audiograph": ["aep"], "application/vnd.balsamiq.bmml+xml": ["bmml"], "application/vnd.blueice.multipass": ["mpm"], "application/vnd.bmi": ["bmi"], "application/vnd.businessobjects": ["rep"], "application/vnd.chemdraw+xml": ["cdxml"], "application/vnd.chipnuts.karaoke-mmd": ["mmd"], "application/vnd.cinderella": ["cdy"], "application/vnd.citationstyles.style+xml": ["csl"], "application/vnd.claymore": ["cla"], "application/vnd.cloanto.rp9": ["rp9"], "application/vnd.clonk.c4group": ["c4g", "c4d", "c4f", "c4p", "c4u"], "application/vnd.cluetrust.cartomobile-config": ["c11amc"], "application/vnd.cluetrust.cartomobile-config-pkg": ["c11amz"], "application/vnd.commonspace": ["csp"], "application/vnd.contact.cmsg": ["cdbcmsg"], "application/vnd.cosmocaller": ["cmc"], "application/vnd.crick.clicker": ["clkx"], "application/vnd.crick.clicker.keyboard": ["clkk"], "application/vnd.crick.clicker.palette": ["clkp"], "application/vnd.crick.clicker.template": ["clkt"], "application/vnd.crick.clicker.wordbank": ["clkw"], "application/vnd.criticaltools.wbs+xml": ["wbs"], "application/vnd.ctc-posml": ["pml"], "application/vnd.cups-ppd": ["ppd"], "application/vnd.curl.car": ["car"], "application/vnd.curl.pcurl": ["pcurl"], "application/vnd.dart": ["dart"], "application/vnd.data-vision.rdz": ["rdz"], "application/vnd.dbf": ["dbf"], "application/vnd.dece.data": ["uvf", "uvvf", "uvd", "uvvd"], "application/vnd.dece.ttml+xml": ["uvt", "uvvt"], "application/vnd.dece.unspecified": ["uvx", "uvvx"], "application/vnd.dece.zip": ["uvz", "uvvz"], "application/vnd.denovo.fcselayout-link": ["fe_launch"], "application/vnd.dna": ["dna"], "application/vnd.dolby.mlp": ["mlp"], "application/vnd.dpgraph": ["dpg"], "application/vnd.dreamfactory": ["dfac"], "application/vnd.ds-keypoint": ["kpxx"], "application/vnd.dvb.ait": ["ait"], "application/vnd.dvb.service": ["svc"], "application/vnd.dynageo": ["geo"], "application/vnd.ecowin.chart": ["mag"], "application/vnd.enliven": ["nml"], "application/vnd.epson.esf": ["esf"], "application/vnd.epson.msf": ["msf"], "application/vnd.epson.quickanime": ["qam"], "application/vnd.epson.salt": ["slt"], "application/vnd.epson.ssf": ["ssf"], "application/vnd.eszigno3+xml": ["es3", "et3"], "application/vnd.ezpix-album": ["ez2"], "application/vnd.ezpix-package": ["ez3"], "application/vnd.fdf": ["fdf"], "application/vnd.fdsn.mseed": ["mseed"], "application/vnd.fdsn.seed": ["seed", "dataless"], "application/vnd.flographit": ["gph"], "application/vnd.fluxtime.clip": ["ftc"], "application/vnd.framemaker": ["fm", "frame", "maker", "book"], "application/vnd.frogans.fnc": ["fnc"], "application/vnd.frogans.ltf": ["ltf"], "application/vnd.fsc.weblaunch": ["fsc"], "application/vnd.fujitsu.oasys": ["oas"], "application/vnd.fujitsu.oasys2": ["oa2"], "application/vnd.fujitsu.oasys3": ["oa3"], "application/vnd.fujitsu.oasysgp": ["fg5"], "application/vnd.fujitsu.oasysprs": ["bh2"], "application/vnd.fujixerox.ddd": ["ddd"], "application/vnd.fujixerox.docuworks": ["xdw"], "application/vnd.fujixerox.docuworks.binder": ["xbd"], "application/vnd.fuzzysheet": ["fzs"], "application/vnd.genomatix.tuxedo": ["txd"], "application/vnd.geogebra.file": ["ggb"], "application/vnd.geogebra.tool": ["ggt"], "application/vnd.geometry-explorer": ["gex", "gre"], "application/vnd.geonext": ["gxt"], "application/vnd.geoplan": ["g2w"], "application/vnd.geospace": ["g3w"], "application/vnd.gmx": ["gmx"], "application/vnd.google-apps.document": ["gdoc"], "application/vnd.google-apps.presentation": ["gslides"], "application/vnd.google-apps.spreadsheet": ["gsheet"], "application/vnd.google-earth.kml+xml": ["kml"], "application/vnd.google-earth.kmz": ["kmz"], "application/vnd.grafeq": ["gqf", "gqs"], "application/vnd.groove-account": ["gac"], "application/vnd.groove-help": ["ghf"], "application/vnd.groove-identity-message": ["gim"], "application/vnd.groove-injector": ["grv"], "application/vnd.groove-tool-message": ["gtm"], "application/vnd.groove-tool-template": ["tpl"], "application/vnd.groove-vcard": ["vcg"], "application/vnd.hal+xml": ["hal"], "application/vnd.handheld-entertainment+xml": ["zmm"], "application/vnd.hbci": ["hbci"], "application/vnd.hhe.lesson-player": ["les"], "application/vnd.hp-hpgl": ["hpgl"], "application/vnd.hp-hpid": ["hpid"], "application/vnd.hp-hps": ["hps"], "application/vnd.hp-jlyt": ["jlt"], "application/vnd.hp-pcl": ["pcl"], "application/vnd.hp-pclxl": ["pclxl"], "application/vnd.hydrostatix.sof-data": ["sfd-hdstx"], "application/vnd.ibm.minipay": ["mpy"], "application/vnd.ibm.modcap": ["afp", "listafp", "list3820"], "application/vnd.ibm.rights-management": ["irm"], "application/vnd.ibm.secure-container": ["sc"], "application/vnd.iccprofile": ["icc", "icm"], "application/vnd.igloader": ["igl"], "application/vnd.immervision-ivp": ["ivp"], "application/vnd.immervision-ivu": ["ivu"], "application/vnd.insors.igm": ["igm"], "application/vnd.intercon.formnet": ["xpw", "xpx"], "application/vnd.intergeo": ["i2g"], "application/vnd.intu.qbo": ["qbo"], "application/vnd.intu.qfx": ["qfx"], "application/vnd.ipunplugged.rcprofile": ["rcprofile"], "application/vnd.irepository.package+xml": ["irp"], "application/vnd.is-xpr": ["xpr"], "application/vnd.isac.fcs": ["fcs"], "application/vnd.jam": ["jam"], "application/vnd.jcp.javame.midlet-rms": ["rms"], "application/vnd.jisp": ["jisp"], "application/vnd.joost.joda-archive": ["joda"], "application/vnd.kahootz": ["ktz", "ktr"], "application/vnd.kde.karbon": ["karbon"], "application/vnd.kde.kchart": ["chrt"], "application/vnd.kde.kformula": ["kfo"], "application/vnd.kde.kivio": ["flw"], "application/vnd.kde.kontour": ["kon"], "application/vnd.kde.kpresenter": ["kpr", "kpt"], "application/vnd.kde.kspread": ["ksp"], "application/vnd.kde.kword": ["kwd", "kwt"], "application/vnd.kenameaapp": ["htke"], "application/vnd.kidspiration": ["kia"], "application/vnd.kinar": ["kne", "knp"], "application/vnd.koan": ["skp", "skd", "skt", "skm"], "application/vnd.kodak-descriptor": ["sse"], "application/vnd.las.las+xml": ["lasxml"], "application/vnd.llamagraphics.life-balance.desktop": ["lbd"], "application/vnd.llamagraphics.life-balance.exchange+xml": ["lbe"], "application/vnd.lotus-1-2-3": ["123"], "application/vnd.lotus-approach": ["apr"], "application/vnd.lotus-freelance": ["pre"], "application/vnd.lotus-notes": ["nsf"], "application/vnd.lotus-organizer": ["org"], "application/vnd.lotus-screencam": ["scm"], "application/vnd.lotus-wordpro": ["lwp"], "application/vnd.macports.portpkg": ["portpkg"], "application/vnd.mapbox-vector-tile": ["mvt"], "application/vnd.mcd": ["mcd"], "application/vnd.medcalcdata": ["mc1"], "application/vnd.mediastation.cdkey": ["cdkey"], "application/vnd.mfer": ["mwf"], "application/vnd.mfmp": ["mfm"], "application/vnd.micrografx.flo": ["flo"], "application/vnd.micrografx.igx": ["igx"], "application/vnd.mif": ["mif"], "application/vnd.mobius.daf": ["daf"], "application/vnd.mobius.dis": ["dis"], "application/vnd.mobius.mbk": ["mbk"], "application/vnd.mobius.mqy": ["mqy"], "application/vnd.mobius.msl": ["msl"], "application/vnd.mobius.plc": ["plc"], "application/vnd.mobius.txf": ["txf"], "application/vnd.mophun.application": ["mpn"], "application/vnd.mophun.certificate": ["mpc"], "application/vnd.mozilla.xul+xml": ["xul"], "application/vnd.ms-artgalry": ["cil"], "application/vnd.ms-cab-compressed": ["cab"], "application/vnd.ms-excel": ["xls", "xlm", "xla", "xlc", "xlt", "xlw"], "application/vnd.ms-excel.addin.macroenabled.12": ["xlam"], "application/vnd.ms-excel.sheet.binary.macroenabled.12": ["xlsb"], "application/vnd.ms-excel.sheet.macroenabled.12": ["xlsm"], "application/vnd.ms-excel.template.macroenabled.12": ["xltm"], "application/vnd.ms-fontobject": ["eot"], "application/vnd.ms-htmlhelp": ["chm"], "application/vnd.ms-ims": ["ims"], "application/vnd.ms-lrm": ["lrm"], "application/vnd.ms-officetheme": ["thmx"], "application/vnd.ms-outlook": ["msg"], "application/vnd.ms-pki.seccat": ["cat"], "application/vnd.ms-pki.stl": ["*stl"], "application/vnd.ms-powerpoint": ["ppt", "pps", "pot"], "application/vnd.ms-powerpoint.addin.macroenabled.12": ["ppam"], "application/vnd.ms-powerpoint.presentation.macroenabled.12": ["pptm"], "application/vnd.ms-powerpoint.slide.macroenabled.12": ["sldm"], "application/vnd.ms-powerpoint.slideshow.macroenabled.12": ["ppsm"], "application/vnd.ms-powerpoint.template.macroenabled.12": ["potm"], "application/vnd.ms-project": ["mpp", "mpt"], "application/vnd.ms-word.document.macroenabled.12": ["docm"], "application/vnd.ms-word.template.macroenabled.12": ["dotm"], "application/vnd.ms-works": ["wps", "wks", "wcm", "wdb"], "application/vnd.ms-wpl": ["wpl"], "application/vnd.ms-xpsdocument": ["xps"], "application/vnd.mseq": ["mseq"], "application/vnd.musician": ["mus"], "application/vnd.muvee.style": ["msty"], "application/vnd.mynfc": ["taglet"], "application/vnd.neurolanguage.nlu": ["nlu"], "application/vnd.nitf": ["ntf", "nitf"], "application/vnd.noblenet-directory": ["nnd"], "application/vnd.noblenet-sealer": ["nns"], "application/vnd.noblenet-web": ["nnw"], "application/vnd.nokia.n-gage.ac+xml": ["*ac"], "application/vnd.nokia.n-gage.data": ["ngdat"], "application/vnd.nokia.n-gage.symbian.install": ["n-gage"], "application/vnd.nokia.radio-preset": ["rpst"], "application/vnd.nokia.radio-presets": ["rpss"], "application/vnd.novadigm.edm": ["edm"], "application/vnd.novadigm.edx": ["edx"], "application/vnd.novadigm.ext": ["ext"], "application/vnd.oasis.opendocument.chart": ["odc"], "application/vnd.oasis.opendocument.chart-template": ["otc"], "application/vnd.oasis.opendocument.database": ["odb"], "application/vnd.oasis.opendocument.formula": ["odf"], "application/vnd.oasis.opendocument.formula-template": ["odft"], "application/vnd.oasis.opendocument.graphics": ["odg"], "application/vnd.oasis.opendocument.graphics-template": ["otg"], "application/vnd.oasis.opendocument.image": ["odi"], "application/vnd.oasis.opendocument.image-template": ["oti"], "application/vnd.oasis.opendocument.presentation": ["odp"], "application/vnd.oasis.opendocument.presentation-template": ["otp"], "application/vnd.oasis.opendocument.spreadsheet": ["ods"], "application/vnd.oasis.opendocument.spreadsheet-template": ["ots"], "application/vnd.oasis.opendocument.text": ["odt"], "application/vnd.oasis.opendocument.text-master": ["odm"], "application/vnd.oasis.opendocument.text-template": ["ott"], "application/vnd.oasis.opendocument.text-web": ["oth"], "application/vnd.olpc-sugar": ["xo"], "application/vnd.oma.dd2+xml": ["dd2"], "application/vnd.openblox.game+xml": ["obgx"], "application/vnd.openofficeorg.extension": ["oxt"], "application/vnd.openstreetmap.data+xml": ["osm"], "application/vnd.openxmlformats-officedocument.presentationml.presentation": ["pptx"], "application/vnd.openxmlformats-officedocument.presentationml.slide": ["sldx"], "application/vnd.openxmlformats-officedocument.presentationml.slideshow": ["ppsx"], "application/vnd.openxmlformats-officedocument.presentationml.template": ["potx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["xlsx"], "application/vnd.openxmlformats-officedocument.spreadsheetml.template": ["xltx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["docx"], "application/vnd.openxmlformats-officedocument.wordprocessingml.template": ["dotx"], "application/vnd.osgeo.mapguide.package": ["mgp"], "application/vnd.osgi.dp": ["dp"], "application/vnd.osgi.subsystem": ["esa"], "application/vnd.palm": ["pdb", "pqa", "oprc"], "application/vnd.pawaafile": ["paw"], "application/vnd.pg.format": ["str"], "application/vnd.pg.osasli": ["ei6"], "application/vnd.picsel": ["efif"], "application/vnd.pmi.widget": ["wg"], "application/vnd.pocketlearn": ["plf"], "application/vnd.powerbuilder6": ["pbd"], "application/vnd.previewsystems.box": ["box"], "application/vnd.proteus.magazine": ["mgz"], "application/vnd.publishare-delta-tree": ["qps"], "application/vnd.pvi.ptid1": ["ptid"], "application/vnd.quark.quarkxpress": ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"], "application/vnd.rar": ["rar"], "application/vnd.realvnc.bed": ["bed"], "application/vnd.recordare.musicxml": ["mxl"], "application/vnd.recordare.musicxml+xml": ["musicxml"], "application/vnd.rig.cryptonote": ["cryptonote"], "application/vnd.rim.cod": ["cod"], "application/vnd.rn-realmedia": ["rm"], "application/vnd.rn-realmedia-vbr": ["rmvb"], "application/vnd.route66.link66+xml": ["link66"], "application/vnd.sailingtracker.track": ["st"], "application/vnd.seemail": ["see"], "application/vnd.sema": ["sema"], "application/vnd.semd": ["semd"], "application/vnd.semf": ["semf"], "application/vnd.shana.informed.formdata": ["ifm"], "application/vnd.shana.informed.formtemplate": ["itp"], "application/vnd.shana.informed.interchange": ["iif"], "application/vnd.shana.informed.package": ["ipk"], "application/vnd.simtech-mindmapper": ["twd", "twds"], "application/vnd.smaf": ["mmf"], "application/vnd.smart.teacher": ["teacher"], "application/vnd.software602.filler.form+xml": ["fo"], "application/vnd.solent.sdkm+xml": ["sdkm", "sdkd"], "application/vnd.spotfire.dxp": ["dxp"], "application/vnd.spotfire.sfs": ["sfs"], "application/vnd.stardivision.calc": ["sdc"], "application/vnd.stardivision.draw": ["sda"], "application/vnd.stardivision.impress": ["sdd"], "application/vnd.stardivision.math": ["smf"], "application/vnd.stardivision.writer": ["sdw", "vor"], "application/vnd.stardivision.writer-global": ["sgl"], "application/vnd.stepmania.package": ["smzip"], "application/vnd.stepmania.stepchart": ["sm"], "application/vnd.sun.wadl+xml": ["wadl"], "application/vnd.sun.xml.calc": ["sxc"], "application/vnd.sun.xml.calc.template": ["stc"], "application/vnd.sun.xml.draw": ["sxd"], "application/vnd.sun.xml.draw.template": ["std"], "application/vnd.sun.xml.impress": ["sxi"], "application/vnd.sun.xml.impress.template": ["sti"], "application/vnd.sun.xml.math": ["sxm"], "application/vnd.sun.xml.writer": ["sxw"], "application/vnd.sun.xml.writer.global": ["sxg"], "application/vnd.sun.xml.writer.template": ["stw"], "application/vnd.sus-calendar": ["sus", "susp"], "application/vnd.svd": ["svd"], "application/vnd.symbian.install": ["sis", "sisx"], "application/vnd.syncml+xml": ["xsm"], "application/vnd.syncml.dm+wbxml": ["bdm"], "application/vnd.syncml.dm+xml": ["xdm"], "application/vnd.syncml.dmddf+xml": ["ddf"], "application/vnd.tao.intent-module-archive": ["tao"], "application/vnd.tcpdump.pcap": ["pcap", "cap", "dmp"], "application/vnd.tmobile-livetv": ["tmo"], "application/vnd.trid.tpt": ["tpt"], "application/vnd.triscape.mxs": ["mxs"], "application/vnd.trueapp": ["tra"], "application/vnd.ufdl": ["ufd", "ufdl"], "application/vnd.uiq.theme": ["utz"], "application/vnd.umajin": ["umj"], "application/vnd.unity": ["unityweb"], "application/vnd.uoml+xml": ["uoml"], "application/vnd.vcx": ["vcx"], "application/vnd.visio": ["vsd", "vst", "vss", "vsw"], "application/vnd.visionary": ["vis"], "application/vnd.vsf": ["vsf"], "application/vnd.wap.wbxml": ["wbxml"], "application/vnd.wap.wmlc": ["wmlc"], "application/vnd.wap.wmlscriptc": ["wmlsc"], "application/vnd.webturbo": ["wtb"], "application/vnd.wolfram.player": ["nbp"], "application/vnd.wordperfect": ["wpd"], "application/vnd.wqd": ["wqd"], "application/vnd.wt.stf": ["stf"], "application/vnd.xara": ["xar"], "application/vnd.xfdl": ["xfdl"], "application/vnd.yamaha.hv-dic": ["hvd"], "application/vnd.yamaha.hv-script": ["hvs"], "application/vnd.yamaha.hv-voice": ["hvp"], "application/vnd.yamaha.openscoreformat": ["osf"], "application/vnd.yamaha.openscoreformat.osfpvg+xml": ["osfpvg"], "application/vnd.yamaha.smaf-audio": ["saf"], "application/vnd.yamaha.smaf-phrase": ["spf"], "application/vnd.yellowriver-custom-menu": ["cmp"], "application/vnd.zul": ["zir", "zirz"], "application/vnd.zzazz.deck+xml": ["zaz"], "application/x-7z-compressed": ["7z"], "application/x-abiword": ["abw"], "application/x-ace-compressed": ["ace"], "application/x-apple-diskimage": ["*dmg"], "application/x-arj": ["arj"], "application/x-authorware-bin": ["aab", "x32", "u32", "vox"], "application/x-authorware-map": ["aam"], "application/x-authorware-seg": ["aas"], "application/x-bcpio": ["bcpio"], "application/x-bdoc": ["*bdoc"], "application/x-bittorrent": ["torrent"], "application/x-blorb": ["blb", "blorb"], "application/x-bzip": ["bz"], "application/x-bzip2": ["bz2", "boz"], "application/x-cbr": ["cbr", "cba", "cbt", "cbz", "cb7"], "application/x-cdlink": ["vcd"], "application/x-cfs-compressed": ["cfs"], "application/x-chat": ["chat"], "application/x-chess-pgn": ["pgn"], "application/x-chrome-extension": ["crx"], "application/x-cocoa": ["cco"], "application/x-conference": ["nsc"], "application/x-cpio": ["cpio"], "application/x-csh": ["csh"], "application/x-debian-package": ["*deb", "udeb"], "application/x-dgc-compressed": ["dgc"], "application/x-director": ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"], "application/x-doom": ["wad"], "application/x-dtbncx+xml": ["ncx"], "application/x-dtbook+xml": ["dtb"], "application/x-dtbresource+xml": ["res"], "application/x-dvi": ["dvi"], "application/x-envoy": ["evy"], "application/x-eva": ["eva"], "application/x-font-bdf": ["bdf"], "application/x-font-ghostscript": ["gsf"], "application/x-font-linux-psf": ["psf"], "application/x-font-pcf": ["pcf"], "application/x-font-snf": ["snf"], "application/x-font-type1": ["pfa", "pfb", "pfm", "afm"], "application/x-freearc": ["arc"], "application/x-futuresplash": ["spl"], "application/x-gca-compressed": ["gca"], "application/x-glulx": ["ulx"], "application/x-gnumeric": ["gnumeric"], "application/x-gramps-xml": ["gramps"], "application/x-gtar": ["gtar"], "application/x-hdf": ["hdf"], "application/x-httpd-php": ["php"], "application/x-install-instructions": ["install"], "application/x-iso9660-image": ["*iso"], "application/x-iwork-keynote-sffkey": ["*key"], "application/x-iwork-numbers-sffnumbers": ["*numbers"], "application/x-iwork-pages-sffpages": ["*pages"], "application/x-java-archive-diff": ["jardiff"], "application/x-java-jnlp-file": ["jnlp"], "application/x-keepass2": ["kdbx"], "application/x-latex": ["latex"], "application/x-lua-bytecode": ["luac"], "application/x-lzh-compressed": ["lzh", "lha"], "application/x-makeself": ["run"], "application/x-mie": ["mie"], "application/x-mobipocket-ebook": ["prc", "mobi"], "application/x-ms-application": ["application"], "application/x-ms-shortcut": ["lnk"], "application/x-ms-wmd": ["wmd"], "application/x-ms-wmz": ["wmz"], "application/x-ms-xbap": ["xbap"], "application/x-msaccess": ["mdb"], "application/x-msbinder": ["obd"], "application/x-mscardfile": ["crd"], "application/x-msclip": ["clp"], "application/x-msdos-program": ["*exe"], "application/x-msdownload": ["*exe", "*dll", "com", "bat", "*msi"], "application/x-msmediaview": ["mvb", "m13", "m14"], "application/x-msmetafile": ["*wmf", "*wmz", "*emf", "emz"], "application/x-msmoney": ["mny"], "application/x-mspublisher": ["pub"], "application/x-msschedule": ["scd"], "application/x-msterminal": ["trm"], "application/x-mswrite": ["wri"], "application/x-netcdf": ["nc", "cdf"], "application/x-ns-proxy-autoconfig": ["pac"], "application/x-nzb": ["nzb"], "application/x-perl": ["pl", "pm"], "application/x-pilot": ["*prc", "*pdb"], "application/x-pkcs12": ["p12", "pfx"], "application/x-pkcs7-certificates": ["p7b", "spc"], "application/x-pkcs7-certreqresp": ["p7r"], "application/x-rar-compressed": ["*rar"], "application/x-redhat-package-manager": ["rpm"], "application/x-research-info-systems": ["ris"], "application/x-sea": ["sea"], "application/x-sh": ["sh"], "application/x-shar": ["shar"], "application/x-shockwave-flash": ["swf"], "application/x-silverlight-app": ["xap"], "application/x-sql": ["sql"], "application/x-stuffit": ["sit"], "application/x-stuffitx": ["sitx"], "application/x-subrip": ["srt"], "application/x-sv4cpio": ["sv4cpio"], "application/x-sv4crc": ["sv4crc"], "application/x-t3vm-image": ["t3"], "application/x-tads": ["gam"], "application/x-tar": ["tar"], "application/x-tcl": ["tcl", "tk"], "application/x-tex": ["tex"], "application/x-tex-tfm": ["tfm"], "application/x-texinfo": ["texinfo", "texi"], "application/x-tgif": ["*obj"], "application/x-ustar": ["ustar"], "application/x-virtualbox-hdd": ["hdd"], "application/x-virtualbox-ova": ["ova"], "application/x-virtualbox-ovf": ["ovf"], "application/x-virtualbox-vbox": ["vbox"], "application/x-virtualbox-vbox-extpack": ["vbox-extpack"], "application/x-virtualbox-vdi": ["vdi"], "application/x-virtualbox-vhd": ["vhd"], "application/x-virtualbox-vmdk": ["vmdk"], "application/x-wais-source": ["src"], "application/x-web-app-manifest+json": ["webapp"], "application/x-x509-ca-cert": ["der", "crt", "pem"], "application/x-xfig": ["fig"], "application/x-xliff+xml": ["*xlf"], "application/x-xpinstall": ["xpi"], "application/x-xz": ["xz"], "application/x-zmachine": ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"], "audio/vnd.dece.audio": ["uva", "uvva"], "audio/vnd.digital-winds": ["eol"], "audio/vnd.dra": ["dra"], "audio/vnd.dts": ["dts"], "audio/vnd.dts.hd": ["dtshd"], "audio/vnd.lucent.voice": ["lvp"], "audio/vnd.ms-playready.media.pya": ["pya"], "audio/vnd.nuera.ecelp4800": ["ecelp4800"], "audio/vnd.nuera.ecelp7470": ["ecelp7470"], "audio/vnd.nuera.ecelp9600": ["ecelp9600"], "audio/vnd.rip": ["rip"], "audio/x-aac": ["aac"], "audio/x-aiff": ["aif", "aiff", "aifc"], "audio/x-caf": ["caf"], "audio/x-flac": ["flac"], "audio/x-m4a": ["*m4a"], "audio/x-matroska": ["mka"], "audio/x-mpegurl": ["m3u"], "audio/x-ms-wax": ["wax"], "audio/x-ms-wma": ["wma"], "audio/x-pn-realaudio": ["ram", "ra"], "audio/x-pn-realaudio-plugin": ["rmp"], "audio/x-realaudio": ["*ra"], "audio/x-wav": ["*wav"], "chemical/x-cdx": ["cdx"], "chemical/x-cif": ["cif"], "chemical/x-cmdf": ["cmdf"], "chemical/x-cml": ["cml"], "chemical/x-csml": ["csml"], "chemical/x-xyz": ["xyz"], "image/prs.btif": ["btif"], "image/prs.pti": ["pti"], "image/vnd.adobe.photoshop": ["psd"], "image/vnd.airzip.accelerator.azv": ["azv"], "image/vnd.dece.graphic": ["uvi", "uvvi", "uvg", "uvvg"], "image/vnd.djvu": ["djvu", "djv"], "image/vnd.dvb.subtitle": ["*sub"], "image/vnd.dwg": ["dwg"], "image/vnd.dxf": ["dxf"], "image/vnd.fastbidsheet": ["fbs"], "image/vnd.fpx": ["fpx"], "image/vnd.fst": ["fst"], "image/vnd.fujixerox.edmics-mmr": ["mmr"], "image/vnd.fujixerox.edmics-rlc": ["rlc"], "image/vnd.microsoft.icon": ["ico"], "image/vnd.ms-dds": ["dds"], "image/vnd.ms-modi": ["mdi"], "image/vnd.ms-photo": ["wdp"], "image/vnd.net-fpx": ["npx"], "image/vnd.pco.b16": ["b16"], "image/vnd.tencent.tap": ["tap"], "image/vnd.valve.source.texture": ["vtf"], "image/vnd.wap.wbmp": ["wbmp"], "image/vnd.xiff": ["xif"], "image/vnd.zbrush.pcx": ["pcx"], "image/x-3ds": ["3ds"], "image/x-cmu-raster": ["ras"], "image/x-cmx": ["cmx"], "image/x-freehand": ["fh", "fhc", "fh4", "fh5", "fh7"], "image/x-icon": ["*ico"], "image/x-jng": ["jng"], "image/x-mrsid-image": ["sid"], "image/x-ms-bmp": ["*bmp"], "image/x-pcx": ["*pcx"], "image/x-pict": ["pic", "pct"], "image/x-portable-anymap": ["pnm"], "image/x-portable-bitmap": ["pbm"], "image/x-portable-graymap": ["pgm"], "image/x-portable-pixmap": ["ppm"], "image/x-rgb": ["rgb"], "image/x-tga": ["tga"], "image/x-xbitmap": ["xbm"], "image/x-xpixmap": ["xpm"], "image/x-xwindowdump": ["xwd"], "message/vnd.wfa.wsc": ["wsc"], "model/vnd.collada+xml": ["dae"], "model/vnd.dwf": ["dwf"], "model/vnd.gdl": ["gdl"], "model/vnd.gtw": ["gtw"], "model/vnd.mts": ["mts"], "model/vnd.opengex": ["ogex"], "model/vnd.parasolid.transmit.binary": ["x_b"], "model/vnd.parasolid.transmit.text": ["x_t"], "model/vnd.sap.vds": ["vds"], "model/vnd.usdz+zip": ["usdz"], "model/vnd.valve.source.compiled-map": ["bsp"], "model/vnd.vtu": ["vtu"], "text/prs.lines.tag": ["dsc"], "text/vnd.curl": ["curl"], "text/vnd.curl.dcurl": ["dcurl"], "text/vnd.curl.mcurl": ["mcurl"], "text/vnd.curl.scurl": ["scurl"], "text/vnd.dvb.subtitle": ["sub"], "text/vnd.fly": ["fly"], "text/vnd.fmi.flexstor": ["flx"], "text/vnd.graphviz": ["gv"], "text/vnd.in3d.3dml": ["3dml"], "text/vnd.in3d.spot": ["spot"], "text/vnd.sun.j2me.app-descriptor": ["jad"], "text/vnd.wap.wml": ["wml"], "text/vnd.wap.wmlscript": ["wmls"], "text/x-asm": ["s", "asm"], "text/x-c": ["c", "cc", "cxx", "cpp", "h", "hh", "dic"], "text/x-component": ["htc"], "text/x-fortran": ["f", "for", "f77", "f90"], "text/x-handlebars-template": ["hbs"], "text/x-java-source": ["java"], "text/x-lua": ["lua"], "text/x-markdown": ["mkd"], "text/x-nfo": ["nfo"], "text/x-opml": ["opml"], "text/x-org": ["*org"], "text/x-pascal": ["p", "pas"], "text/x-processing": ["pde"], "text/x-sass": ["sass"], "text/x-scss": ["scss"], "text/x-setext": ["etx"], "text/x-sfv": ["sfv"], "text/x-suse-ymp": ["ymp"], "text/x-uuencode": ["uu"], "text/x-vcalendar": ["vcs"], "text/x-vcard": ["vcf"], "video/vnd.dece.hd": ["uvh", "uvvh"], "video/vnd.dece.mobile": ["uvm", "uvvm"], "video/vnd.dece.pd": ["uvp", "uvvp"], "video/vnd.dece.sd": ["uvs", "uvvs"], "video/vnd.dece.video": ["uvv", "uvvv"], "video/vnd.dvb.file": ["dvb"], "video/vnd.fvt": ["fvt"], "video/vnd.mpegurl": ["mxu", "m4u"], "video/vnd.ms-playready.media.pyv": ["pyv"], "video/vnd.uvvu.mp4": ["uvu", "uvvu"], "video/vnd.vivo": ["viv"], "video/x-f4v": ["f4v"], "video/x-fli": ["fli"], "video/x-flv": ["flv"], "video/x-m4v": ["m4v"], "video/x-matroska": ["mkv", "mk3d", "mks"], "video/x-mng": ["mng"], "video/x-ms-asf": ["asf", "asx"], "video/x-ms-vob": ["vob"], "video/x-ms-wm": ["wm"], "video/x-ms-wmv": ["wmv"], "video/x-ms-wmx": ["wmx"], "video/x-ms-wvx": ["wvx"], "video/x-msvideo": ["avi"], "video/x-sgi-movie": ["movie"], "video/x-smv": ["smv"], "x-conference/x-cooltalk": ["ice"] };
  }
});

// node_modules/puppeteer/node_modules/mime/index.js
var require_mime = __commonJS({
  "node_modules/puppeteer/node_modules/mime/index.js"(exports, module2) {
    "use strict";
    var Mime = require_Mime();
    module2.exports = new Mime(require_standard(), require_other());
  }
});

// node_modules/puppeteer/lib/Connection.js
var require_Connection = __commonJS({
  "node_modules/puppeteer/lib/Connection.js"(exports, module2) {
    var { assert } = require_helper();
    var { Events } = require_Events();
    var debugProtocol = require_src()("puppeteer:protocol");
    var EventEmitter = require("events");
    var Connection = class extends EventEmitter {
      constructor(url, transport, delay = 0) {
        super();
        this._url = url;
        this._lastId = 0;
        this._callbacks = new Map();
        this._delay = delay;
        this._transport = transport;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = new Map();
        this._closed = false;
      }
      static fromSession(session) {
        return session._connection;
      }
      session(sessionId) {
        return this._sessions.get(sessionId) || null;
      }
      url() {
        return this._url;
      }
      send(method, params = {}) {
        const id = this._rawSend({ method, params });
        return new Promise((resolve, reject) => {
          this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
      }
      _rawSend(message) {
        const id = ++this._lastId;
        message = JSON.stringify(Object.assign({}, message, { id }));
        debugProtocol("SEND \u25BA " + message);
        this._transport.send(message);
        return id;
      }
      async _onMessage(message) {
        if (this._delay)
          await new Promise((f) => setTimeout(f, this._delay));
        debugProtocol("\u25C0 RECV " + message);
        const object = JSON.parse(message);
        if (object.method === "Target.attachedToTarget") {
          const sessionId = object.params.sessionId;
          const session = new CDPSession(this, object.params.targetInfo.type, sessionId);
          this._sessions.set(sessionId, session);
        } else if (object.method === "Target.detachedFromTarget") {
          const session = this._sessions.get(object.params.sessionId);
          if (session) {
            session._onClosed();
            this._sessions.delete(object.params.sessionId);
          }
        }
        if (object.sessionId) {
          const session = this._sessions.get(object.sessionId);
          if (session)
            session._onMessage(object);
        } else if (object.id) {
          const callback = this._callbacks.get(object.id);
          if (callback) {
            this._callbacks.delete(object.id);
            if (object.error)
              callback.reject(createProtocolError(callback.error, callback.method, object));
            else
              callback.resolve(object.result);
          }
        } else {
          this.emit(object.method, object.params);
        }
      }
      _onClose() {
        if (this._closed)
          return;
        this._closed = true;
        this._transport.onmessage = null;
        this._transport.onclose = null;
        for (const callback of this._callbacks.values())
          callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        for (const session of this._sessions.values())
          session._onClosed();
        this._sessions.clear();
        this.emit(Events.Connection.Disconnected);
      }
      dispose() {
        this._onClose();
        this._transport.close();
      }
      async createSession(targetInfo) {
        const { sessionId } = await this.send("Target.attachToTarget", { targetId: targetInfo.targetId, flatten: true });
        return this._sessions.get(sessionId);
      }
    };
    var CDPSession = class extends EventEmitter {
      constructor(connection, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
      }
      send(method, params = {}) {
        if (!this._connection)
          return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));
        const id = this._connection._rawSend({ sessionId: this._sessionId, method, params });
        return new Promise((resolve, reject) => {
          this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
      }
      _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object));
          else
            callback.resolve(object.result);
        } else {
          assert(!object.id);
          this.emit(object.method, object.params);
        }
      }
      async detach() {
        if (!this._connection)
          throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
        await this._connection.send("Target.detachFromTarget", { sessionId: this._sessionId });
      }
      _onClosed() {
        for (const callback of this._callbacks.values())
          callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        this._connection = null;
        this.emit(Events.CDPSession.Disconnected);
      }
    };
    function createProtocolError(error, method, object) {
      let message = `Protocol error (${method}): ${object.error.message}`;
      if ("data" in object.error)
        message += ` ${object.error.data}`;
      return rewriteError(error, message);
    }
    function rewriteError(error, message) {
      error.message = message;
      return error;
    }
    module2.exports = { Connection, CDPSession };
  }
});

// node_modules/puppeteer/lib/Dialog.js
var require_Dialog = __commonJS({
  "node_modules/puppeteer/lib/Dialog.js"(exports, module2) {
    var { assert } = require_helper();
    var Dialog = class {
      constructor(client, type, message, defaultValue = "") {
        this._client = client;
        this._type = type;
        this._message = message;
        this._handled = false;
        this._defaultValue = defaultValue;
      }
      type() {
        return this._type;
      }
      message() {
        return this._message;
      }
      defaultValue() {
        return this._defaultValue;
      }
      async accept(promptText) {
        assert(!this._handled, "Cannot accept dialog which is already handled!");
        this._handled = true;
        await this._client.send("Page.handleJavaScriptDialog", {
          accept: true,
          promptText
        });
      }
      async dismiss() {
        assert(!this._handled, "Cannot dismiss dialog which is already handled!");
        this._handled = true;
        await this._client.send("Page.handleJavaScriptDialog", {
          accept: false
        });
      }
    };
    Dialog.Type = {
      Alert: "alert",
      BeforeUnload: "beforeunload",
      Confirm: "confirm",
      Prompt: "prompt"
    };
    module2.exports = { Dialog };
  }
});

// node_modules/puppeteer/lib/EmulationManager.js
var require_EmulationManager = __commonJS({
  "node_modules/puppeteer/lib/EmulationManager.js"(exports, module2) {
    var EmulationManager = class {
      constructor(client) {
        this._client = client;
        this._emulatingMobile = false;
        this._hasTouch = false;
      }
      async emulateViewport(viewport) {
        const mobile = viewport.isMobile || false;
        const width = viewport.width;
        const height = viewport.height;
        const deviceScaleFactor = viewport.deviceScaleFactor || 1;
        const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
        const hasTouch = viewport.hasTouch || false;
        await Promise.all([
          this._client.send("Emulation.setDeviceMetricsOverride", { mobile, width, height, deviceScaleFactor, screenOrientation }),
          this._client.send("Emulation.setTouchEmulationEnabled", {
            enabled: hasTouch
          })
        ]);
        const reloadNeeded = this._emulatingMobile !== mobile || this._hasTouch !== hasTouch;
        this._emulatingMobile = mobile;
        this._hasTouch = hasTouch;
        return reloadNeeded;
      }
    };
    module2.exports = { EmulationManager };
  }
});

// node_modules/puppeteer/lib/JSHandle.js
var require_JSHandle = __commonJS({
  "node_modules/puppeteer/lib/JSHandle.js"(exports, module2) {
    var { helper, assert, debugError } = require_helper();
    var path = require("path");
    function createJSHandle(context, remoteObject) {
      const frame = context.frame();
      if (remoteObject.subtype === "node" && frame) {
        const frameManager = frame._frameManager;
        return new ElementHandle(context, context._client, remoteObject, frameManager.page(), frameManager);
      }
      return new JSHandle(context, context._client, remoteObject);
    }
    var JSHandle = class {
      constructor(context, client, remoteObject) {
        this._context = context;
        this._client = client;
        this._remoteObject = remoteObject;
        this._disposed = false;
      }
      executionContext() {
        return this._context;
      }
      async getProperty(propertyName) {
        const objectHandle = await this._context.evaluateHandle((object, propertyName2) => {
          const result2 = { __proto__: null };
          result2[propertyName2] = object[propertyName2];
          return result2;
        }, this, propertyName);
        const properties = await objectHandle.getProperties();
        const result = properties.get(propertyName) || null;
        await objectHandle.dispose();
        return result;
      }
      async getProperties() {
        const response = await this._client.send("Runtime.getProperties", {
          objectId: this._remoteObject.objectId,
          ownProperties: true
        });
        const result = new Map();
        for (const property of response.result) {
          if (!property.enumerable)
            continue;
          result.set(property.name, createJSHandle(this._context, property.value));
        }
        return result;
      }
      async jsonValue() {
        if (this._remoteObject.objectId) {
          const response = await this._client.send("Runtime.callFunctionOn", {
            functionDeclaration: "function() { return this; }",
            objectId: this._remoteObject.objectId,
            returnByValue: true,
            awaitPromise: true
          });
          return helper.valueFromRemoteObject(response.result);
        }
        return helper.valueFromRemoteObject(this._remoteObject);
      }
      asElement() {
        return null;
      }
      async dispose() {
        if (this._disposed)
          return;
        this._disposed = true;
        await helper.releaseObject(this._client, this._remoteObject);
      }
      toString() {
        if (this._remoteObject.objectId) {
          const type = this._remoteObject.subtype || this._remoteObject.type;
          return "JSHandle@" + type;
        }
        return "JSHandle:" + helper.valueFromRemoteObject(this._remoteObject);
      }
    };
    var ElementHandle = class extends JSHandle {
      constructor(context, client, remoteObject, page, frameManager) {
        super(context, client, remoteObject);
        this._client = client;
        this._remoteObject = remoteObject;
        this._page = page;
        this._frameManager = frameManager;
        this._disposed = false;
      }
      asElement() {
        return this;
      }
      async contentFrame() {
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: this._remoteObject.objectId
        });
        if (typeof nodeInfo.node.frameId !== "string")
          return null;
        return this._frameManager.frame(nodeInfo.node.frameId);
      }
      async _scrollIntoViewIfNeeded() {
        const error = await this.executionContext().evaluate(async (element, pageJavascriptEnabled) => {
          if (!element.isConnected)
            return "Node is detached from document";
          if (element.nodeType !== Node.ELEMENT_NODE)
            return "Node is not of type HTMLElement";
          if (!pageJavascriptEnabled) {
            element.scrollIntoView({ block: "center", inline: "center", behavior: "instant" });
            return false;
          }
          const visibleRatio = await new Promise((resolve) => {
            const observer = new IntersectionObserver((entries) => {
              resolve(entries[0].intersectionRatio);
              observer.disconnect();
            });
            observer.observe(element);
          });
          if (visibleRatio !== 1)
            element.scrollIntoView({ block: "center", inline: "center", behavior: "instant" });
          return false;
        }, this, this._page._javascriptEnabled);
        if (error)
          throw new Error(error);
      }
      async _clickablePoint() {
        const [result, layoutMetrics] = await Promise.all([
          this._client.send("DOM.getContentQuads", {
            objectId: this._remoteObject.objectId
          }).catch(debugError),
          this._client.send("Page.getLayoutMetrics")
        ]);
        if (!result || !result.quads.length)
          throw new Error("Node is either not visible or not an HTMLElement");
        const { clientWidth, clientHeight } = layoutMetrics.layoutViewport;
        const quads = result.quads.map((quad2) => this._fromProtocolQuad(quad2)).map((quad2) => this._intersectQuadWithViewport(quad2, clientWidth, clientHeight)).filter((quad2) => computeQuadArea(quad2) > 1);
        if (!quads.length)
          throw new Error("Node is either not visible or not an HTMLElement");
        const quad = quads[0];
        let x = 0;
        let y = 0;
        for (const point of quad) {
          x += point.x;
          y += point.y;
        }
        return {
          x: x / 4,
          y: y / 4
        };
      }
      _getBoxModel() {
        return this._client.send("DOM.getBoxModel", {
          objectId: this._remoteObject.objectId
        }).catch((error) => debugError(error));
      }
      _fromProtocolQuad(quad) {
        return [
          { x: quad[0], y: quad[1] },
          { x: quad[2], y: quad[3] },
          { x: quad[4], y: quad[5] },
          { x: quad[6], y: quad[7] }
        ];
      }
      _intersectQuadWithViewport(quad, width, height) {
        return quad.map((point) => ({
          x: Math.min(Math.max(point.x, 0), width),
          y: Math.min(Math.max(point.y, 0), height)
        }));
      }
      async hover() {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.mouse.move(x, y);
      }
      async click(options) {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.mouse.click(x, y, options);
      }
      async uploadFile(...filePaths) {
        const files = filePaths.map((filePath) => path.resolve(filePath));
        const objectId = this._remoteObject.objectId;
        await this._client.send("DOM.setFileInputFiles", { objectId, files });
      }
      async tap() {
        await this._scrollIntoViewIfNeeded();
        const { x, y } = await this._clickablePoint();
        await this._page.touchscreen.tap(x, y);
      }
      async focus() {
        await this.executionContext().evaluate((element) => element.focus(), this);
      }
      async type(text, options) {
        await this.focus();
        await this._page.keyboard.type(text, options);
      }
      async press(key, options) {
        await this.focus();
        await this._page.keyboard.press(key, options);
      }
      async boundingBox() {
        const result = await this._getBoxModel();
        if (!result)
          return null;
        const quad = result.model.border;
        const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
        const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
        const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
        const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
        return { x, y, width, height };
      }
      async boxModel() {
        const result = await this._getBoxModel();
        if (!result)
          return null;
        const { content, padding, border, margin, width, height } = result.model;
        return {
          content: this._fromProtocolQuad(content),
          padding: this._fromProtocolQuad(padding),
          border: this._fromProtocolQuad(border),
          margin: this._fromProtocolQuad(margin),
          width,
          height
        };
      }
      async screenshot(options = {}) {
        let needsViewportReset = false;
        let boundingBox = await this.boundingBox();
        assert(boundingBox, "Node is either not visible or not an HTMLElement");
        const viewport = this._page.viewport();
        if (viewport && (boundingBox.width > viewport.width || boundingBox.height > viewport.height)) {
          const newViewport = {
            width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
            height: Math.max(viewport.height, Math.ceil(boundingBox.height))
          };
          await this._page.setViewport(Object.assign({}, viewport, newViewport));
          needsViewportReset = true;
        }
        await this._scrollIntoViewIfNeeded();
        boundingBox = await this.boundingBox();
        assert(boundingBox, "Node is either not visible or not an HTMLElement");
        assert(boundingBox.width !== 0, "Node has 0 width.");
        assert(boundingBox.height !== 0, "Node has 0 height.");
        const { layoutViewport: { pageX, pageY } } = await this._client.send("Page.getLayoutMetrics");
        const clip = Object.assign({}, boundingBox);
        clip.x += pageX;
        clip.y += pageY;
        const imageData = await this._page.screenshot(Object.assign({}, {
          clip
        }, options));
        if (needsViewportReset)
          await this._page.setViewport(viewport);
        return imageData;
      }
      async $(selector) {
        const handle = await this.executionContext().evaluateHandle((element2, selector2) => element2.querySelector(selector2), this, selector);
        const element = handle.asElement();
        if (element)
          return element;
        await handle.dispose();
        return null;
      }
      async $$(selector) {
        const arrayHandle = await this.executionContext().evaluateHandle((element, selector2) => element.querySelectorAll(selector2), this, selector);
        const properties = await arrayHandle.getProperties();
        await arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
          const elementHandle = property.asElement();
          if (elementHandle)
            result.push(elementHandle);
        }
        return result;
      }
      async $eval(selector, pageFunction, ...args) {
        const elementHandle = await this.$(selector);
        if (!elementHandle)
          throw new Error(`Error: failed to find element matching selector "${selector}"`);
        const result = await this.executionContext().evaluate(pageFunction, elementHandle, ...args);
        await elementHandle.dispose();
        return result;
      }
      async $$eval(selector, pageFunction, ...args) {
        const arrayHandle = await this.executionContext().evaluateHandle((element, selector2) => Array.from(element.querySelectorAll(selector2)), this, selector);
        const result = await this.executionContext().evaluate(pageFunction, arrayHandle, ...args);
        await arrayHandle.dispose();
        return result;
      }
      async $x(expression) {
        const arrayHandle = await this.executionContext().evaluateHandle((element, expression2) => {
          const document2 = element.ownerDocument || element;
          const iterator = document2.evaluate(expression2, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
          const array = [];
          let item;
          while (item = iterator.iterateNext())
            array.push(item);
          return array;
        }, this, expression);
        const properties = await arrayHandle.getProperties();
        await arrayHandle.dispose();
        const result = [];
        for (const property of properties.values()) {
          const elementHandle = property.asElement();
          if (elementHandle)
            result.push(elementHandle);
        }
        return result;
      }
      isIntersectingViewport() {
        return this.executionContext().evaluate(async (element) => {
          const visibleRatio = await new Promise((resolve) => {
            const observer = new IntersectionObserver((entries) => {
              resolve(entries[0].intersectionRatio);
              observer.disconnect();
            });
            observer.observe(element);
          });
          return visibleRatio > 0;
        }, this);
      }
    };
    function computeQuadArea(quad) {
      let area = 0;
      for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
      }
      return Math.abs(area);
    }
    module2.exports = { createJSHandle, JSHandle, ElementHandle };
  }
});

// node_modules/puppeteer/lib/ExecutionContext.js
var require_ExecutionContext = __commonJS({
  "node_modules/puppeteer/lib/ExecutionContext.js"(exports, module2) {
    var { helper, assert } = require_helper();
    var { createJSHandle, JSHandle } = require_JSHandle();
    var EVALUATION_SCRIPT_URL = "__puppeteer_evaluation_script__";
    var SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
    var ExecutionContext = class {
      constructor(client, contextPayload, world) {
        this._client = client;
        this._world = world;
        this._contextId = contextPayload.id;
      }
      frame() {
        return this._world ? this._world.frame() : null;
      }
      async evaluate(pageFunction, ...args) {
        const handle = await this.evaluateHandle(pageFunction, ...args);
        const result = await handle.jsonValue().catch((error) => {
          if (error.message.includes("Object reference chain is too long"))
            return;
          if (error.message.includes("Object couldn't be returned by value"))
            return;
          throw error;
        });
        await handle.dispose();
        return result;
      }
      async evaluateHandle(pageFunction, ...args) {
        const suffix = `//# sourceURL=${EVALUATION_SCRIPT_URL}`;
        if (helper.isString(pageFunction)) {
          const contextId = this._contextId;
          const expression = pageFunction;
          const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + "\n" + suffix;
          const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = await this._client.send("Runtime.evaluate", {
            expression: expressionWithSourceUrl,
            contextId,
            returnByValue: false,
            awaitPromise: true,
            userGesture: true
          }).catch(rewriteError);
          if (exceptionDetails2)
            throw new Error("Evaluation failed: " + helper.getExceptionMessage(exceptionDetails2));
          return createJSHandle(this, remoteObject2);
        }
        if (typeof pageFunction !== "function")
          throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
        let functionText = pageFunction.toString();
        try {
          new Function("(" + functionText + ")");
        } catch (e1) {
          if (functionText.startsWith("async "))
            functionText = "async function " + functionText.substring("async ".length);
          else
            functionText = "function " + functionText;
          try {
            new Function("(" + functionText + ")");
          } catch (e2) {
            throw new Error("Passed function is not well-serializable!");
          }
        }
        let callFunctionOnPromise;
        try {
          callFunctionOnPromise = this._client.send("Runtime.callFunctionOn", {
            functionDeclaration: functionText + "\n" + suffix + "\n",
            executionContextId: this._contextId,
            arguments: args.map(convertArgument.bind(this)),
            returnByValue: false,
            awaitPromise: true,
            userGesture: true
          });
        } catch (err) {
          if (err instanceof TypeError && err.message === "Converting circular structure to JSON")
            err.message += " Are you passing a nested JSHandle?";
          throw err;
        }
        const { exceptionDetails, result: remoteObject } = await callFunctionOnPromise.catch(rewriteError);
        if (exceptionDetails)
          throw new Error("Evaluation failed: " + helper.getExceptionMessage(exceptionDetails));
        return createJSHandle(this, remoteObject);
        function convertArgument(arg) {
          if (typeof arg === "bigint")
            return { unserializableValue: `${arg.toString()}n` };
          if (Object.is(arg, -0))
            return { unserializableValue: "-0" };
          if (Object.is(arg, Infinity))
            return { unserializableValue: "Infinity" };
          if (Object.is(arg, -Infinity))
            return { unserializableValue: "-Infinity" };
          if (Object.is(arg, NaN))
            return { unserializableValue: "NaN" };
          const objectHandle = arg && arg instanceof JSHandle ? arg : null;
          if (objectHandle) {
            if (objectHandle._context !== this)
              throw new Error("JSHandles can be evaluated only in the context they were created!");
            if (objectHandle._disposed)
              throw new Error("JSHandle is disposed!");
            if (objectHandle._remoteObject.unserializableValue)
              return { unserializableValue: objectHandle._remoteObject.unserializableValue };
            if (!objectHandle._remoteObject.objectId)
              return { value: objectHandle._remoteObject.value };
            return { objectId: objectHandle._remoteObject.objectId };
          }
          return { value: arg };
        }
        function rewriteError(error) {
          if (error.message.endsWith("Cannot find context with specified id"))
            throw new Error("Execution context was destroyed, most likely because of a navigation.");
          throw error;
        }
      }
      async queryObjects(prototypeHandle) {
        assert(!prototypeHandle._disposed, "Prototype JSHandle is disposed!");
        assert(prototypeHandle._remoteObject.objectId, "Prototype JSHandle must not be referencing primitive value");
        const response = await this._client.send("Runtime.queryObjects", {
          prototypeObjectId: prototypeHandle._remoteObject.objectId
        });
        return createJSHandle(this, response.objects);
      }
      async _adoptElementHandle(elementHandle) {
        assert(elementHandle.executionContext() !== this, "Cannot adopt handle that already belongs to this execution context");
        assert(this._world, "Cannot adopt handle without DOMWorld");
        const nodeInfo = await this._client.send("DOM.describeNode", {
          objectId: elementHandle._remoteObject.objectId
        });
        const { object } = await this._client.send("DOM.resolveNode", {
          backendNodeId: nodeInfo.node.backendNodeId,
          executionContextId: this._contextId
        });
        return createJSHandle(this, object);
      }
    };
    module2.exports = { ExecutionContext, EVALUATION_SCRIPT_URL };
  }
});

// node_modules/puppeteer/lib/LifecycleWatcher.js
var require_LifecycleWatcher = __commonJS({
  "node_modules/puppeteer/lib/LifecycleWatcher.js"(exports, module2) {
    var { helper, assert } = require_helper();
    var { Events } = require_Events();
    var { TimeoutError } = require_Errors();
    var LifecycleWatcher = class {
      constructor(frameManager, frame, waitUntil, timeout) {
        if (Array.isArray(waitUntil))
          waitUntil = waitUntil.slice();
        else if (typeof waitUntil === "string")
          waitUntil = [waitUntil];
        this._expectedLifecycle = waitUntil.map((value) => {
          const protocolEvent = puppeteerToProtocolLifecycle[value];
          assert(protocolEvent, "Unknown value for options.waitUntil: " + value);
          return protocolEvent;
        });
        this._frameManager = frameManager;
        this._frame = frame;
        this._initialLoaderId = frame._loaderId;
        this._timeout = timeout;
        this._navigationRequest = null;
        this._eventListeners = [
          helper.addEventListener(frameManager._client, Events.CDPSession.Disconnected, () => this._terminate(new Error("Navigation failed because browser has disconnected!"))),
          helper.addEventListener(this._frameManager, Events.FrameManager.LifecycleEvent, this._checkLifecycleComplete.bind(this)),
          helper.addEventListener(this._frameManager, Events.FrameManager.FrameNavigatedWithinDocument, this._navigatedWithinDocument.bind(this)),
          helper.addEventListener(this._frameManager, Events.FrameManager.FrameDetached, this._onFrameDetached.bind(this)),
          helper.addEventListener(this._frameManager.networkManager(), Events.NetworkManager.Request, this._onRequest.bind(this))
        ];
        this._sameDocumentNavigationPromise = new Promise((fulfill) => {
          this._sameDocumentNavigationCompleteCallback = fulfill;
        });
        this._lifecyclePromise = new Promise((fulfill) => {
          this._lifecycleCallback = fulfill;
        });
        this._newDocumentNavigationPromise = new Promise((fulfill) => {
          this._newDocumentNavigationCompleteCallback = fulfill;
        });
        this._timeoutPromise = this._createTimeoutPromise();
        this._terminationPromise = new Promise((fulfill) => {
          this._terminationCallback = fulfill;
        });
        this._checkLifecycleComplete();
      }
      _onRequest(request) {
        if (request.frame() !== this._frame || !request.isNavigationRequest())
          return;
        this._navigationRequest = request;
      }
      _onFrameDetached(frame) {
        if (this._frame === frame) {
          this._terminationCallback.call(null, new Error("Navigating frame was detached"));
          return;
        }
        this._checkLifecycleComplete();
      }
      navigationResponse() {
        return this._navigationRequest ? this._navigationRequest.response() : null;
      }
      _terminate(error) {
        this._terminationCallback.call(null, error);
      }
      sameDocumentNavigationPromise() {
        return this._sameDocumentNavigationPromise;
      }
      newDocumentNavigationPromise() {
        return this._newDocumentNavigationPromise;
      }
      lifecyclePromise() {
        return this._lifecyclePromise;
      }
      timeoutOrTerminationPromise() {
        return Promise.race([this._timeoutPromise, this._terminationPromise]);
      }
      _createTimeoutPromise() {
        if (!this._timeout)
          return new Promise(() => {
          });
        const errorMessage = "Navigation Timeout Exceeded: " + this._timeout + "ms exceeded";
        return new Promise((fulfill) => this._maximumTimer = setTimeout(fulfill, this._timeout)).then(() => new TimeoutError(errorMessage));
      }
      _navigatedWithinDocument(frame) {
        if (frame !== this._frame)
          return;
        this._hasSameDocumentNavigation = true;
        this._checkLifecycleComplete();
      }
      _checkLifecycleComplete() {
        if (!checkLifecycle(this._frame, this._expectedLifecycle))
          return;
        this._lifecycleCallback();
        if (this._frame._loaderId === this._initialLoaderId && !this._hasSameDocumentNavigation)
          return;
        if (this._hasSameDocumentNavigation)
          this._sameDocumentNavigationCompleteCallback();
        if (this._frame._loaderId !== this._initialLoaderId)
          this._newDocumentNavigationCompleteCallback();
        function checkLifecycle(frame, expectedLifecycle) {
          for (const event of expectedLifecycle) {
            if (!frame._lifecycleEvents.has(event))
              return false;
          }
          for (const child of frame.childFrames()) {
            if (!checkLifecycle(child, expectedLifecycle))
              return false;
          }
          return true;
        }
      }
      dispose() {
        helper.removeEventListeners(this._eventListeners);
        clearTimeout(this._maximumTimer);
      }
    };
    var puppeteerToProtocolLifecycle = {
      "load": "load",
      "domcontentloaded": "DOMContentLoaded",
      "networkidle0": "networkIdle",
      "networkidle2": "networkAlmostIdle"
    };
    module2.exports = { LifecycleWatcher };
  }
});

// node_modules/puppeteer/lib/DOMWorld.js
var require_DOMWorld = __commonJS({
  "node_modules/puppeteer/lib/DOMWorld.js"(exports, module2) {
    var fs = require("fs");
    var { helper, assert } = require_helper();
    var { LifecycleWatcher } = require_LifecycleWatcher();
    var { TimeoutError } = require_Errors();
    var readFileAsync = helper.promisify(fs.readFile);
    var DOMWorld = class {
      constructor(frameManager, frame, timeoutSettings) {
        this._frameManager = frameManager;
        this._frame = frame;
        this._timeoutSettings = timeoutSettings;
        this._documentPromise = null;
        this._contextPromise;
        this._contextResolveCallback = null;
        this._setContext(null);
        this._waitTasks = new Set();
        this._detached = false;
      }
      frame() {
        return this._frame;
      }
      _setContext(context) {
        if (context) {
          this._contextResolveCallback.call(null, context);
          this._contextResolveCallback = null;
          for (const waitTask of this._waitTasks)
            waitTask.rerun();
        } else {
          this._documentPromise = null;
          this._contextPromise = new Promise((fulfill) => {
            this._contextResolveCallback = fulfill;
          });
        }
      }
      _hasContext() {
        return !this._contextResolveCallback;
      }
      _detach() {
        this._detached = true;
        for (const waitTask of this._waitTasks)
          waitTask.terminate(new Error("waitForFunction failed: frame got detached."));
      }
      executionContext() {
        if (this._detached)
          throw new Error(`Execution Context is not available in detached frame "${this._frame.url()}" (are you trying to evaluate?)`);
        return this._contextPromise;
      }
      async evaluateHandle(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluateHandle(pageFunction, ...args);
      }
      async evaluate(pageFunction, ...args) {
        const context = await this.executionContext();
        return context.evaluate(pageFunction, ...args);
      }
      async $(selector) {
        const document2 = await this._document();
        const value = await document2.$(selector);
        return value;
      }
      async _document() {
        if (this._documentPromise)
          return this._documentPromise;
        this._documentPromise = this.executionContext().then(async (context) => {
          const document2 = await context.evaluateHandle("document");
          return document2.asElement();
        });
        return this._documentPromise;
      }
      async $x(expression) {
        const document2 = await this._document();
        const value = await document2.$x(expression);
        return value;
      }
      async $eval(selector, pageFunction, ...args) {
        const document2 = await this._document();
        return document2.$eval(selector, pageFunction, ...args);
      }
      async $$eval(selector, pageFunction, ...args) {
        const document2 = await this._document();
        const value = await document2.$$eval(selector, pageFunction, ...args);
        return value;
      }
      async $$(selector) {
        const document2 = await this._document();
        const value = await document2.$$(selector);
        return value;
      }
      async content() {
        return await this.evaluate(() => {
          let retVal = "";
          if (document.doctype)
            retVal = new XMLSerializer().serializeToString(document.doctype);
          if (document.documentElement)
            retVal += document.documentElement.outerHTML;
          return retVal;
        });
      }
      async setContent(html, options = {}) {
        const {
          waitUntil = ["load"],
          timeout = this._timeoutSettings.navigationTimeout()
        } = options;
        await this.evaluate((html2) => {
          document.open();
          document.write(html2);
          document.close();
        }, html);
        const watcher = new LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);
        const error = await Promise.race([
          watcher.timeoutOrTerminationPromise(),
          watcher.lifecyclePromise()
        ]);
        watcher.dispose();
        if (error)
          throw error;
      }
      async addScriptTag(options) {
        const {
          url = null,
          path = null,
          content = null,
          type = ""
        } = options;
        if (url !== null) {
          try {
            const context = await this.executionContext();
            return (await context.evaluateHandle(addScriptUrl, url, type)).asElement();
          } catch (error) {
            throw new Error(`Loading script from ${url} failed`);
          }
        }
        if (path !== null) {
          let contents = await readFileAsync(path, "utf8");
          contents += "//# sourceURL=" + path.replace(/\n/g, "");
          const context = await this.executionContext();
          return (await context.evaluateHandle(addScriptContent, contents, type)).asElement();
        }
        if (content !== null) {
          const context = await this.executionContext();
          return (await context.evaluateHandle(addScriptContent, content, type)).asElement();
        }
        throw new Error("Provide an object with a `url`, `path` or `content` property");
        async function addScriptUrl(url2, type2) {
          const script = document.createElement("script");
          script.src = url2;
          if (type2)
            script.type = type2;
          const promise = new Promise((res, rej) => {
            script.onload = res;
            script.onerror = rej;
          });
          document.head.appendChild(script);
          await promise;
          return script;
        }
        function addScriptContent(content2, type2 = "text/javascript") {
          const script = document.createElement("script");
          script.type = type2;
          script.text = content2;
          let error = null;
          script.onerror = (e) => error = e;
          document.head.appendChild(script);
          if (error)
            throw error;
          return script;
        }
      }
      async addStyleTag(options) {
        const {
          url = null,
          path = null,
          content = null
        } = options;
        if (url !== null) {
          try {
            const context = await this.executionContext();
            return (await context.evaluateHandle(addStyleUrl, url)).asElement();
          } catch (error) {
            throw new Error(`Loading style from ${url} failed`);
          }
        }
        if (path !== null) {
          let contents = await readFileAsync(path, "utf8");
          contents += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
          const context = await this.executionContext();
          return (await context.evaluateHandle(addStyleContent, contents)).asElement();
        }
        if (content !== null) {
          const context = await this.executionContext();
          return (await context.evaluateHandle(addStyleContent, content)).asElement();
        }
        throw new Error("Provide an object with a `url`, `path` or `content` property");
        async function addStyleUrl(url2) {
          const link = document.createElement("link");
          link.rel = "stylesheet";
          link.href = url2;
          const promise = new Promise((res, rej) => {
            link.onload = res;
            link.onerror = rej;
          });
          document.head.appendChild(link);
          await promise;
          return link;
        }
        async function addStyleContent(content2) {
          const style = document.createElement("style");
          style.type = "text/css";
          style.appendChild(document.createTextNode(content2));
          const promise = new Promise((res, rej) => {
            style.onload = res;
            style.onerror = rej;
          });
          document.head.appendChild(style);
          await promise;
          return style;
        }
      }
      async click(selector, options) {
        const handle = await this.$(selector);
        assert(handle, "No node found for selector: " + selector);
        await handle.click(options);
        await handle.dispose();
      }
      async focus(selector) {
        const handle = await this.$(selector);
        assert(handle, "No node found for selector: " + selector);
        await handle.focus();
        await handle.dispose();
      }
      async hover(selector) {
        const handle = await this.$(selector);
        assert(handle, "No node found for selector: " + selector);
        await handle.hover();
        await handle.dispose();
      }
      select(selector, ...values) {
        for (const value of values)
          assert(helper.isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
        return this.$eval(selector, (element, values2) => {
          if (element.nodeName.toLowerCase() !== "select")
            throw new Error("Element is not a <select> element.");
          const options = Array.from(element.options);
          element.value = void 0;
          for (const option of options) {
            option.selected = values2.includes(option.value);
            if (option.selected && !element.multiple)
              break;
          }
          element.dispatchEvent(new Event("input", { "bubbles": true }));
          element.dispatchEvent(new Event("change", { "bubbles": true }));
          return options.filter((option) => option.selected).map((option) => option.value);
        }, values);
      }
      async tap(selector) {
        const handle = await this.$(selector);
        assert(handle, "No node found for selector: " + selector);
        await handle.tap();
        await handle.dispose();
      }
      async type(selector, text, options) {
        const handle = await this.$(selector);
        assert(handle, "No node found for selector: " + selector);
        await handle.type(text, options);
        await handle.dispose();
      }
      waitForSelector(selector, options) {
        return this._waitForSelectorOrXPath(selector, false, options);
      }
      waitForXPath(xpath, options) {
        return this._waitForSelectorOrXPath(xpath, true, options);
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        const {
          polling = "raf",
          timeout = this._timeoutSettings.timeout()
        } = options;
        return new WaitTask(this, pageFunction, "function", polling, timeout, ...args).promise;
      }
      async title() {
        return this.evaluate(() => document.title);
      }
      async _waitForSelectorOrXPath(selectorOrXPath, isXPath, options = {}) {
        const {
          visible: waitForVisible = false,
          hidden: waitForHidden = false,
          timeout = this._timeoutSettings.timeout()
        } = options;
        const polling = waitForVisible || waitForHidden ? "raf" : "mutation";
        const title = `${isXPath ? "XPath" : "selector"} "${selectorOrXPath}"${waitForHidden ? " to be hidden" : ""}`;
        const waitTask = new WaitTask(this, predicate, title, polling, timeout, selectorOrXPath, isXPath, waitForVisible, waitForHidden);
        const handle = await waitTask.promise;
        if (!handle.asElement()) {
          await handle.dispose();
          return null;
        }
        return handle.asElement();
        function predicate(selectorOrXPath2, isXPath2, waitForVisible2, waitForHidden2) {
          const node = isXPath2 ? document.evaluate(selectorOrXPath2, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue : document.querySelector(selectorOrXPath2);
          if (!node)
            return waitForHidden2;
          if (!waitForVisible2 && !waitForHidden2)
            return node;
          const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
          const style = window.getComputedStyle(element);
          const isVisible = style && style.visibility !== "hidden" && hasVisibleBoundingBox();
          const success = waitForVisible2 === isVisible || waitForHidden2 === !isVisible;
          return success ? node : null;
          function hasVisibleBoundingBox() {
            const rect = element.getBoundingClientRect();
            return !!(rect.top || rect.bottom || rect.width || rect.height);
          }
        }
      }
    };
    var WaitTask = class {
      constructor(domWorld, predicateBody, title, polling, timeout, ...args) {
        if (helper.isString(polling))
          assert(polling === "raf" || polling === "mutation", "Unknown polling option: " + polling);
        else if (helper.isNumber(polling))
          assert(polling > 0, "Cannot poll with non-positive interval: " + polling);
        else
          throw new Error("Unknown polling options: " + polling);
        this._domWorld = domWorld;
        this._polling = polling;
        this._timeout = timeout;
        this._predicateBody = helper.isString(predicateBody) ? "return (" + predicateBody + ")" : "return (" + predicateBody + ")(...args)";
        this._args = args;
        this._runCount = 0;
        domWorld._waitTasks.add(this);
        this.promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
        if (timeout) {
          const timeoutError = new TimeoutError(`waiting for ${title} failed: timeout ${timeout}ms exceeded`);
          this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), timeout);
        }
        this.rerun();
      }
      terminate(error) {
        this._terminated = true;
        this._reject(error);
        this._cleanup();
      }
      async rerun() {
        const runCount = ++this._runCount;
        let success = null;
        let error = null;
        try {
          success = await (await this._domWorld.executionContext()).evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);
        } catch (e) {
          error = e;
        }
        if (this._terminated || runCount !== this._runCount) {
          if (success)
            await success.dispose();
          return;
        }
        if (!error && await this._domWorld.evaluate((s) => !s, success).catch((e) => true)) {
          await success.dispose();
          return;
        }
        if (error && error.message.includes("Execution context was destroyed"))
          return;
        if (error && error.message.includes("Cannot find context with specified id"))
          return;
        if (error)
          this._reject(error);
        else
          this._resolve(success);
        this._cleanup();
      }
      _cleanup() {
        clearTimeout(this._timeoutTimer);
        this._domWorld._waitTasks.delete(this);
        this._runningTask = null;
      }
    };
    async function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {
      const predicate = new Function("...args", predicateBody);
      let timedOut = false;
      if (timeout)
        setTimeout(() => timedOut = true, timeout);
      if (polling === "raf")
        return await pollRaf();
      if (polling === "mutation")
        return await pollMutation();
      if (typeof polling === "number")
        return await pollInterval(polling);
      function pollMutation() {
        const success = predicate.apply(null, args);
        if (success)
          return Promise.resolve(success);
        let fulfill;
        const result = new Promise((x) => fulfill = x);
        const observer = new MutationObserver((mutations) => {
          if (timedOut) {
            observer.disconnect();
            fulfill();
          }
          const success2 = predicate.apply(null, args);
          if (success2) {
            observer.disconnect();
            fulfill(success2);
          }
        });
        observer.observe(document, {
          childList: true,
          subtree: true,
          attributes: true
        });
        return result;
      }
      function pollRaf() {
        let fulfill;
        const result = new Promise((x) => fulfill = x);
        onRaf();
        return result;
        function onRaf() {
          if (timedOut) {
            fulfill();
            return;
          }
          const success = predicate.apply(null, args);
          if (success)
            fulfill(success);
          else
            requestAnimationFrame(onRaf);
        }
      }
      function pollInterval(pollInterval2) {
        let fulfill;
        const result = new Promise((x) => fulfill = x);
        onTimeout();
        return result;
        function onTimeout() {
          if (timedOut) {
            fulfill();
            return;
          }
          const success = predicate.apply(null, args);
          if (success)
            fulfill(success);
          else
            setTimeout(onTimeout, pollInterval2);
        }
      }
    }
    module2.exports = { DOMWorld };
  }
});

// node_modules/puppeteer/lib/NetworkManager.js
var require_NetworkManager = __commonJS({
  "node_modules/puppeteer/lib/NetworkManager.js"(exports, module2) {
    var EventEmitter = require("events");
    var { helper, assert, debugError } = require_helper();
    var { Events } = require_Events();
    var NetworkManager = class extends EventEmitter {
      constructor(client, ignoreHTTPSErrors) {
        super();
        this._client = client;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._frameManager = null;
        this._requestIdToRequest = new Map();
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._extraHTTPHeaders = {};
        this._offline = false;
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._userCacheDisabled = false;
        this._requestIdToInterceptionId = new Map();
        this._client.on("Fetch.requestPaused", this._onRequestPaused.bind(this));
        this._client.on("Fetch.authRequired", this._onAuthRequired.bind(this));
        this._client.on("Network.requestWillBeSent", this._onRequestWillBeSent.bind(this));
        this._client.on("Network.requestServedFromCache", this._onRequestServedFromCache.bind(this));
        this._client.on("Network.responseReceived", this._onResponseReceived.bind(this));
        this._client.on("Network.loadingFinished", this._onLoadingFinished.bind(this));
        this._client.on("Network.loadingFailed", this._onLoadingFailed.bind(this));
      }
      async initialize() {
        await this._client.send("Network.enable");
        if (this._ignoreHTTPSErrors)
          await this._client.send("Security.setIgnoreCertificateErrors", { ignore: true });
      }
      setFrameManager(frameManager) {
        this._frameManager = frameManager;
      }
      async authenticate(credentials) {
        this._credentials = credentials;
        await this._updateProtocolRequestInterception();
      }
      async setExtraHTTPHeaders(extraHTTPHeaders) {
        this._extraHTTPHeaders = {};
        for (const key of Object.keys(extraHTTPHeaders)) {
          const value = extraHTTPHeaders[key];
          assert(helper.isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
          this._extraHTTPHeaders[key.toLowerCase()] = value;
        }
        await this._client.send("Network.setExtraHTTPHeaders", { headers: this._extraHTTPHeaders });
      }
      extraHTTPHeaders() {
        return Object.assign({}, this._extraHTTPHeaders);
      }
      async setOfflineMode(value) {
        if (this._offline === value)
          return;
        this._offline = value;
        await this._client.send("Network.emulateNetworkConditions", {
          offline: this._offline,
          latency: 0,
          downloadThroughput: -1,
          uploadThroughput: -1
        });
      }
      async setUserAgent(userAgent) {
        await this._client.send("Network.setUserAgentOverride", { userAgent });
      }
      async setCacheEnabled(enabled) {
        this._userCacheDisabled = !enabled;
        await this._updateProtocolCacheDisabled();
      }
      async setRequestInterception(value) {
        this._userRequestInterceptionEnabled = value;
        await this._updateProtocolRequestInterception();
      }
      async _updateProtocolRequestInterception() {
        const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
        if (enabled === this._protocolRequestInterceptionEnabled)
          return;
        this._protocolRequestInterceptionEnabled = enabled;
        if (enabled) {
          await Promise.all([
            this._updateProtocolCacheDisabled(),
            this._client.send("Fetch.enable", {
              handleAuthRequests: true,
              patterns: [{ urlPattern: "*" }]
            })
          ]);
        } else {
          await Promise.all([
            this._updateProtocolCacheDisabled(),
            this._client.send("Fetch.disable")
          ]);
        }
      }
      async _updateProtocolCacheDisabled() {
        await this._client.send("Network.setCacheDisabled", {
          cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled
        });
      }
      _onRequestWillBeSent(event) {
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
          const requestId = event.requestId;
          const interceptionId = this._requestIdToInterceptionId.get(requestId);
          if (interceptionId) {
            this._onRequest(event, interceptionId);
            this._requestIdToInterceptionId.delete(requestId);
          } else {
            this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
          }
          return;
        }
        this._onRequest(event, null);
      }
      _onAuthRequired(event) {
        let response = "Default";
        if (this._attemptedAuthentications.has(event.requestId)) {
          response = "CancelAuth";
        } else if (this._credentials) {
          response = "ProvideCredentials";
          this._attemptedAuthentications.add(event.requestId);
        }
        const { username, password } = this._credentials || { username: void 0, password: void 0 };
        this._client.send("Fetch.continueWithAuth", {
          requestId: event.requestId,
          authChallengeResponse: { response, username, password }
        }).catch(debugError);
      }
      _onRequestPaused(event) {
        if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {
          this._client.send("Fetch.continueRequest", {
            requestId: event.requestId
          }).catch(debugError);
        }
        const requestId = event.networkId;
        const interceptionId = event.requestId;
        if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {
          const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
          this._onRequest(requestWillBeSentEvent, interceptionId);
          this._requestIdToRequestWillBeSentEvent.delete(requestId);
        } else {
          this._requestIdToInterceptionId.set(requestId, interceptionId);
        }
      }
      _onRequest(event, interceptionId) {
        let redirectChain = [];
        if (event.redirectResponse) {
          const request2 = this._requestIdToRequest.get(event.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, event.redirectResponse);
            redirectChain = request2._redirectChain;
          }
        }
        const frame = event.frameId && this._frameManager ? this._frameManager.frame(event.frameId) : null;
        const request = new Request(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);
        this._requestIdToRequest.set(event.requestId, request);
        this.emit(Events.NetworkManager.Request, request);
      }
      _onRequestServedFromCache(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request)
          request._fromMemoryCache = true;
      }
      _handleRequestRedirect(request, responsePayload) {
        const response = new Response(this._client, request, responsePayload);
        request._response = response;
        request._redirectChain.push(request);
        response._bodyLoadedPromiseFulfill.call(null, new Error("Response body is unavailable for redirect responses"));
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(Events.NetworkManager.Response, response);
        this.emit(Events.NetworkManager.RequestFinished, request);
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = new Response(this._client, request, event.response);
        request._response = response;
        this.emit(Events.NetworkManager.Response, response);
      }
      _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        if (request.response())
          request.response()._bodyLoadedPromiseFulfill.call(null);
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(Events.NetworkManager.RequestFinished, request);
      }
      _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        request._failureText = event.errorText;
        const response = request.response();
        if (response)
          response._bodyLoadedPromiseFulfill.call(null);
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(Events.NetworkManager.RequestFailed, request);
      }
    };
    var Request = class {
      constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {
        this._client = client;
        this._requestId = event.requestId;
        this._isNavigationRequest = event.requestId === event.loaderId && event.type === "Document";
        this._interceptionId = interceptionId;
        this._allowInterception = allowInterception;
        this._interceptionHandled = false;
        this._response = null;
        this._failureText = null;
        this._url = event.request.url;
        this._resourceType = event.type.toLowerCase();
        this._method = event.request.method;
        this._postData = event.request.postData;
        this._headers = {};
        this._frame = frame;
        this._redirectChain = redirectChain;
        for (const key of Object.keys(event.request.headers))
          this._headers[key.toLowerCase()] = event.request.headers[key];
        this._fromMemoryCache = false;
      }
      url() {
        return this._url;
      }
      resourceType() {
        return this._resourceType;
      }
      method() {
        return this._method;
      }
      postData() {
        return this._postData;
      }
      headers() {
        return this._headers;
      }
      response() {
        return this._response;
      }
      frame() {
        return this._frame;
      }
      isNavigationRequest() {
        return this._isNavigationRequest;
      }
      redirectChain() {
        return this._redirectChain.slice();
      }
      failure() {
        if (!this._failureText)
          return null;
        return {
          errorText: this._failureText
        };
      }
      async continue(overrides = {}) {
        if (this._url.startsWith("data:"))
          return;
        assert(this._allowInterception, "Request Interception is not enabled!");
        assert(!this._interceptionHandled, "Request is already handled!");
        const {
          url,
          method,
          postData,
          headers
        } = overrides;
        this._interceptionHandled = true;
        await this._client.send("Fetch.continueRequest", {
          requestId: this._interceptionId,
          url,
          method,
          postData,
          headers: headers ? headersArray(headers) : void 0
        }).catch((error) => {
          debugError(error);
        });
      }
      async respond(response) {
        if (this._url.startsWith("data:"))
          return;
        assert(this._allowInterception, "Request Interception is not enabled!");
        assert(!this._interceptionHandled, "Request is already handled!");
        this._interceptionHandled = true;
        const responseBody = response.body && helper.isString(response.body) ? Buffer.from(response.body) : response.body || null;
        const responseHeaders = {};
        if (response.headers) {
          for (const header of Object.keys(response.headers))
            responseHeaders[header.toLowerCase()] = response.headers[header];
        }
        if (response.contentType)
          responseHeaders["content-type"] = response.contentType;
        if (responseBody && !("content-length" in responseHeaders))
          responseHeaders["content-length"] = String(Buffer.byteLength(responseBody));
        await this._client.send("Fetch.fulfillRequest", {
          requestId: this._interceptionId,
          responseCode: response.status || 200,
          responseHeaders: headersArray(responseHeaders),
          body: responseBody ? responseBody.toString("base64") : void 0
        }).catch((error) => {
          debugError(error);
        });
      }
      async abort(errorCode = "failed") {
        if (this._url.startsWith("data:"))
          return;
        const errorReason = errorReasons[errorCode];
        assert(errorReason, "Unknown error code: " + errorCode);
        assert(this._allowInterception, "Request Interception is not enabled!");
        assert(!this._interceptionHandled, "Request is already handled!");
        this._interceptionHandled = true;
        await this._client.send("Fetch.failRequest", {
          requestId: this._interceptionId,
          errorReason
        }).catch((error) => {
          debugError(error);
        });
      }
    };
    var errorReasons = {
      "aborted": "Aborted",
      "accessdenied": "AccessDenied",
      "addressunreachable": "AddressUnreachable",
      "blockedbyclient": "BlockedByClient",
      "blockedbyresponse": "BlockedByResponse",
      "connectionaborted": "ConnectionAborted",
      "connectionclosed": "ConnectionClosed",
      "connectionfailed": "ConnectionFailed",
      "connectionrefused": "ConnectionRefused",
      "connectionreset": "ConnectionReset",
      "internetdisconnected": "InternetDisconnected",
      "namenotresolved": "NameNotResolved",
      "timedout": "TimedOut",
      "failed": "Failed"
    };
    var Response = class {
      constructor(client, request, responsePayload) {
        this._client = client;
        this._request = request;
        this._contentPromise = null;
        this._bodyLoadedPromise = new Promise((fulfill) => {
          this._bodyLoadedPromiseFulfill = fulfill;
        });
        this._remoteAddress = {
          ip: responsePayload.remoteIPAddress,
          port: responsePayload.remotePort
        };
        this._status = responsePayload.status;
        this._statusText = responsePayload.statusText;
        this._url = request.url();
        this._fromDiskCache = !!responsePayload.fromDiskCache;
        this._fromServiceWorker = !!responsePayload.fromServiceWorker;
        this._headers = {};
        for (const key of Object.keys(responsePayload.headers))
          this._headers[key.toLowerCase()] = responsePayload.headers[key];
        this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
      }
      remoteAddress() {
        return this._remoteAddress;
      }
      url() {
        return this._url;
      }
      ok() {
        return this._status === 0 || this._status >= 200 && this._status <= 299;
      }
      status() {
        return this._status;
      }
      statusText() {
        return this._statusText;
      }
      headers() {
        return this._headers;
      }
      securityDetails() {
        return this._securityDetails;
      }
      buffer() {
        if (!this._contentPromise) {
          this._contentPromise = this._bodyLoadedPromise.then(async (error) => {
            if (error)
              throw error;
            const response = await this._client.send("Network.getResponseBody", {
              requestId: this._request._requestId
            });
            return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
          });
        }
        return this._contentPromise;
      }
      async text() {
        const content = await this.buffer();
        return content.toString("utf8");
      }
      async json() {
        const content = await this.text();
        return JSON.parse(content);
      }
      request() {
        return this._request;
      }
      fromCache() {
        return this._fromDiskCache || this._request._fromMemoryCache;
      }
      fromServiceWorker() {
        return this._fromServiceWorker;
      }
      frame() {
        return this._request.frame();
      }
    };
    var SecurityDetails = class {
      constructor(securityPayload) {
        this._subjectName = securityPayload["subjectName"];
        this._issuer = securityPayload["issuer"];
        this._validFrom = securityPayload["validFrom"];
        this._validTo = securityPayload["validTo"];
        this._protocol = securityPayload["protocol"];
      }
      subjectName() {
        return this._subjectName;
      }
      issuer() {
        return this._issuer;
      }
      validFrom() {
        return this._validFrom;
      }
      validTo() {
        return this._validTo;
      }
      protocol() {
        return this._protocol;
      }
    };
    function headersArray(headers) {
      const result = [];
      for (const name in headers)
        result.push({ name, value: headers[name] + "" });
      return result;
    }
    module2.exports = { Request, Response, NetworkManager, SecurityDetails };
  }
});

// node_modules/puppeteer/lib/FrameManager.js
var require_FrameManager = __commonJS({
  "node_modules/puppeteer/lib/FrameManager.js"(exports, module2) {
    var EventEmitter = require("events");
    var { helper, assert } = require_helper();
    var { Events } = require_Events();
    var { ExecutionContext, EVALUATION_SCRIPT_URL } = require_ExecutionContext();
    var { LifecycleWatcher } = require_LifecycleWatcher();
    var { DOMWorld } = require_DOMWorld();
    var { NetworkManager } = require_NetworkManager();
    var UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
    var FrameManager = class extends EventEmitter {
      constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
        super();
        this._client = client;
        this._page = page;
        this._networkManager = new NetworkManager(client, ignoreHTTPSErrors);
        this._networkManager.setFrameManager(this);
        this._timeoutSettings = timeoutSettings;
        this._frames = new Map();
        this._contextIdToContext = new Map();
        this._isolatedWorlds = new Set();
        this._client.on("Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId));
        this._client.on("Page.frameNavigated", (event) => this._onFrameNavigated(event.frame));
        this._client.on("Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url));
        this._client.on("Page.frameDetached", (event) => this._onFrameDetached(event.frameId));
        this._client.on("Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId));
        this._client.on("Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context));
        this._client.on("Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId));
        this._client.on("Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared());
        this._client.on("Page.lifecycleEvent", (event) => this._onLifecycleEvent(event));
      }
      async initialize() {
        const [, { frameTree }] = await Promise.all([
          this._client.send("Page.enable"),
          this._client.send("Page.getFrameTree")
        ]);
        this._handleFrameTree(frameTree);
        await Promise.all([
          this._client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
          this._client.send("Runtime.enable", {}).then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),
          this._networkManager.initialize()
        ]);
      }
      networkManager() {
        return this._networkManager;
      }
      async navigateFrame(frame, url, options = {}) {
        assertNoLegacyNavigationOptions(options);
        const {
          referer = this._networkManager.extraHTTPHeaders()["referer"],
          waitUntil = ["load"],
          timeout = this._timeoutSettings.navigationTimeout()
        } = options;
        const watcher = new LifecycleWatcher(this, frame, waitUntil, timeout);
        let ensureNewDocumentNavigation = false;
        let error = await Promise.race([
          navigate(this._client, url, referer, frame._id),
          watcher.timeoutOrTerminationPromise()
        ]);
        if (!error) {
          error = await Promise.race([
            watcher.timeoutOrTerminationPromise(),
            ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
          ]);
        }
        watcher.dispose();
        if (error)
          throw error;
        return watcher.navigationResponse();
        async function navigate(client, url2, referrer, frameId) {
          try {
            const response = await client.send("Page.navigate", { url: url2, referrer, frameId });
            ensureNewDocumentNavigation = !!response.loaderId;
            return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
          } catch (error2) {
            return error2;
          }
        }
      }
      async waitForFrameNavigation(frame, options = {}) {
        assertNoLegacyNavigationOptions(options);
        const {
          waitUntil = ["load"],
          timeout = this._timeoutSettings.navigationTimeout()
        } = options;
        const watcher = new LifecycleWatcher(this, frame, waitUntil, timeout);
        const error = await Promise.race([
          watcher.timeoutOrTerminationPromise(),
          watcher.sameDocumentNavigationPromise(),
          watcher.newDocumentNavigationPromise()
        ]);
        watcher.dispose();
        if (error)
          throw error;
        return watcher.navigationResponse();
      }
      _onLifecycleEvent(event) {
        const frame = this._frames.get(event.frameId);
        if (!frame)
          return;
        frame._onLifecycleEvent(event.loaderId, event.name);
        this.emit(Events.FrameManager.LifecycleEvent, frame);
      }
      _onFrameStoppedLoading(frameId) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._onLoadingStopped();
        this.emit(Events.FrameManager.LifecycleEvent, frame);
      }
      _handleFrameTree(frameTree) {
        if (frameTree.frame.parentId)
          this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);
        this._onFrameNavigated(frameTree.frame);
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      page() {
        return this._page;
      }
      mainFrame() {
        return this._mainFrame;
      }
      frames() {
        return Array.from(this._frames.values());
      }
      frame(frameId) {
        return this._frames.get(frameId) || null;
      }
      _onFrameAttached(frameId, parentFrameId) {
        if (this._frames.has(frameId))
          return;
        assert(parentFrameId);
        const parentFrame = this._frames.get(parentFrameId);
        const frame = new Frame(this, this._client, parentFrame, frameId);
        this._frames.set(frame._id, frame);
        this.emit(Events.FrameManager.FrameAttached, frame);
      }
      _onFrameNavigated(framePayload) {
        const isMainFrame = !framePayload.parentId;
        let frame = isMainFrame ? this._mainFrame : this._frames.get(framePayload.id);
        assert(isMainFrame || frame, "We either navigate top level or have old version of the navigated frame");
        if (frame) {
          for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        }
        if (isMainFrame) {
          if (frame) {
            this._frames.delete(frame._id);
            frame._id = framePayload.id;
          } else {
            frame = new Frame(this, this._client, null, framePayload.id);
          }
          this._frames.set(framePayload.id, frame);
          this._mainFrame = frame;
        }
        frame._navigated(framePayload);
        this.emit(Events.FrameManager.FrameNavigated, frame);
      }
      async _ensureIsolatedWorld(name) {
        if (this._isolatedWorlds.has(name))
          return;
        this._isolatedWorlds.add(name);
        await this._client.send("Page.addScriptToEvaluateOnNewDocument", {
          source: `//# sourceURL=${EVALUATION_SCRIPT_URL}`,
          worldName: name
        }), await Promise.all(this.frames().map((frame) => this._client.send("Page.createIsolatedWorld", {
          frameId: frame._id,
          grantUniveralAccess: true,
          worldName: name
        })));
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._navigatedWithinDocument(url);
        this.emit(Events.FrameManager.FrameNavigatedWithinDocument, frame);
        this.emit(Events.FrameManager.FrameNavigated, frame);
      }
      _onFrameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
          this._removeFramesRecursively(frame);
      }
      _onExecutionContextCreated(contextPayload) {
        const frameId = contextPayload.auxData ? contextPayload.auxData.frameId : null;
        const frame = this._frames.get(frameId) || null;
        let world = null;
        if (frame) {
          if (contextPayload.auxData && !!contextPayload.auxData["isDefault"]) {
            world = frame._mainWorld;
          } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame._secondaryWorld._hasContext()) {
            world = frame._secondaryWorld;
          }
        }
        if (contextPayload.auxData && contextPayload.auxData["type"] === "isolated")
          this._isolatedWorlds.add(contextPayload.name);
        const context = new ExecutionContext(this._client, contextPayload, world);
        if (world)
          world._setContext(context);
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        if (context._world)
          context._world._setContext(null);
      }
      _onExecutionContextsCleared() {
        for (const context of this._contextIdToContext.values()) {
          if (context._world)
            context._world._setContext(null);
        }
        this._contextIdToContext.clear();
      }
      executionContextById(contextId) {
        const context = this._contextIdToContext.get(contextId);
        assert(context, "INTERNAL ERROR: missing context with id = " + contextId);
        return context;
      }
      _removeFramesRecursively(frame) {
        for (const child of frame.childFrames())
          this._removeFramesRecursively(child);
        frame._detach();
        this._frames.delete(frame._id);
        this.emit(Events.FrameManager.FrameDetached, frame);
      }
    };
    var Frame = class {
      constructor(frameManager, client, parentFrame, frameId) {
        this._frameManager = frameManager;
        this._client = client;
        this._parentFrame = parentFrame;
        this._url = "";
        this._id = frameId;
        this._detached = false;
        this._loaderId = "";
        this._lifecycleEvents = new Set();
        this._mainWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._secondaryWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._childFrames = new Set();
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
      }
      async goto(url, options) {
        return await this._frameManager.navigateFrame(this, url, options);
      }
      async waitForNavigation(options) {
        return await this._frameManager.waitForFrameNavigation(this, options);
      }
      executionContext() {
        return this._mainWorld.executionContext();
      }
      async evaluateHandle(pageFunction, ...args) {
        return this._mainWorld.evaluateHandle(pageFunction, ...args);
      }
      async evaluate(pageFunction, ...args) {
        return this._mainWorld.evaluate(pageFunction, ...args);
      }
      async $(selector) {
        return this._mainWorld.$(selector);
      }
      async $x(expression) {
        return this._mainWorld.$x(expression);
      }
      async $eval(selector, pageFunction, ...args) {
        return this._mainWorld.$eval(selector, pageFunction, ...args);
      }
      async $$eval(selector, pageFunction, ...args) {
        return this._mainWorld.$$eval(selector, pageFunction, ...args);
      }
      async $$(selector) {
        return this._mainWorld.$$(selector);
      }
      async content() {
        return this._secondaryWorld.content();
      }
      async setContent(html, options = {}) {
        return this._secondaryWorld.setContent(html, options);
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      isDetached() {
        return this._detached;
      }
      async addScriptTag(options) {
        return this._mainWorld.addScriptTag(options);
      }
      async addStyleTag(options) {
        return this._mainWorld.addStyleTag(options);
      }
      async click(selector, options) {
        return this._secondaryWorld.click(selector, options);
      }
      async focus(selector) {
        return this._secondaryWorld.focus(selector);
      }
      async hover(selector) {
        return this._secondaryWorld.hover(selector);
      }
      select(selector, ...values) {
        return this._secondaryWorld.select(selector, ...values);
      }
      async tap(selector) {
        return this._secondaryWorld.tap(selector);
      }
      async type(selector, text, options) {
        return this._mainWorld.type(selector, text, options);
      }
      waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        const xPathPattern = "//";
        if (helper.isString(selectorOrFunctionOrTimeout)) {
          const string = selectorOrFunctionOrTimeout;
          if (string.startsWith(xPathPattern))
            return this.waitForXPath(string, options);
          return this.waitForSelector(string, options);
        }
        if (helper.isNumber(selectorOrFunctionOrTimeout))
          return new Promise((fulfill) => setTimeout(fulfill, selectorOrFunctionOrTimeout));
        if (typeof selectorOrFunctionOrTimeout === "function")
          return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);
        return Promise.reject(new Error("Unsupported target type: " + typeof selectorOrFunctionOrTimeout));
      }
      async waitForSelector(selector, options) {
        const handle = await this._secondaryWorld.waitForSelector(selector, options);
        if (!handle)
          return null;
        const mainExecutionContext = await this._mainWorld.executionContext();
        const result = await mainExecutionContext._adoptElementHandle(handle);
        await handle.dispose();
        return result;
      }
      async waitForXPath(xpath, options) {
        const handle = await this._secondaryWorld.waitForXPath(xpath, options);
        if (!handle)
          return null;
        const mainExecutionContext = await this._mainWorld.executionContext();
        const result = await mainExecutionContext._adoptElementHandle(handle);
        await handle.dispose();
        return result;
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        return this._mainWorld.waitForFunction(pageFunction, options, ...args);
      }
      async title() {
        return this._secondaryWorld.title();
      }
      _navigated(framePayload) {
        this._name = framePayload.name;
        this._navigationURL = framePayload.url;
        this._url = framePayload.url;
      }
      _navigatedWithinDocument(url) {
        this._url = url;
      }
      _onLifecycleEvent(loaderId, name) {
        if (name === "init") {
          this._loaderId = loaderId;
          this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name);
      }
      _onLoadingStopped() {
        this._lifecycleEvents.add("DOMContentLoaded");
        this._lifecycleEvents.add("load");
      }
      _detach() {
        this._detached = true;
        this._mainWorld._detach();
        this._secondaryWorld._detach();
        if (this._parentFrame)
          this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
      }
    };
    function assertNoLegacyNavigationOptions(options) {
      assert(options["networkIdleTimeout"] === void 0, "ERROR: networkIdleTimeout option is no longer supported.");
      assert(options["networkIdleInflight"] === void 0, "ERROR: networkIdleInflight option is no longer supported.");
      assert(options.waitUntil !== "networkidle", 'ERROR: "networkidle" option is no longer supported. Use "networkidle2" instead');
    }
    module2.exports = { FrameManager, Frame };
  }
});

// node_modules/puppeteer/lib/USKeyboardLayout.js
var require_USKeyboardLayout = __commonJS({
  "node_modules/puppeteer/lib/USKeyboardLayout.js"(exports, module2) {
    module2.exports = {
      "0": { "keyCode": 48, "key": "0", "code": "Digit0" },
      "1": { "keyCode": 49, "key": "1", "code": "Digit1" },
      "2": { "keyCode": 50, "key": "2", "code": "Digit2" },
      "3": { "keyCode": 51, "key": "3", "code": "Digit3" },
      "4": { "keyCode": 52, "key": "4", "code": "Digit4" },
      "5": { "keyCode": 53, "key": "5", "code": "Digit5" },
      "6": { "keyCode": 54, "key": "6", "code": "Digit6" },
      "7": { "keyCode": 55, "key": "7", "code": "Digit7" },
      "8": { "keyCode": 56, "key": "8", "code": "Digit8" },
      "9": { "keyCode": 57, "key": "9", "code": "Digit9" },
      "Power": { "key": "Power", "code": "Power" },
      "Eject": { "key": "Eject", "code": "Eject" },
      "Abort": { "keyCode": 3, "code": "Abort", "key": "Cancel" },
      "Help": { "keyCode": 6, "code": "Help", "key": "Help" },
      "Backspace": { "keyCode": 8, "code": "Backspace", "key": "Backspace" },
      "Tab": { "keyCode": 9, "code": "Tab", "key": "Tab" },
      "Numpad5": { "keyCode": 12, "shiftKeyCode": 101, "key": "Clear", "code": "Numpad5", "shiftKey": "5", "location": 3 },
      "NumpadEnter": { "keyCode": 13, "code": "NumpadEnter", "key": "Enter", "text": "\r", "location": 3 },
      "Enter": { "keyCode": 13, "code": "Enter", "key": "Enter", "text": "\r" },
      "\r": { "keyCode": 13, "code": "Enter", "key": "Enter", "text": "\r" },
      "\n": { "keyCode": 13, "code": "Enter", "key": "Enter", "text": "\r" },
      "ShiftLeft": { "keyCode": 16, "code": "ShiftLeft", "key": "Shift", "location": 1 },
      "ShiftRight": { "keyCode": 16, "code": "ShiftRight", "key": "Shift", "location": 2 },
      "ControlLeft": { "keyCode": 17, "code": "ControlLeft", "key": "Control", "location": 1 },
      "ControlRight": { "keyCode": 17, "code": "ControlRight", "key": "Control", "location": 2 },
      "AltLeft": { "keyCode": 18, "code": "AltLeft", "key": "Alt", "location": 1 },
      "AltRight": { "keyCode": 18, "code": "AltRight", "key": "Alt", "location": 2 },
      "Pause": { "keyCode": 19, "code": "Pause", "key": "Pause" },
      "CapsLock": { "keyCode": 20, "code": "CapsLock", "key": "CapsLock" },
      "Escape": { "keyCode": 27, "code": "Escape", "key": "Escape" },
      "Convert": { "keyCode": 28, "code": "Convert", "key": "Convert" },
      "NonConvert": { "keyCode": 29, "code": "NonConvert", "key": "NonConvert" },
      "Space": { "keyCode": 32, "code": "Space", "key": " " },
      "Numpad9": { "keyCode": 33, "shiftKeyCode": 105, "key": "PageUp", "code": "Numpad9", "shiftKey": "9", "location": 3 },
      "PageUp": { "keyCode": 33, "code": "PageUp", "key": "PageUp" },
      "Numpad3": { "keyCode": 34, "shiftKeyCode": 99, "key": "PageDown", "code": "Numpad3", "shiftKey": "3", "location": 3 },
      "PageDown": { "keyCode": 34, "code": "PageDown", "key": "PageDown" },
      "End": { "keyCode": 35, "code": "End", "key": "End" },
      "Numpad1": { "keyCode": 35, "shiftKeyCode": 97, "key": "End", "code": "Numpad1", "shiftKey": "1", "location": 3 },
      "Home": { "keyCode": 36, "code": "Home", "key": "Home" },
      "Numpad7": { "keyCode": 36, "shiftKeyCode": 103, "key": "Home", "code": "Numpad7", "shiftKey": "7", "location": 3 },
      "ArrowLeft": { "keyCode": 37, "code": "ArrowLeft", "key": "ArrowLeft" },
      "Numpad4": { "keyCode": 37, "shiftKeyCode": 100, "key": "ArrowLeft", "code": "Numpad4", "shiftKey": "4", "location": 3 },
      "Numpad8": { "keyCode": 38, "shiftKeyCode": 104, "key": "ArrowUp", "code": "Numpad8", "shiftKey": "8", "location": 3 },
      "ArrowUp": { "keyCode": 38, "code": "ArrowUp", "key": "ArrowUp" },
      "ArrowRight": { "keyCode": 39, "code": "ArrowRight", "key": "ArrowRight" },
      "Numpad6": { "keyCode": 39, "shiftKeyCode": 102, "key": "ArrowRight", "code": "Numpad6", "shiftKey": "6", "location": 3 },
      "Numpad2": { "keyCode": 40, "shiftKeyCode": 98, "key": "ArrowDown", "code": "Numpad2", "shiftKey": "2", "location": 3 },
      "ArrowDown": { "keyCode": 40, "code": "ArrowDown", "key": "ArrowDown" },
      "Select": { "keyCode": 41, "code": "Select", "key": "Select" },
      "Open": { "keyCode": 43, "code": "Open", "key": "Execute" },
      "PrintScreen": { "keyCode": 44, "code": "PrintScreen", "key": "PrintScreen" },
      "Insert": { "keyCode": 45, "code": "Insert", "key": "Insert" },
      "Numpad0": { "keyCode": 45, "shiftKeyCode": 96, "key": "Insert", "code": "Numpad0", "shiftKey": "0", "location": 3 },
      "Delete": { "keyCode": 46, "code": "Delete", "key": "Delete" },
      "NumpadDecimal": { "keyCode": 46, "shiftKeyCode": 110, "code": "NumpadDecimal", "key": "\0", "shiftKey": ".", "location": 3 },
      "Digit0": { "keyCode": 48, "code": "Digit0", "shiftKey": ")", "key": "0" },
      "Digit1": { "keyCode": 49, "code": "Digit1", "shiftKey": "!", "key": "1" },
      "Digit2": { "keyCode": 50, "code": "Digit2", "shiftKey": "@", "key": "2" },
      "Digit3": { "keyCode": 51, "code": "Digit3", "shiftKey": "#", "key": "3" },
      "Digit4": { "keyCode": 52, "code": "Digit4", "shiftKey": "$", "key": "4" },
      "Digit5": { "keyCode": 53, "code": "Digit5", "shiftKey": "%", "key": "5" },
      "Digit6": { "keyCode": 54, "code": "Digit6", "shiftKey": "^", "key": "6" },
      "Digit7": { "keyCode": 55, "code": "Digit7", "shiftKey": "&", "key": "7" },
      "Digit8": { "keyCode": 56, "code": "Digit8", "shiftKey": "*", "key": "8" },
      "Digit9": { "keyCode": 57, "code": "Digit9", "shiftKey": "(", "key": "9" },
      "KeyA": { "keyCode": 65, "code": "KeyA", "shiftKey": "A", "key": "a" },
      "KeyB": { "keyCode": 66, "code": "KeyB", "shiftKey": "B", "key": "b" },
      "KeyC": { "keyCode": 67, "code": "KeyC", "shiftKey": "C", "key": "c" },
      "KeyD": { "keyCode": 68, "code": "KeyD", "shiftKey": "D", "key": "d" },
      "KeyE": { "keyCode": 69, "code": "KeyE", "shiftKey": "E", "key": "e" },
      "KeyF": { "keyCode": 70, "code": "KeyF", "shiftKey": "F", "key": "f" },
      "KeyG": { "keyCode": 71, "code": "KeyG", "shiftKey": "G", "key": "g" },
      "KeyH": { "keyCode": 72, "code": "KeyH", "shiftKey": "H", "key": "h" },
      "KeyI": { "keyCode": 73, "code": "KeyI", "shiftKey": "I", "key": "i" },
      "KeyJ": { "keyCode": 74, "code": "KeyJ", "shiftKey": "J", "key": "j" },
      "KeyK": { "keyCode": 75, "code": "KeyK", "shiftKey": "K", "key": "k" },
      "KeyL": { "keyCode": 76, "code": "KeyL", "shiftKey": "L", "key": "l" },
      "KeyM": { "keyCode": 77, "code": "KeyM", "shiftKey": "M", "key": "m" },
      "KeyN": { "keyCode": 78, "code": "KeyN", "shiftKey": "N", "key": "n" },
      "KeyO": { "keyCode": 79, "code": "KeyO", "shiftKey": "O", "key": "o" },
      "KeyP": { "keyCode": 80, "code": "KeyP", "shiftKey": "P", "key": "p" },
      "KeyQ": { "keyCode": 81, "code": "KeyQ", "shiftKey": "Q", "key": "q" },
      "KeyR": { "keyCode": 82, "code": "KeyR", "shiftKey": "R", "key": "r" },
      "KeyS": { "keyCode": 83, "code": "KeyS", "shiftKey": "S", "key": "s" },
      "KeyT": { "keyCode": 84, "code": "KeyT", "shiftKey": "T", "key": "t" },
      "KeyU": { "keyCode": 85, "code": "KeyU", "shiftKey": "U", "key": "u" },
      "KeyV": { "keyCode": 86, "code": "KeyV", "shiftKey": "V", "key": "v" },
      "KeyW": { "keyCode": 87, "code": "KeyW", "shiftKey": "W", "key": "w" },
      "KeyX": { "keyCode": 88, "code": "KeyX", "shiftKey": "X", "key": "x" },
      "KeyY": { "keyCode": 89, "code": "KeyY", "shiftKey": "Y", "key": "y" },
      "KeyZ": { "keyCode": 90, "code": "KeyZ", "shiftKey": "Z", "key": "z" },
      "MetaLeft": { "keyCode": 91, "code": "MetaLeft", "key": "Meta", "location": 1 },
      "MetaRight": { "keyCode": 92, "code": "MetaRight", "key": "Meta", "location": 2 },
      "ContextMenu": { "keyCode": 93, "code": "ContextMenu", "key": "ContextMenu" },
      "NumpadMultiply": { "keyCode": 106, "code": "NumpadMultiply", "key": "*", "location": 3 },
      "NumpadAdd": { "keyCode": 107, "code": "NumpadAdd", "key": "+", "location": 3 },
      "NumpadSubtract": { "keyCode": 109, "code": "NumpadSubtract", "key": "-", "location": 3 },
      "NumpadDivide": { "keyCode": 111, "code": "NumpadDivide", "key": "/", "location": 3 },
      "F1": { "keyCode": 112, "code": "F1", "key": "F1" },
      "F2": { "keyCode": 113, "code": "F2", "key": "F2" },
      "F3": { "keyCode": 114, "code": "F3", "key": "F3" },
      "F4": { "keyCode": 115, "code": "F4", "key": "F4" },
      "F5": { "keyCode": 116, "code": "F5", "key": "F5" },
      "F6": { "keyCode": 117, "code": "F6", "key": "F6" },
      "F7": { "keyCode": 118, "code": "F7", "key": "F7" },
      "F8": { "keyCode": 119, "code": "F8", "key": "F8" },
      "F9": { "keyCode": 120, "code": "F9", "key": "F9" },
      "F10": { "keyCode": 121, "code": "F10", "key": "F10" },
      "F11": { "keyCode": 122, "code": "F11", "key": "F11" },
      "F12": { "keyCode": 123, "code": "F12", "key": "F12" },
      "F13": { "keyCode": 124, "code": "F13", "key": "F13" },
      "F14": { "keyCode": 125, "code": "F14", "key": "F14" },
      "F15": { "keyCode": 126, "code": "F15", "key": "F15" },
      "F16": { "keyCode": 127, "code": "F16", "key": "F16" },
      "F17": { "keyCode": 128, "code": "F17", "key": "F17" },
      "F18": { "keyCode": 129, "code": "F18", "key": "F18" },
      "F19": { "keyCode": 130, "code": "F19", "key": "F19" },
      "F20": { "keyCode": 131, "code": "F20", "key": "F20" },
      "F21": { "keyCode": 132, "code": "F21", "key": "F21" },
      "F22": { "keyCode": 133, "code": "F22", "key": "F22" },
      "F23": { "keyCode": 134, "code": "F23", "key": "F23" },
      "F24": { "keyCode": 135, "code": "F24", "key": "F24" },
      "NumLock": { "keyCode": 144, "code": "NumLock", "key": "NumLock" },
      "ScrollLock": { "keyCode": 145, "code": "ScrollLock", "key": "ScrollLock" },
      "AudioVolumeMute": { "keyCode": 173, "code": "AudioVolumeMute", "key": "AudioVolumeMute" },
      "AudioVolumeDown": { "keyCode": 174, "code": "AudioVolumeDown", "key": "AudioVolumeDown" },
      "AudioVolumeUp": { "keyCode": 175, "code": "AudioVolumeUp", "key": "AudioVolumeUp" },
      "MediaTrackNext": { "keyCode": 176, "code": "MediaTrackNext", "key": "MediaTrackNext" },
      "MediaTrackPrevious": { "keyCode": 177, "code": "MediaTrackPrevious", "key": "MediaTrackPrevious" },
      "MediaStop": { "keyCode": 178, "code": "MediaStop", "key": "MediaStop" },
      "MediaPlayPause": { "keyCode": 179, "code": "MediaPlayPause", "key": "MediaPlayPause" },
      "Semicolon": { "keyCode": 186, "code": "Semicolon", "shiftKey": ":", "key": ";" },
      "Equal": { "keyCode": 187, "code": "Equal", "shiftKey": "+", "key": "=" },
      "NumpadEqual": { "keyCode": 187, "code": "NumpadEqual", "key": "=", "location": 3 },
      "Comma": { "keyCode": 188, "code": "Comma", "shiftKey": "<", "key": "," },
      "Minus": { "keyCode": 189, "code": "Minus", "shiftKey": "_", "key": "-" },
      "Period": { "keyCode": 190, "code": "Period", "shiftKey": ">", "key": "." },
      "Slash": { "keyCode": 191, "code": "Slash", "shiftKey": "?", "key": "/" },
      "Backquote": { "keyCode": 192, "code": "Backquote", "shiftKey": "~", "key": "`" },
      "BracketLeft": { "keyCode": 219, "code": "BracketLeft", "shiftKey": "{", "key": "[" },
      "Backslash": { "keyCode": 220, "code": "Backslash", "shiftKey": "|", "key": "\\" },
      "BracketRight": { "keyCode": 221, "code": "BracketRight", "shiftKey": "}", "key": "]" },
      "Quote": { "keyCode": 222, "code": "Quote", "shiftKey": '"', "key": "'" },
      "AltGraph": { "keyCode": 225, "code": "AltGraph", "key": "AltGraph" },
      "Props": { "keyCode": 247, "code": "Props", "key": "CrSel" },
      "Cancel": { "keyCode": 3, "key": "Cancel", "code": "Abort" },
      "Clear": { "keyCode": 12, "key": "Clear", "code": "Numpad5", "location": 3 },
      "Shift": { "keyCode": 16, "key": "Shift", "code": "ShiftLeft", "location": 1 },
      "Control": { "keyCode": 17, "key": "Control", "code": "ControlLeft", "location": 1 },
      "Alt": { "keyCode": 18, "key": "Alt", "code": "AltLeft", "location": 1 },
      "Accept": { "keyCode": 30, "key": "Accept" },
      "ModeChange": { "keyCode": 31, "key": "ModeChange" },
      " ": { "keyCode": 32, "key": " ", "code": "Space" },
      "Print": { "keyCode": 42, "key": "Print" },
      "Execute": { "keyCode": 43, "key": "Execute", "code": "Open" },
      "\0": { "keyCode": 46, "key": "\0", "code": "NumpadDecimal", "location": 3 },
      "a": { "keyCode": 65, "key": "a", "code": "KeyA" },
      "b": { "keyCode": 66, "key": "b", "code": "KeyB" },
      "c": { "keyCode": 67, "key": "c", "code": "KeyC" },
      "d": { "keyCode": 68, "key": "d", "code": "KeyD" },
      "e": { "keyCode": 69, "key": "e", "code": "KeyE" },
      "f": { "keyCode": 70, "key": "f", "code": "KeyF" },
      "g": { "keyCode": 71, "key": "g", "code": "KeyG" },
      "h": { "keyCode": 72, "key": "h", "code": "KeyH" },
      "i": { "keyCode": 73, "key": "i", "code": "KeyI" },
      "j": { "keyCode": 74, "key": "j", "code": "KeyJ" },
      "k": { "keyCode": 75, "key": "k", "code": "KeyK" },
      "l": { "keyCode": 76, "key": "l", "code": "KeyL" },
      "m": { "keyCode": 77, "key": "m", "code": "KeyM" },
      "n": { "keyCode": 78, "key": "n", "code": "KeyN" },
      "o": { "keyCode": 79, "key": "o", "code": "KeyO" },
      "p": { "keyCode": 80, "key": "p", "code": "KeyP" },
      "q": { "keyCode": 81, "key": "q", "code": "KeyQ" },
      "r": { "keyCode": 82, "key": "r", "code": "KeyR" },
      "s": { "keyCode": 83, "key": "s", "code": "KeyS" },
      "t": { "keyCode": 84, "key": "t", "code": "KeyT" },
      "u": { "keyCode": 85, "key": "u", "code": "KeyU" },
      "v": { "keyCode": 86, "key": "v", "code": "KeyV" },
      "w": { "keyCode": 87, "key": "w", "code": "KeyW" },
      "x": { "keyCode": 88, "key": "x", "code": "KeyX" },
      "y": { "keyCode": 89, "key": "y", "code": "KeyY" },
      "z": { "keyCode": 90, "key": "z", "code": "KeyZ" },
      "Meta": { "keyCode": 91, "key": "Meta", "code": "MetaLeft", "location": 1 },
      "*": { "keyCode": 106, "key": "*", "code": "NumpadMultiply", "location": 3 },
      "+": { "keyCode": 107, "key": "+", "code": "NumpadAdd", "location": 3 },
      "-": { "keyCode": 109, "key": "-", "code": "NumpadSubtract", "location": 3 },
      "/": { "keyCode": 111, "key": "/", "code": "NumpadDivide", "location": 3 },
      ";": { "keyCode": 186, "key": ";", "code": "Semicolon" },
      "=": { "keyCode": 187, "key": "=", "code": "Equal" },
      ",": { "keyCode": 188, "key": ",", "code": "Comma" },
      ".": { "keyCode": 190, "key": ".", "code": "Period" },
      "`": { "keyCode": 192, "key": "`", "code": "Backquote" },
      "[": { "keyCode": 219, "key": "[", "code": "BracketLeft" },
      "\\": { "keyCode": 220, "key": "\\", "code": "Backslash" },
      "]": { "keyCode": 221, "key": "]", "code": "BracketRight" },
      "'": { "keyCode": 222, "key": "'", "code": "Quote" },
      "Attn": { "keyCode": 246, "key": "Attn" },
      "CrSel": { "keyCode": 247, "key": "CrSel", "code": "Props" },
      "ExSel": { "keyCode": 248, "key": "ExSel" },
      "EraseEof": { "keyCode": 249, "key": "EraseEof" },
      "Play": { "keyCode": 250, "key": "Play" },
      "ZoomOut": { "keyCode": 251, "key": "ZoomOut" },
      ")": { "keyCode": 48, "key": ")", "code": "Digit0" },
      "!": { "keyCode": 49, "key": "!", "code": "Digit1" },
      "@": { "keyCode": 50, "key": "@", "code": "Digit2" },
      "#": { "keyCode": 51, "key": "#", "code": "Digit3" },
      "$": { "keyCode": 52, "key": "$", "code": "Digit4" },
      "%": { "keyCode": 53, "key": "%", "code": "Digit5" },
      "^": { "keyCode": 54, "key": "^", "code": "Digit6" },
      "&": { "keyCode": 55, "key": "&", "code": "Digit7" },
      "(": { "keyCode": 57, "key": "(", "code": "Digit9" },
      "A": { "keyCode": 65, "key": "A", "code": "KeyA" },
      "B": { "keyCode": 66, "key": "B", "code": "KeyB" },
      "C": { "keyCode": 67, "key": "C", "code": "KeyC" },
      "D": { "keyCode": 68, "key": "D", "code": "KeyD" },
      "E": { "keyCode": 69, "key": "E", "code": "KeyE" },
      "F": { "keyCode": 70, "key": "F", "code": "KeyF" },
      "G": { "keyCode": 71, "key": "G", "code": "KeyG" },
      "H": { "keyCode": 72, "key": "H", "code": "KeyH" },
      "I": { "keyCode": 73, "key": "I", "code": "KeyI" },
      "J": { "keyCode": 74, "key": "J", "code": "KeyJ" },
      "K": { "keyCode": 75, "key": "K", "code": "KeyK" },
      "L": { "keyCode": 76, "key": "L", "code": "KeyL" },
      "M": { "keyCode": 77, "key": "M", "code": "KeyM" },
      "N": { "keyCode": 78, "key": "N", "code": "KeyN" },
      "O": { "keyCode": 79, "key": "O", "code": "KeyO" },
      "P": { "keyCode": 80, "key": "P", "code": "KeyP" },
      "Q": { "keyCode": 81, "key": "Q", "code": "KeyQ" },
      "R": { "keyCode": 82, "key": "R", "code": "KeyR" },
      "S": { "keyCode": 83, "key": "S", "code": "KeyS" },
      "T": { "keyCode": 84, "key": "T", "code": "KeyT" },
      "U": { "keyCode": 85, "key": "U", "code": "KeyU" },
      "V": { "keyCode": 86, "key": "V", "code": "KeyV" },
      "W": { "keyCode": 87, "key": "W", "code": "KeyW" },
      "X": { "keyCode": 88, "key": "X", "code": "KeyX" },
      "Y": { "keyCode": 89, "key": "Y", "code": "KeyY" },
      "Z": { "keyCode": 90, "key": "Z", "code": "KeyZ" },
      ":": { "keyCode": 186, "key": ":", "code": "Semicolon" },
      "<": { "keyCode": 188, "key": "<", "code": "Comma" },
      "_": { "keyCode": 189, "key": "_", "code": "Minus" },
      ">": { "keyCode": 190, "key": ">", "code": "Period" },
      "?": { "keyCode": 191, "key": "?", "code": "Slash" },
      "~": { "keyCode": 192, "key": "~", "code": "Backquote" },
      "{": { "keyCode": 219, "key": "{", "code": "BracketLeft" },
      "|": { "keyCode": 220, "key": "|", "code": "Backslash" },
      "}": { "keyCode": 221, "key": "}", "code": "BracketRight" },
      '"': { "keyCode": 222, "key": '"', "code": "Quote" }
    };
  }
});

// node_modules/puppeteer/lib/Input.js
var require_Input = __commonJS({
  "node_modules/puppeteer/lib/Input.js"(exports, module2) {
    var { assert } = require_helper();
    var keyDefinitions = require_USKeyboardLayout();
    var Keyboard = class {
      constructor(client) {
        this._client = client;
        this._modifiers = 0;
        this._pressedKeys = new Set();
      }
      async down(key, options = { text: void 0 }) {
        const description = this._keyDescriptionForString(key);
        const autoRepeat = this._pressedKeys.has(description.code);
        this._pressedKeys.add(description.code);
        this._modifiers |= this._modifierBit(description.key);
        const text = options.text === void 0 ? description.text : options.text;
        await this._client.send("Input.dispatchKeyEvent", {
          type: text ? "keyDown" : "rawKeyDown",
          modifiers: this._modifiers,
          windowsVirtualKeyCode: description.keyCode,
          code: description.code,
          key: description.key,
          text,
          unmodifiedText: text,
          autoRepeat,
          location: description.location,
          isKeypad: description.location === 3
        });
      }
      _modifierBit(key) {
        if (key === "Alt")
          return 1;
        if (key === "Control")
          return 2;
        if (key === "Meta")
          return 4;
        if (key === "Shift")
          return 8;
        return 0;
      }
      _keyDescriptionForString(keyString) {
        const shift = this._modifiers & 8;
        const description = {
          key: "",
          keyCode: 0,
          code: "",
          text: "",
          location: 0
        };
        const definition = keyDefinitions[keyString];
        assert(definition, `Unknown key: "${keyString}"`);
        if (definition.key)
          description.key = definition.key;
        if (shift && definition.shiftKey)
          description.key = definition.shiftKey;
        if (definition.keyCode)
          description.keyCode = definition.keyCode;
        if (shift && definition.shiftKeyCode)
          description.keyCode = definition.shiftKeyCode;
        if (definition.code)
          description.code = definition.code;
        if (definition.location)
          description.location = definition.location;
        if (description.key.length === 1)
          description.text = description.key;
        if (definition.text)
          description.text = definition.text;
        if (shift && definition.shiftText)
          description.text = definition.shiftText;
        if (this._modifiers & ~8)
          description.text = "";
        return description;
      }
      async up(key) {
        const description = this._keyDescriptionForString(key);
        this._modifiers &= ~this._modifierBit(description.key);
        this._pressedKeys.delete(description.code);
        await this._client.send("Input.dispatchKeyEvent", {
          type: "keyUp",
          modifiers: this._modifiers,
          key: description.key,
          windowsVirtualKeyCode: description.keyCode,
          code: description.code,
          location: description.location
        });
      }
      async sendCharacter(char) {
        await this._client.send("Input.insertText", { text: char });
      }
      async type(text, options) {
        let delay = 0;
        if (options && options.delay)
          delay = options.delay;
        for (const char of text) {
          if (keyDefinitions[char])
            await this.press(char, { delay });
          else
            await this.sendCharacter(char);
          if (delay)
            await new Promise((f) => setTimeout(f, delay));
        }
      }
      async press(key, options = {}) {
        const { delay = null } = options;
        await this.down(key, options);
        if (delay !== null)
          await new Promise((f) => setTimeout(f, options.delay));
        await this.up(key);
      }
    };
    var Mouse = class {
      constructor(client, keyboard) {
        this._client = client;
        this._keyboard = keyboard;
        this._x = 0;
        this._y = 0;
        this._button = "none";
      }
      async move(x, y, options = {}) {
        const { steps = 1 } = options;
        const fromX = this._x, fromY = this._y;
        this._x = x;
        this._y = y;
        for (let i = 1; i <= steps; i++) {
          await this._client.send("Input.dispatchMouseEvent", {
            type: "mouseMoved",
            button: this._button,
            x: fromX + (this._x - fromX) * (i / steps),
            y: fromY + (this._y - fromY) * (i / steps),
            modifiers: this._keyboard._modifiers
          });
        }
      }
      async click(x, y, options = {}) {
        const { delay = null } = options;
        this.move(x, y);
        this.down(options);
        if (delay !== null)
          await new Promise((f) => setTimeout(f, delay));
        await this.up(options);
      }
      async down(options = {}) {
        const { button = "left", clickCount = 1 } = options;
        this._button = button;
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mousePressed",
          button,
          x: this._x,
          y: this._y,
          modifiers: this._keyboard._modifiers,
          clickCount
        });
      }
      async up(options = {}) {
        const { button = "left", clickCount = 1 } = options;
        this._button = "none";
        await this._client.send("Input.dispatchMouseEvent", {
          type: "mouseReleased",
          button,
          x: this._x,
          y: this._y,
          modifiers: this._keyboard._modifiers,
          clickCount
        });
      }
    };
    var Touchscreen = class {
      constructor(client, keyboard) {
        this._client = client;
        this._keyboard = keyboard;
      }
      async tap(x, y) {
        await this._client.send("Runtime.evaluate", {
          expression: "new Promise(x => requestAnimationFrame(() => requestAnimationFrame(x)))",
          awaitPromise: true
        });
        const touchPoints = [{ x: Math.round(x), y: Math.round(y) }];
        await this._client.send("Input.dispatchTouchEvent", {
          type: "touchStart",
          touchPoints,
          modifiers: this._keyboard._modifiers
        });
        await this._client.send("Input.dispatchTouchEvent", {
          type: "touchEnd",
          touchPoints: [],
          modifiers: this._keyboard._modifiers
        });
      }
    };
    module2.exports = { Keyboard, Mouse, Touchscreen };
  }
});

// node_modules/puppeteer/lib/Tracing.js
var require_Tracing = __commonJS({
  "node_modules/puppeteer/lib/Tracing.js"(exports, module2) {
    var { helper, assert } = require_helper();
    var fs = require("fs");
    var openAsync = helper.promisify(fs.open);
    var writeAsync = helper.promisify(fs.write);
    var closeAsync = helper.promisify(fs.close);
    var Tracing = class {
      constructor(client) {
        this._client = client;
        this._recording = false;
        this._path = "";
      }
      async start(options = {}) {
        assert(!this._recording, "Cannot start recording trace while already recording trace.");
        const defaultCategories = [
          "-*",
          "devtools.timeline",
          "v8.execute",
          "disabled-by-default-devtools.timeline",
          "disabled-by-default-devtools.timeline.frame",
          "toplevel",
          "blink.console",
          "blink.user_timing",
          "latencyInfo",
          "disabled-by-default-devtools.timeline.stack",
          "disabled-by-default-v8.cpu_profiler",
          "disabled-by-default-v8.cpu_profiler.hires"
        ];
        const {
          path = null,
          screenshots = false,
          categories = defaultCategories
        } = options;
        if (screenshots)
          categories.push("disabled-by-default-devtools.screenshot");
        this._path = path;
        this._recording = true;
        await this._client.send("Tracing.start", {
          transferMode: "ReturnAsStream",
          categories: categories.join(",")
        });
      }
      async stop() {
        let fulfill;
        const contentPromise = new Promise((x) => fulfill = x);
        this._client.once("Tracing.tracingComplete", (event) => {
          this._readStream(event.stream, this._path).then(fulfill);
        });
        await this._client.send("Tracing.end");
        this._recording = false;
        return contentPromise;
      }
      async _readStream(handle, path) {
        let eof = false;
        let file;
        if (path)
          file = await openAsync(path, "w");
        const bufs = [];
        while (!eof) {
          const response = await this._client.send("IO.read", { handle });
          eof = response.eof;
          bufs.push(Buffer.from(response.data));
          if (path)
            await writeAsync(file, response.data);
        }
        if (path)
          await closeAsync(file);
        await this._client.send("IO.close", { handle });
        let resultBuffer = null;
        try {
          resultBuffer = Buffer.concat(bufs);
        } finally {
          return resultBuffer;
        }
      }
    };
    module2.exports = Tracing;
  }
});

// node_modules/puppeteer/lib/Coverage.js
var require_Coverage = __commonJS({
  "node_modules/puppeteer/lib/Coverage.js"(exports, module2) {
    var { helper, debugError, assert } = require_helper();
    var { EVALUATION_SCRIPT_URL } = require_ExecutionContext();
    var Coverage = class {
      constructor(client) {
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
      }
      async startJSCoverage(options) {
        return await this._jsCoverage.start(options);
      }
      async stopJSCoverage() {
        return await this._jsCoverage.stop();
      }
      async startCSSCoverage(options) {
        return await this._cssCoverage.start(options);
      }
      async stopCSSCoverage() {
        return await this._cssCoverage.stop();
      }
    };
    module2.exports = { Coverage };
    var JSCoverage = class {
      constructor(client) {
        this._client = client;
        this._enabled = false;
        this._scriptURLs = new Map();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      async start(options = {}) {
        assert(!this._enabled, "JSCoverage is already enabled");
        const {
          resetOnNavigation = true,
          reportAnonymousScripts = false
        } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._reportAnonymousScripts = reportAnonymousScripts;
        this._enabled = true;
        this._scriptURLs.clear();
        this._scriptSources.clear();
        this._eventListeners = [
          helper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)),
          helper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))
        ];
        await Promise.all([
          this._client.send("Profiler.enable"),
          this._client.send("Profiler.startPreciseCoverage", { callCount: false, detailed: true }),
          this._client.send("Debugger.enable"),
          this._client.send("Debugger.setSkipAllPauses", { skip: true })
        ]);
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._scriptURLs.clear();
        this._scriptSources.clear();
      }
      async _onScriptParsed(event) {
        if (event.url === EVALUATION_SCRIPT_URL)
          return;
        if (!event.url && !this._reportAnonymousScripts)
          return;
        try {
          const response = await this._client.send("Debugger.getScriptSource", { scriptId: event.scriptId });
          this._scriptURLs.set(event.scriptId, event.url);
          this._scriptSources.set(event.scriptId, response.scriptSource);
        } catch (e) {
          debugError(e);
        }
      }
      async stop() {
        assert(this._enabled, "JSCoverage is not enabled");
        this._enabled = false;
        const [profileResponse] = await Promise.all([
          this._client.send("Profiler.takePreciseCoverage"),
          this._client.send("Profiler.stopPreciseCoverage"),
          this._client.send("Profiler.disable"),
          this._client.send("Debugger.disable")
        ]);
        helper.removeEventListeners(this._eventListeners);
        const coverage = [];
        for (const entry of profileResponse.result) {
          let url = this._scriptURLs.get(entry.scriptId);
          if (!url && this._reportAnonymousScripts)
            url = "debugger://VM" + entry.scriptId;
          const text = this._scriptSources.get(entry.scriptId);
          if (text === void 0 || url === void 0)
            continue;
          const flattenRanges = [];
          for (const func of entry.functions)
            flattenRanges.push(...func.ranges);
          const ranges = convertToDisjointRanges(flattenRanges);
          coverage.push({ url, ranges, text });
        }
        return coverage;
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      async start(options = {}) {
        assert(!this._enabled, "CSSCoverage is already enabled");
        const { resetOnNavigation = true } = options;
        this._resetOnNavigation = resetOnNavigation;
        this._enabled = true;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
        this._eventListeners = [
          helper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)),
          helper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))
        ];
        await Promise.all([
          this._client.send("DOM.enable"),
          this._client.send("CSS.enable"),
          this._client.send("CSS.startRuleUsageTracking")
        ]);
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
      }
      async _onStyleSheet(event) {
        const header = event.header;
        if (!header.sourceURL)
          return;
        try {
          const response = await this._client.send("CSS.getStyleSheetText", { styleSheetId: header.styleSheetId });
          this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
          this._stylesheetSources.set(header.styleSheetId, response.text);
        } catch (e) {
          debugError(e);
        }
      }
      async stop() {
        assert(this._enabled, "CSSCoverage is not enabled");
        this._enabled = false;
        const ruleTrackingResponse = await this._client.send("CSS.stopRuleUsageTracking");
        await Promise.all([
          this._client.send("CSS.disable"),
          this._client.send("DOM.disable")
        ]);
        helper.removeEventListeners(this._eventListeners);
        const styleSheetIdToCoverage = new Map();
        for (const entry of ruleTrackingResponse.ruleUsage) {
          let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
          if (!ranges) {
            ranges = [];
            styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
          }
          ranges.push({
            startOffset: entry.startOffset,
            endOffset: entry.endOffset,
            count: entry.used ? 1 : 0
          });
        }
        const coverage = [];
        for (const styleSheetId of this._stylesheetURLs.keys()) {
          const url = this._stylesheetURLs.get(styleSheetId);
          const text = this._stylesheetSources.get(styleSheetId);
          const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
          coverage.push({ url, ranges, text });
        }
        return coverage;
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset)
          return a.offset - b.offset;
        if (a.type !== b.type)
          return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0)
          return bLength - aLength;
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results.length ? results[results.length - 1] : null;
          if (lastResult && lastResult.end === lastOffset)
            lastResult.end = point.offset;
          else
            results.push({ start: lastOffset, end: point.offset });
        }
        lastOffset = point.offset;
        if (point.type === 0)
          hitCountStack.push(point.range.count);
        else
          hitCountStack.pop();
      }
      return results.filter((range) => range.end - range.start > 1);
    }
  }
});

// node_modules/puppeteer/lib/Worker.js
var require_Worker = __commonJS({
  "node_modules/puppeteer/lib/Worker.js"(exports, module2) {
    var EventEmitter = require("events");
    var { debugError } = require_helper();
    var { ExecutionContext } = require_ExecutionContext();
    var { JSHandle } = require_JSHandle();
    var Worker = class extends EventEmitter {
      constructor(client, url, consoleAPICalled, exceptionThrown) {
        super();
        this._client = client;
        this._url = url;
        this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
        let jsHandleFactory;
        this._client.once("Runtime.executionContextCreated", async (event) => {
          jsHandleFactory = (remoteObject) => new JSHandle(executionContext, client, remoteObject);
          const executionContext = new ExecutionContext(client, event.context, null);
          this._executionContextCallback(executionContext);
        });
        this._client.send("Runtime.enable", {}).catch(debugError);
        this._client.on("Runtime.consoleAPICalled", (event) => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));
        this._client.on("Runtime.exceptionThrown", (exception) => exceptionThrown(exception.exceptionDetails));
      }
      url() {
        return this._url;
      }
      async executionContext() {
        return this._executionContextPromise;
      }
      async evaluate(pageFunction, ...args) {
        return (await this._executionContextPromise).evaluate(pageFunction, ...args);
      }
      async evaluateHandle(pageFunction, ...args) {
        return (await this._executionContextPromise).evaluateHandle(pageFunction, ...args);
      }
    };
    module2.exports = { Worker };
  }
});

// node_modules/puppeteer/lib/TimeoutSettings.js
var require_TimeoutSettings = __commonJS({
  "node_modules/puppeteer/lib/TimeoutSettings.js"(exports, module2) {
    var DEFAULT_TIMEOUT = 3e4;
    var TimeoutSettings = class {
      constructor() {
        this._defaultTimeout = null;
        this._defaultNavigationTimeout = null;
      }
      setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
      }
      setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
      }
      navigationTimeout() {
        if (this._defaultNavigationTimeout !== null)
          return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== null)
          return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
      }
      timeout() {
        if (this._defaultTimeout !== null)
          return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
      }
    };
    module2.exports = { TimeoutSettings };
  }
});

// node_modules/puppeteer/lib/Page.js
var require_Page = __commonJS({
  "node_modules/puppeteer/lib/Page.js"(exports, module2) {
    var fs = require("fs");
    var EventEmitter = require("events");
    var mime = require_mime();
    var { Events } = require_Events();
    var { Connection } = require_Connection();
    var { Dialog } = require_Dialog();
    var { EmulationManager } = require_EmulationManager();
    var { FrameManager } = require_FrameManager();
    var { Keyboard, Mouse, Touchscreen } = require_Input();
    var Tracing = require_Tracing();
    var { helper, debugError, assert } = require_helper();
    var { Coverage } = require_Coverage();
    var { Worker } = require_Worker();
    var { createJSHandle } = require_JSHandle();
    var { Accessibility } = require_Accessibility();
    var { TimeoutSettings } = require_TimeoutSettings();
    var writeFileAsync = helper.promisify(fs.writeFile);
    var Page = class extends EventEmitter {
      static async create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
        const page = new Page(client, target, ignoreHTTPSErrors, screenshotTaskQueue);
        await Promise.all([
          page._frameManager.initialize(),
          client.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: false, flatten: true }),
          client.send("Performance.enable", {}),
          client.send("Log.enable", {})
        ]);
        if (defaultViewport)
          await page.setViewport(defaultViewport);
        return page;
      }
      constructor(client, target, ignoreHTTPSErrors, screenshotTaskQueue) {
        super();
        this._closed = false;
        this._client = client;
        this._target = target;
        this._keyboard = new Keyboard(client);
        this._mouse = new Mouse(client, this._keyboard);
        this._timeoutSettings = new TimeoutSettings();
        this._touchscreen = new Touchscreen(client, this._keyboard);
        this._accessibility = new Accessibility(client);
        this._frameManager = new FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
        this._emulationManager = new EmulationManager(client);
        this._tracing = new Tracing(client);
        this._pageBindings = new Map();
        this._coverage = new Coverage(client);
        this._javascriptEnabled = true;
        this._viewport = null;
        this._screenshotTaskQueue = screenshotTaskQueue;
        this._workers = new Map();
        client.on("Target.attachedToTarget", (event) => {
          if (event.targetInfo.type !== "worker") {
            client.send("Target.detachFromTarget", {
              sessionId: event.sessionId
            }).catch(debugError);
            return;
          }
          const session = Connection.fromSession(client).session(event.sessionId);
          const worker = new Worker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this));
          this._workers.set(event.sessionId, worker);
          this.emit(Events.Page.WorkerCreated, worker);
        });
        client.on("Target.detachedFromTarget", (event) => {
          const worker = this._workers.get(event.sessionId);
          if (!worker)
            return;
          this.emit(Events.Page.WorkerDestroyed, worker);
          this._workers.delete(event.sessionId);
        });
        this._frameManager.on(Events.FrameManager.FrameAttached, (event) => this.emit(Events.Page.FrameAttached, event));
        this._frameManager.on(Events.FrameManager.FrameDetached, (event) => this.emit(Events.Page.FrameDetached, event));
        this._frameManager.on(Events.FrameManager.FrameNavigated, (event) => this.emit(Events.Page.FrameNavigated, event));
        const networkManager = this._frameManager.networkManager();
        networkManager.on(Events.NetworkManager.Request, (event) => this.emit(Events.Page.Request, event));
        networkManager.on(Events.NetworkManager.Response, (event) => this.emit(Events.Page.Response, event));
        networkManager.on(Events.NetworkManager.RequestFailed, (event) => this.emit(Events.Page.RequestFailed, event));
        networkManager.on(Events.NetworkManager.RequestFinished, (event) => this.emit(Events.Page.RequestFinished, event));
        client.on("Page.domContentEventFired", (event) => this.emit(Events.Page.DOMContentLoaded));
        client.on("Page.loadEventFired", (event) => this.emit(Events.Page.Load));
        client.on("Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event));
        client.on("Runtime.bindingCalled", (event) => this._onBindingCalled(event));
        client.on("Page.javascriptDialogOpening", (event) => this._onDialog(event));
        client.on("Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails));
        client.on("Inspector.targetCrashed", (event) => this._onTargetCrashed());
        client.on("Performance.metrics", (event) => this._emitMetrics(event));
        client.on("Log.entryAdded", (event) => this._onLogEntryAdded(event));
        this._target._isClosedPromise.then(() => {
          this.emit(Events.Page.Close);
          this._closed = true;
        });
      }
      async setGeolocation(options) {
        const { longitude, latitude, accuracy = 0 } = options;
        if (longitude < -180 || longitude > 180)
          throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
        if (latitude < -90 || latitude > 90)
          throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
        if (accuracy < 0)
          throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
        await this._client.send("Emulation.setGeolocationOverride", { longitude, latitude, accuracy });
      }
      target() {
        return this._target;
      }
      browser() {
        return this._target.browser();
      }
      browserContext() {
        return this._target.browserContext();
      }
      _onTargetCrashed() {
        this.emit("error", new Error("Page crashed!"));
      }
      _onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args)
          args.map((arg) => helper.releaseObject(this._client, arg));
        if (source !== "worker")
          this.emit(Events.Page.Console, new ConsoleMessage(level, text, [], { url, lineNumber }));
      }
      mainFrame() {
        return this._frameManager.mainFrame();
      }
      get keyboard() {
        return this._keyboard;
      }
      get touchscreen() {
        return this._touchscreen;
      }
      get coverage() {
        return this._coverage;
      }
      get tracing() {
        return this._tracing;
      }
      get accessibility() {
        return this._accessibility;
      }
      frames() {
        return this._frameManager.frames();
      }
      workers() {
        return Array.from(this._workers.values());
      }
      async setRequestInterception(value) {
        return this._frameManager.networkManager().setRequestInterception(value);
      }
      setOfflineMode(enabled) {
        return this._frameManager.networkManager().setOfflineMode(enabled);
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      async $(selector) {
        return this.mainFrame().$(selector);
      }
      async evaluateHandle(pageFunction, ...args) {
        const context = await this.mainFrame().executionContext();
        return context.evaluateHandle(pageFunction, ...args);
      }
      async queryObjects(prototypeHandle) {
        const context = await this.mainFrame().executionContext();
        return context.queryObjects(prototypeHandle);
      }
      async $eval(selector, pageFunction, ...args) {
        return this.mainFrame().$eval(selector, pageFunction, ...args);
      }
      async $$eval(selector, pageFunction, ...args) {
        return this.mainFrame().$$eval(selector, pageFunction, ...args);
      }
      async $$(selector) {
        return this.mainFrame().$$(selector);
      }
      async $x(expression) {
        return this.mainFrame().$x(expression);
      }
      async cookies(...urls) {
        return (await this._client.send("Network.getCookies", {
          urls: urls.length ? urls : [this.url()]
        })).cookies;
      }
      async deleteCookie(...cookies) {
        const pageURL = this.url();
        for (const cookie of cookies) {
          const item = Object.assign({}, cookie);
          if (!cookie.url && pageURL.startsWith("http"))
            item.url = pageURL;
          await this._client.send("Network.deleteCookies", item);
        }
      }
      async setCookie(...cookies) {
        const pageURL = this.url();
        const startsWithHTTP = pageURL.startsWith("http");
        const items = cookies.map((cookie) => {
          const item = Object.assign({}, cookie);
          if (!item.url && startsWithHTTP)
            item.url = pageURL;
          assert(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
          assert(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
          return item;
        });
        await this.deleteCookie(...items);
        if (items.length)
          await this._client.send("Network.setCookies", { cookies: items });
      }
      async addScriptTag(options) {
        return this.mainFrame().addScriptTag(options);
      }
      async addStyleTag(options) {
        return this.mainFrame().addStyleTag(options);
      }
      async exposeFunction(name, puppeteerFunction) {
        if (this._pageBindings.has(name))
          throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
        this._pageBindings.set(name, puppeteerFunction);
        const expression = helper.evaluationString(addPageBinding, name);
        await this._client.send("Runtime.addBinding", { name });
        await this._client.send("Page.addScriptToEvaluateOnNewDocument", { source: expression });
        await Promise.all(this.frames().map((frame) => frame.evaluate(expression).catch(debugError)));
        function addPageBinding(bindingName) {
          const binding = window[bindingName];
          window[bindingName] = (...args) => {
            const me = window[bindingName];
            let callbacks = me["callbacks"];
            if (!callbacks) {
              callbacks = new Map();
              me["callbacks"] = callbacks;
            }
            const seq = (me["lastSeq"] || 0) + 1;
            me["lastSeq"] = seq;
            const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
            binding(JSON.stringify({ name: bindingName, seq, args }));
            return promise;
          };
        }
      }
      async authenticate(credentials) {
        return this._frameManager.networkManager().authenticate(credentials);
      }
      async setExtraHTTPHeaders(headers) {
        return this._frameManager.networkManager().setExtraHTTPHeaders(headers);
      }
      async setUserAgent(userAgent) {
        return this._frameManager.networkManager().setUserAgent(userAgent);
      }
      async metrics() {
        const response = await this._client.send("Performance.getMetrics");
        return this._buildMetricsObject(response.metrics);
      }
      _emitMetrics(event) {
        this.emit(Events.Page.Metrics, {
          title: event.title,
          metrics: this._buildMetricsObject(event.metrics)
        });
      }
      _buildMetricsObject(metrics) {
        const result = {};
        for (const metric of metrics || []) {
          if (supportedMetrics.has(metric.name))
            result[metric.name] = metric.value;
        }
        return result;
      }
      _handleException(exceptionDetails) {
        const message = helper.getExceptionMessage(exceptionDetails);
        const err = new Error(message);
        err.stack = "";
        this.emit(Events.Page.PageError, err);
      }
      async _onConsoleAPI(event) {
        if (event.executionContextId === 0) {
          return;
        }
        const context = this._frameManager.executionContextById(event.executionContextId);
        const values = event.args.map((arg) => createJSHandle(context, arg));
        this._addConsoleMessage(event.type, values, event.stackTrace);
      }
      async _onBindingCalled(event) {
        const { name, seq, args } = JSON.parse(event.payload);
        let expression = null;
        try {
          const result = await this._pageBindings.get(name)(...args);
          expression = helper.evaluationString(deliverResult, name, seq, result);
        } catch (error) {
          if (error instanceof Error)
            expression = helper.evaluationString(deliverError, name, seq, error.message, error.stack);
          else
            expression = helper.evaluationString(deliverErrorValue, name, seq, error);
        }
        this._client.send("Runtime.evaluate", { expression, contextId: event.executionContextId }).catch(debugError);
        function deliverResult(name2, seq2, result) {
          window[name2]["callbacks"].get(seq2).resolve(result);
          window[name2]["callbacks"].delete(seq2);
        }
        function deliverError(name2, seq2, message, stack) {
          const error = new Error(message);
          error.stack = stack;
          window[name2]["callbacks"].get(seq2).reject(error);
          window[name2]["callbacks"].delete(seq2);
        }
        function deliverErrorValue(name2, seq2, value) {
          window[name2]["callbacks"].get(seq2).reject(value);
          window[name2]["callbacks"].delete(seq2);
        }
      }
      _addConsoleMessage(type, args, stackTrace) {
        if (!this.listenerCount(Events.Page.Console)) {
          args.forEach((arg) => arg.dispose());
          return;
        }
        const textTokens = [];
        for (const arg of args) {
          const remoteObject = arg._remoteObject;
          if (remoteObject.objectId)
            textTokens.push(arg.toString());
          else
            textTokens.push(helper.valueFromRemoteObject(remoteObject));
        }
        const location = stackTrace && stackTrace.callFrames.length ? {
          url: stackTrace.callFrames[0].url,
          lineNumber: stackTrace.callFrames[0].lineNumber,
          columnNumber: stackTrace.callFrames[0].columnNumber
        } : {};
        const message = new ConsoleMessage(type, textTokens.join(" "), args, location);
        this.emit(Events.Page.Console, message);
      }
      _onDialog(event) {
        let dialogType = null;
        if (event.type === "alert")
          dialogType = Dialog.Type.Alert;
        else if (event.type === "confirm")
          dialogType = Dialog.Type.Confirm;
        else if (event.type === "prompt")
          dialogType = Dialog.Type.Prompt;
        else if (event.type === "beforeunload")
          dialogType = Dialog.Type.BeforeUnload;
        assert(dialogType, "Unknown javascript dialog type: " + event.type);
        const dialog = new Dialog(this._client, dialogType, event.message, event.defaultPrompt);
        this.emit(Events.Page.Dialog, dialog);
      }
      url() {
        return this.mainFrame().url();
      }
      async content() {
        return await this._frameManager.mainFrame().content();
      }
      async setContent(html, options) {
        await this._frameManager.mainFrame().setContent(html, options);
      }
      async goto(url, options) {
        return await this._frameManager.mainFrame().goto(url, options);
      }
      async reload(options) {
        const [response] = await Promise.all([
          this.waitForNavigation(options),
          this._client.send("Page.reload")
        ]);
        return response;
      }
      async waitForNavigation(options = {}) {
        return await this._frameManager.mainFrame().waitForNavigation(options);
      }
      async waitForRequest(urlOrPredicate, options = {}) {
        const {
          timeout = this._timeoutSettings.timeout()
        } = options;
        return helper.waitForEvent(this._frameManager.networkManager(), Events.NetworkManager.Request, (request) => {
          if (helper.isString(urlOrPredicate))
            return urlOrPredicate === request.url();
          if (typeof urlOrPredicate === "function")
            return !!urlOrPredicate(request);
          return false;
        }, timeout);
      }
      async waitForResponse(urlOrPredicate, options = {}) {
        const {
          timeout = this._timeoutSettings.timeout()
        } = options;
        return helper.waitForEvent(this._frameManager.networkManager(), Events.NetworkManager.Response, (response) => {
          if (helper.isString(urlOrPredicate))
            return urlOrPredicate === response.url();
          if (typeof urlOrPredicate === "function")
            return !!urlOrPredicate(response);
          return false;
        }, timeout);
      }
      async goBack(options) {
        return this._go(-1, options);
      }
      async goForward(options) {
        return this._go(1, options);
      }
      async _go(delta, options) {
        const history = await this._client.send("Page.getNavigationHistory");
        const entry = history.entries[history.currentIndex + delta];
        if (!entry)
          return null;
        const [response] = await Promise.all([
          this.waitForNavigation(options),
          this._client.send("Page.navigateToHistoryEntry", { entryId: entry.id })
        ]);
        return response;
      }
      async bringToFront() {
        await this._client.send("Page.bringToFront");
      }
      async emulate(options) {
        await Promise.all([
          this.setViewport(options.viewport),
          this.setUserAgent(options.userAgent)
        ]);
      }
      async setJavaScriptEnabled(enabled) {
        if (this._javascriptEnabled === enabled)
          return;
        this._javascriptEnabled = enabled;
        await this._client.send("Emulation.setScriptExecutionDisabled", { value: !enabled });
      }
      async setBypassCSP(enabled) {
        await this._client.send("Page.setBypassCSP", { enabled });
      }
      async emulateMedia(mediaType) {
        assert(mediaType === "screen" || mediaType === "print" || mediaType === null, "Unsupported media type: " + mediaType);
        await this._client.send("Emulation.setEmulatedMedia", { media: mediaType || "" });
      }
      async setViewport(viewport) {
        const needsReload = await this._emulationManager.emulateViewport(viewport);
        this._viewport = viewport;
        if (needsReload)
          await this.reload();
      }
      viewport() {
        return this._viewport;
      }
      async evaluate(pageFunction, ...args) {
        return this._frameManager.mainFrame().evaluate(pageFunction, ...args);
      }
      async evaluateOnNewDocument(pageFunction, ...args) {
        const source = helper.evaluationString(pageFunction, ...args);
        await this._client.send("Page.addScriptToEvaluateOnNewDocument", { source });
      }
      async setCacheEnabled(enabled = true) {
        await this._frameManager.networkManager().setCacheEnabled(enabled);
      }
      async screenshot(options = {}) {
        let screenshotType = null;
        if (options.type) {
          assert(options.type === "png" || options.type === "jpeg", "Unknown options.type value: " + options.type);
          screenshotType = options.type;
        } else if (options.path) {
          const mimeType = mime.getType(options.path);
          if (mimeType === "image/png")
            screenshotType = "png";
          else if (mimeType === "image/jpeg")
            screenshotType = "jpeg";
          assert(screenshotType, "Unsupported screenshot mime type: " + mimeType);
        }
        if (!screenshotType)
          screenshotType = "png";
        if (options.quality) {
          assert(screenshotType === "jpeg", "options.quality is unsupported for the " + screenshotType + " screenshots");
          assert(typeof options.quality === "number", "Expected options.quality to be a number but found " + typeof options.quality);
          assert(Number.isInteger(options.quality), "Expected options.quality to be an integer");
          assert(options.quality >= 0 && options.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options.quality);
        }
        assert(!options.clip || !options.fullPage, "options.clip and options.fullPage are exclusive");
        if (options.clip) {
          assert(typeof options.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options.clip.x);
          assert(typeof options.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options.clip.y);
          assert(typeof options.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options.clip.width);
          assert(typeof options.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options.clip.height);
          assert(options.clip.width !== 0, "Expected options.clip.width not to be 0.");
          assert(options.clip.height !== 0, "Expected options.clip.width not to be 0.");
        }
        return this._screenshotTaskQueue.postTask(this._screenshotTask.bind(this, screenshotType, options));
      }
      async _screenshotTask(format, options) {
        await this._client.send("Target.activateTarget", { targetId: this._target._targetId });
        let clip = options.clip ? processClip(options.clip) : void 0;
        if (options.fullPage) {
          const metrics = await this._client.send("Page.getLayoutMetrics");
          const width = Math.ceil(metrics.contentSize.width);
          const height = Math.ceil(metrics.contentSize.height);
          clip = { x: 0, y: 0, width, height, scale: 1 };
          const {
            isMobile = false,
            deviceScaleFactor = 1,
            isLandscape = false
          } = this._viewport || {};
          const screenOrientation = isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
          await this._client.send("Emulation.setDeviceMetricsOverride", { mobile: isMobile, width, height, deviceScaleFactor, screenOrientation });
        }
        const shouldSetDefaultBackground = options.omitBackground && format === "png";
        if (shouldSetDefaultBackground)
          await this._client.send("Emulation.setDefaultBackgroundColorOverride", { color: { r: 0, g: 0, b: 0, a: 0 } });
        const result = await this._client.send("Page.captureScreenshot", { format, quality: options.quality, clip });
        if (shouldSetDefaultBackground)
          await this._client.send("Emulation.setDefaultBackgroundColorOverride");
        if (options.fullPage && this._viewport)
          await this.setViewport(this._viewport);
        const buffer = options.encoding === "base64" ? result.data : Buffer.from(result.data, "base64");
        if (options.path)
          await writeFileAsync(options.path, buffer);
        return buffer;
        function processClip(clip2) {
          const x = Math.round(clip2.x);
          const y = Math.round(clip2.y);
          const width = Math.round(clip2.width + clip2.x - x);
          const height = Math.round(clip2.height + clip2.y - y);
          return { x, y, width, height, scale: 1 };
        }
      }
      async pdf(options = {}) {
        const {
          scale = 1,
          displayHeaderFooter = false,
          headerTemplate = "",
          footerTemplate = "",
          printBackground = false,
          landscape = false,
          pageRanges = "",
          preferCSSPageSize = false,
          margin = {},
          path = null
        } = options;
        let paperWidth = 8.5;
        let paperHeight = 11;
        if (options.format) {
          const format = Page.PaperFormats[options.format.toLowerCase()];
          assert(format, "Unknown paper format: " + options.format);
          paperWidth = format.width;
          paperHeight = format.height;
        } else {
          paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
          paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
        }
        const marginTop = convertPrintParameterToInches(margin.top) || 0;
        const marginLeft = convertPrintParameterToInches(margin.left) || 0;
        const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
        const marginRight = convertPrintParameterToInches(margin.right) || 0;
        const result = await this._client.send("Page.printToPDF", {
          landscape,
          displayHeaderFooter,
          headerTemplate,
          footerTemplate,
          printBackground,
          scale,
          paperWidth,
          paperHeight,
          marginTop,
          marginBottom,
          marginLeft,
          marginRight,
          pageRanges,
          preferCSSPageSize
        });
        const buffer = Buffer.from(result.data, "base64");
        if (path !== null)
          await writeFileAsync(path, buffer);
        return buffer;
      }
      async title() {
        return this.mainFrame().title();
      }
      async close(options = { runBeforeUnload: void 0 }) {
        assert(!!this._client._connection, "Protocol error: Connection closed. Most likely the page has been closed.");
        const runBeforeUnload = !!options.runBeforeUnload;
        if (runBeforeUnload) {
          await this._client.send("Page.close");
        } else {
          await this._client._connection.send("Target.closeTarget", { targetId: this._target._targetId });
          await this._target._isClosedPromise;
        }
      }
      isClosed() {
        return this._closed;
      }
      get mouse() {
        return this._mouse;
      }
      click(selector, options = {}) {
        return this.mainFrame().click(selector, options);
      }
      focus(selector) {
        return this.mainFrame().focus(selector);
      }
      hover(selector) {
        return this.mainFrame().hover(selector);
      }
      select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
      }
      tap(selector) {
        return this.mainFrame().tap(selector);
      }
      type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
      }
      waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);
      }
      waitForSelector(selector, options = {}) {
        return this.mainFrame().waitForSelector(selector, options);
      }
      waitForXPath(xpath, options = {}) {
        return this.mainFrame().waitForXPath(xpath, options);
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
      }
    };
    var supportedMetrics = new Set([
      "Timestamp",
      "Documents",
      "Frames",
      "JSEventListeners",
      "Nodes",
      "LayoutCount",
      "RecalcStyleCount",
      "LayoutDuration",
      "RecalcStyleDuration",
      "ScriptDuration",
      "TaskDuration",
      "JSHeapUsedSize",
      "JSHeapTotalSize"
    ]);
    Page.PaperFormats = {
      letter: { width: 8.5, height: 11 },
      legal: { width: 8.5, height: 14 },
      tabloid: { width: 11, height: 17 },
      ledger: { width: 17, height: 11 },
      a0: { width: 33.1, height: 46.8 },
      a1: { width: 23.4, height: 33.1 },
      a2: { width: 16.5, height: 23.4 },
      a3: { width: 11.7, height: 16.5 },
      a4: { width: 8.27, height: 11.7 },
      a5: { width: 5.83, height: 8.27 },
      a6: { width: 4.13, height: 5.83 }
    };
    var unitToPixels = {
      "px": 1,
      "in": 96,
      "cm": 37.8,
      "mm": 3.78
    };
    function convertPrintParameterToInches(parameter) {
      if (typeof parameter === "undefined")
        return void 0;
      let pixels;
      if (helper.isNumber(parameter)) {
        pixels = parameter;
      } else if (helper.isString(parameter)) {
        const text = parameter;
        let unit = text.substring(text.length - 2).toLowerCase();
        let valueText = "";
        if (unitToPixels.hasOwnProperty(unit)) {
          valueText = text.substring(0, text.length - 2);
        } else {
          unit = "px";
          valueText = text;
        }
        const value = Number(valueText);
        assert(!isNaN(value), "Failed to parse parameter value: " + text);
        pixels = value * unitToPixels[unit];
      } else {
        throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
      }
      return pixels / 96;
    }
    var ConsoleMessage = class {
      constructor(type, text, args, location = {}) {
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location;
      }
      type() {
        return this._type;
      }
      text() {
        return this._text;
      }
      args() {
        return this._args;
      }
      location() {
        return this._location;
      }
    };
    module2.exports = { Page, ConsoleMessage };
  }
});

// node_modules/puppeteer/lib/Target.js
var require_Target = __commonJS({
  "node_modules/puppeteer/lib/Target.js"(exports, module2) {
    var { Events } = require_Events();
    var { Page } = require_Page();
    var { Worker } = require_Worker();
    var { Connection } = require_Connection();
    var Target = class {
      constructor(targetInfo, browserContext, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
        this._targetInfo = targetInfo;
        this._browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this._sessionFactory = sessionFactory;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        this._screenshotTaskQueue = screenshotTaskQueue;
        this._pagePromise = null;
        this._workerPromise = null;
        this._initializedPromise = new Promise((fulfill) => this._initializedCallback = fulfill).then(async (success) => {
          if (!success)
            return false;
          const opener = this.opener();
          if (!opener || !opener._pagePromise || this.type() !== "page")
            return true;
          const openerPage = await opener._pagePromise;
          if (!openerPage.listenerCount(Events.Page.Popup))
            return true;
          const popupPage = await this.page();
          openerPage.emit(Events.Page.Popup, popupPage);
          return true;
        });
        this._isClosedPromise = new Promise((fulfill) => this._closedCallback = fulfill);
        this._isInitialized = this._targetInfo.type !== "page" || this._targetInfo.url !== "";
        if (this._isInitialized)
          this._initializedCallback(true);
      }
      createCDPSession() {
        return this._sessionFactory();
      }
      async page() {
        if ((this._targetInfo.type === "page" || this._targetInfo.type === "background_page") && !this._pagePromise) {
          this._pagePromise = this._sessionFactory().then((client) => Page.create(client, this, this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue));
        }
        return this._pagePromise;
      }
      async worker() {
        if (this._targetInfo.type !== "service_worker" && this._targetInfo.type !== "shared_worker")
          return null;
        if (!this._workerPromise) {
          this._workerPromise = this._sessionFactory().then(async (client) => {
            const [targetAttached] = await Promise.all([
              new Promise((x) => client.once("Target.attachedToTarget", x)),
              client.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: false, flatten: true })
            ]);
            const session = Connection.fromSession(client).session(targetAttached.sessionId);
            return new Worker(session, this._targetInfo.url, () => {
            }, () => {
            });
          });
        }
        return this._workerPromise;
      }
      url() {
        return this._targetInfo.url;
      }
      type() {
        const type = this._targetInfo.type;
        if (type === "page" || type === "background_page" || type === "service_worker" || type === "shared_worker" || type === "browser")
          return type;
        return "other";
      }
      browser() {
        return this._browserContext.browser();
      }
      browserContext() {
        return this._browserContext;
      }
      opener() {
        const { openerId } = this._targetInfo;
        if (!openerId)
          return null;
        return this.browser()._targets.get(openerId);
      }
      _targetInfoChanged(targetInfo) {
        this._targetInfo = targetInfo;
        if (!this._isInitialized && (this._targetInfo.type !== "page" || this._targetInfo.url !== "")) {
          this._isInitialized = true;
          this._initializedCallback(true);
          return;
        }
      }
    };
    module2.exports = { Target };
  }
});

// node_modules/puppeteer/lib/TaskQueue.js
var require_TaskQueue = __commonJS({
  "node_modules/puppeteer/lib/TaskQueue.js"(exports, module2) {
    var TaskQueue = class {
      constructor() {
        this._chain = Promise.resolve();
      }
      postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => {
        });
        return result;
      }
    };
    module2.exports = { TaskQueue };
  }
});

// node_modules/puppeteer/lib/Browser.js
var require_Browser = __commonJS({
  "node_modules/puppeteer/lib/Browser.js"(exports, module2) {
    var { helper, assert } = require_helper();
    var { Target } = require_Target();
    var EventEmitter = require("events");
    var { TaskQueue } = require_TaskQueue();
    var { Events } = require_Events();
    var Browser = class extends EventEmitter {
      static async create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback) {
        const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback);
        await connection.send("Target.setDiscoverTargets", { discover: true });
        return browser;
      }
      constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback) {
        super();
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        this._process = process2;
        this._screenshotTaskQueue = new TaskQueue();
        this._connection = connection;
        this._closeCallback = closeCallback || new Function();
        this._defaultContext = new BrowserContext(this._connection, this, null);
        this._contexts = new Map();
        for (const contextId of contextIds)
          this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));
        this._targets = new Map();
        this._connection.on(Events.Connection.Disconnected, () => this.emit(Events.Browser.Disconnected));
        this._connection.on("Target.targetCreated", this._targetCreated.bind(this));
        this._connection.on("Target.targetDestroyed", this._targetDestroyed.bind(this));
        this._connection.on("Target.targetInfoChanged", this._targetInfoChanged.bind(this));
      }
      process() {
        return this._process;
      }
      async createIncognitoBrowserContext() {
        const { browserContextId } = await this._connection.send("Target.createBrowserContext");
        const context = new BrowserContext(this._connection, this, browserContextId);
        this._contexts.set(browserContextId, context);
        return context;
      }
      browserContexts() {
        return [this._defaultContext, ...Array.from(this._contexts.values())];
      }
      defaultBrowserContext() {
        return this._defaultContext;
      }
      async _disposeContext(contextId) {
        await this._connection.send("Target.disposeBrowserContext", { browserContextId: contextId || void 0 });
        this._contexts.delete(contextId);
      }
      async _targetCreated(event) {
        const targetInfo = event.targetInfo;
        const { browserContextId } = targetInfo;
        const context = browserContextId && this._contexts.has(browserContextId) ? this._contexts.get(browserContextId) : this._defaultContext;
        const target = new Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue);
        assert(!this._targets.has(event.targetInfo.targetId), "Target should not exist before targetCreated");
        this._targets.set(event.targetInfo.targetId, target);
        if (await target._initializedPromise) {
          this.emit(Events.Browser.TargetCreated, target);
          context.emit(Events.BrowserContext.TargetCreated, target);
        }
      }
      async _targetDestroyed(event) {
        const target = this._targets.get(event.targetId);
        target._initializedCallback(false);
        this._targets.delete(event.targetId);
        target._closedCallback();
        if (await target._initializedPromise) {
          this.emit(Events.Browser.TargetDestroyed, target);
          target.browserContext().emit(Events.BrowserContext.TargetDestroyed, target);
        }
      }
      _targetInfoChanged(event) {
        const target = this._targets.get(event.targetInfo.targetId);
        assert(target, "target should exist before targetInfoChanged");
        const previousURL = target.url();
        const wasInitialized = target._isInitialized;
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
          this.emit(Events.Browser.TargetChanged, target);
          target.browserContext().emit(Events.BrowserContext.TargetChanged, target);
        }
      }
      wsEndpoint() {
        return this._connection.url();
      }
      async newPage() {
        return this._defaultContext.newPage();
      }
      async _createPageInContext(contextId) {
        const { targetId } = await this._connection.send("Target.createTarget", { url: "about:blank", browserContextId: contextId || void 0 });
        const target = await this._targets.get(targetId);
        assert(await target._initializedPromise, "Failed to create target for page");
        const page = await target.page();
        return page;
      }
      targets() {
        return Array.from(this._targets.values()).filter((target) => target._isInitialized);
      }
      target() {
        return this.targets().find((target) => target.type() === "browser");
      }
      async waitForTarget(predicate, options = {}) {
        const {
          timeout = 3e4
        } = options;
        const existingTarget = this.targets().find(predicate);
        if (existingTarget)
          return existingTarget;
        let resolve;
        const targetPromise = new Promise((x) => resolve = x);
        this.on(Events.Browser.TargetCreated, check);
        this.on(Events.Browser.TargetChanged, check);
        try {
          if (!timeout)
            return await targetPromise;
          return await helper.waitWithTimeout(targetPromise, "target", timeout);
        } finally {
          this.removeListener(Events.Browser.TargetCreated, check);
          this.removeListener(Events.Browser.TargetChanged, check);
        }
        function check(target) {
          if (predicate(target))
            resolve(target);
        }
      }
      async pages() {
        const contextPages = await Promise.all(this.browserContexts().map((context) => context.pages()));
        return contextPages.reduce((acc, x) => acc.concat(x), []);
      }
      async version() {
        const version = await this._getVersion();
        return version.product;
      }
      async userAgent() {
        const version = await this._getVersion();
        return version.userAgent;
      }
      async close() {
        await this._closeCallback.call(null);
        this.disconnect();
      }
      disconnect() {
        this._connection.dispose();
      }
      isConnected() {
        return !this._connection._closed;
      }
      _getVersion() {
        return this._connection.send("Browser.getVersion");
      }
    };
    var BrowserContext = class extends EventEmitter {
      constructor(connection, browser, contextId) {
        super();
        this._connection = connection;
        this._browser = browser;
        this._id = contextId;
      }
      targets() {
        return this._browser.targets().filter((target) => target.browserContext() === this);
      }
      waitForTarget(predicate, options) {
        return this._browser.waitForTarget((target) => target.browserContext() === this && predicate(target), options);
      }
      async pages() {
        const pages = await Promise.all(this.targets().filter((target) => target.type() === "page").map((target) => target.page()));
        return pages.filter((page) => !!page);
      }
      isIncognito() {
        return !!this._id;
      }
      async overridePermissions(origin, permissions) {
        const webPermissionToProtocol = new Map([
          ["geolocation", "geolocation"],
          ["midi", "midi"],
          ["notifications", "notifications"],
          ["push", "push"],
          ["camera", "videoCapture"],
          ["microphone", "audioCapture"],
          ["background-sync", "backgroundSync"],
          ["ambient-light-sensor", "sensors"],
          ["accelerometer", "sensors"],
          ["gyroscope", "sensors"],
          ["magnetometer", "sensors"],
          ["accessibility-events", "accessibilityEvents"],
          ["clipboard-read", "clipboardRead"],
          ["clipboard-write", "clipboardWrite"],
          ["payment-handler", "paymentHandler"],
          ["midi-sysex", "midiSysex"]
        ]);
        permissions = permissions.map((permission) => {
          const protocolPermission = webPermissionToProtocol.get(permission);
          if (!protocolPermission)
            throw new Error("Unknown permission: " + permission);
          return protocolPermission;
        });
        await this._connection.send("Browser.grantPermissions", { origin, browserContextId: this._id || void 0, permissions });
      }
      async clearPermissionOverrides() {
        await this._connection.send("Browser.resetPermissions", { browserContextId: this._id || void 0 });
      }
      newPage() {
        return this._browser._createPageInContext(this._id);
      }
      browser() {
        return this._browser;
      }
      async close() {
        assert(this._id, "Non-incognito profiles cannot be closed!");
        await this._browser._disposeContext(this._id);
      }
    };
    module2.exports = { Browser, BrowserContext };
  }
});

// node_modules/pend/index.js
var require_pend = __commonJS({
  "node_modules/pend/index.js"(exports, module2) {
    module2.exports = Pend;
    function Pend() {
      this.pending = 0;
      this.max = Infinity;
      this.listeners = [];
      this.waiting = [];
      this.error = null;
    }
    Pend.prototype.go = function(fn) {
      if (this.pending < this.max) {
        pendGo(this, fn);
      } else {
        this.waiting.push(fn);
      }
    };
    Pend.prototype.wait = function(cb) {
      if (this.pending === 0) {
        cb(this.error);
      } else {
        this.listeners.push(cb);
      }
    };
    Pend.prototype.hold = function() {
      return pendHold(this);
    };
    function pendHold(self2) {
      self2.pending += 1;
      var called = false;
      return onCb;
      function onCb(err) {
        if (called)
          throw new Error("callback called twice");
        called = true;
        self2.error = self2.error || err;
        self2.pending -= 1;
        if (self2.waiting.length > 0 && self2.pending < self2.max) {
          pendGo(self2, self2.waiting.shift());
        } else if (self2.pending === 0) {
          var listeners = self2.listeners;
          self2.listeners = [];
          listeners.forEach(cbListener);
        }
      }
      function cbListener(listener) {
        listener(self2.error);
      }
    }
    function pendGo(self2, fn) {
      fn(pendHold(self2));
    }
  }
});

// node_modules/fd-slicer/index.js
var require_fd_slicer = __commonJS({
  "node_modules/fd-slicer/index.js"(exports) {
    var fs = require("fs");
    var util = require("util");
    var stream = require("stream");
    var Readable = stream.Readable;
    var Writable = stream.Writable;
    var PassThrough = stream.PassThrough;
    var Pend = require_pend();
    var EventEmitter = require("events").EventEmitter;
    exports.createFromBuffer = createFromBuffer;
    exports.createFromFd = createFromFd;
    exports.BufferSlicer = BufferSlicer;
    exports.FdSlicer = FdSlicer;
    util.inherits(FdSlicer, EventEmitter);
    function FdSlicer(fd, options) {
      options = options || {};
      EventEmitter.call(this);
      this.fd = fd;
      this.pend = new Pend();
      this.pend.max = 1;
      this.refCount = 0;
      this.autoClose = !!options.autoClose;
    }
    FdSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.read(self2.fd, buffer, offset, length, position, function(err, bytesRead, buffer2) {
          cb();
          callback(err, bytesRead, buffer2);
        });
      });
    };
    FdSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      var self2 = this;
      self2.pend.go(function(cb) {
        fs.write(self2.fd, buffer, offset, length, position, function(err, written, buffer2) {
          cb();
          callback(err, written, buffer2);
        });
      });
    };
    FdSlicer.prototype.createReadStream = function(options) {
      return new ReadStream(this, options);
    };
    FdSlicer.prototype.createWriteStream = function(options) {
      return new WriteStream(this, options);
    };
    FdSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    FdSlicer.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      if (self2.autoClose) {
        fs.close(self2.fd, onCloseDone);
      }
      function onCloseDone(err) {
        if (err) {
          self2.emit("error", err);
        } else {
          self2.emit("close");
        }
      }
    };
    util.inherits(ReadStream, Readable);
    function ReadStream(context, options) {
      options = options || {};
      Readable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end;
      this.pos = this.start;
      this.destroyed = false;
    }
    ReadStream.prototype._read = function(n) {
      var self2 = this;
      if (self2.destroyed)
        return;
      var toRead = Math.min(self2._readableState.highWaterMark, n);
      if (self2.endOffset != null) {
        toRead = Math.min(toRead, self2.endOffset - self2.pos);
      }
      if (toRead <= 0) {
        self2.destroyed = true;
        self2.push(null);
        self2.context.unref();
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        var buffer = new Buffer(toRead);
        fs.read(self2.context.fd, buffer, 0, toRead, self2.pos, function(err, bytesRead) {
          if (err) {
            self2.destroy(err);
          } else if (bytesRead === 0) {
            self2.destroyed = true;
            self2.push(null);
            self2.context.unref();
          } else {
            self2.pos += bytesRead;
            self2.push(buffer.slice(0, bytesRead));
          }
          cb();
        });
      });
    };
    ReadStream.prototype.destroy = function(err) {
      if (this.destroyed)
        return;
      err = err || new Error("stream destroyed");
      this.destroyed = true;
      this.emit("error", err);
      this.context.unref();
    };
    util.inherits(WriteStream, Writable);
    function WriteStream(context, options) {
      options = options || {};
      Writable.call(this, options);
      this.context = context;
      this.context.ref();
      this.start = options.start || 0;
      this.endOffset = options.end == null ? Infinity : +options.end;
      this.bytesWritten = 0;
      this.pos = this.start;
      this.destroyed = false;
      this.on("finish", this.destroy.bind(this));
    }
    WriteStream.prototype._write = function(buffer, encoding, callback) {
      var self2 = this;
      if (self2.destroyed)
        return;
      if (self2.pos + buffer.length > self2.endOffset) {
        var err = new Error("maximum file length exceeded");
        err.code = "ETOOBIG";
        self2.destroy();
        callback(err);
        return;
      }
      self2.context.pend.go(function(cb) {
        if (self2.destroyed)
          return cb();
        fs.write(self2.context.fd, buffer, 0, buffer.length, self2.pos, function(err2, bytes) {
          if (err2) {
            self2.destroy();
            cb();
            callback(err2);
          } else {
            self2.bytesWritten += bytes;
            self2.pos += bytes;
            self2.emit("progress");
            cb();
            callback();
          }
        });
      });
    };
    WriteStream.prototype.destroy = function() {
      if (this.destroyed)
        return;
      this.destroyed = true;
      this.context.unref();
    };
    util.inherits(BufferSlicer, EventEmitter);
    function BufferSlicer(buffer, options) {
      EventEmitter.call(this);
      options = options || {};
      this.refCount = 0;
      this.buffer = buffer;
      this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;
    }
    BufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {
      var end = position + length;
      var delta = end - this.buffer.length;
      var written = delta > 0 ? delta : length;
      this.buffer.copy(buffer, offset, position, end);
      setImmediate(function() {
        callback(null, written);
      });
    };
    BufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {
      buffer.copy(this.buffer, position, offset, offset + length);
      setImmediate(function() {
        callback(null, length, buffer);
      });
    };
    BufferSlicer.prototype.createReadStream = function(options) {
      options = options || {};
      var readStream = new PassThrough(options);
      readStream.destroyed = false;
      readStream.start = options.start || 0;
      readStream.endOffset = options.end;
      readStream.pos = readStream.endOffset || this.buffer.length;
      var entireSlice = this.buffer.slice(readStream.start, readStream.pos);
      var offset = 0;
      while (true) {
        var nextOffset = offset + this.maxChunkSize;
        if (nextOffset >= entireSlice.length) {
          if (offset < entireSlice.length) {
            readStream.write(entireSlice.slice(offset, entireSlice.length));
          }
          break;
        }
        readStream.write(entireSlice.slice(offset, nextOffset));
        offset = nextOffset;
      }
      readStream.end();
      readStream.destroy = function() {
        readStream.destroyed = true;
      };
      return readStream;
    };
    BufferSlicer.prototype.createWriteStream = function(options) {
      var bufferSlicer = this;
      options = options || {};
      var writeStream = new Writable(options);
      writeStream.start = options.start || 0;
      writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;
      writeStream.bytesWritten = 0;
      writeStream.pos = writeStream.start;
      writeStream.destroyed = false;
      writeStream._write = function(buffer, encoding, callback) {
        if (writeStream.destroyed)
          return;
        var end = writeStream.pos + buffer.length;
        if (end > writeStream.endOffset) {
          var err = new Error("maximum file length exceeded");
          err.code = "ETOOBIG";
          writeStream.destroyed = true;
          callback(err);
          return;
        }
        buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);
        writeStream.bytesWritten += buffer.length;
        writeStream.pos = end;
        writeStream.emit("progress");
        callback();
      };
      writeStream.destroy = function() {
        writeStream.destroyed = true;
      };
      return writeStream;
    };
    BufferSlicer.prototype.ref = function() {
      this.refCount += 1;
    };
    BufferSlicer.prototype.unref = function() {
      this.refCount -= 1;
      if (this.refCount < 0) {
        throw new Error("invalid unref");
      }
    };
    function createFromBuffer(buffer, options) {
      return new BufferSlicer(buffer, options);
    }
    function createFromFd(fd, options) {
      return new FdSlicer(fd, options);
    }
  }
});

// node_modules/buffer-crc32/index.js
var require_buffer_crc32 = __commonJS({
  "node_modules/buffer-crc32/index.js"(exports, module2) {
    var Buffer2 = require("buffer").Buffer;
    var CRC_TABLE = [
      0,
      1996959894,
      3993919788,
      2567524794,
      124634137,
      1886057615,
      3915621685,
      2657392035,
      249268274,
      2044508324,
      3772115230,
      2547177864,
      162941995,
      2125561021,
      3887607047,
      2428444049,
      498536548,
      1789927666,
      4089016648,
      2227061214,
      450548861,
      1843258603,
      4107580753,
      2211677639,
      325883990,
      1684777152,
      4251122042,
      2321926636,
      335633487,
      1661365465,
      4195302755,
      2366115317,
      997073096,
      1281953886,
      3579855332,
      2724688242,
      1006888145,
      1258607687,
      3524101629,
      2768942443,
      901097722,
      1119000684,
      3686517206,
      2898065728,
      853044451,
      1172266101,
      3705015759,
      2882616665,
      651767980,
      1373503546,
      3369554304,
      3218104598,
      565507253,
      1454621731,
      3485111705,
      3099436303,
      671266974,
      1594198024,
      3322730930,
      2970347812,
      795835527,
      1483230225,
      3244367275,
      3060149565,
      1994146192,
      31158534,
      2563907772,
      4023717930,
      1907459465,
      112637215,
      2680153253,
      3904427059,
      2013776290,
      251722036,
      2517215374,
      3775830040,
      2137656763,
      141376813,
      2439277719,
      3865271297,
      1802195444,
      476864866,
      2238001368,
      4066508878,
      1812370925,
      453092731,
      2181625025,
      4111451223,
      1706088902,
      314042704,
      2344532202,
      4240017532,
      1658658271,
      366619977,
      2362670323,
      4224994405,
      1303535960,
      984961486,
      2747007092,
      3569037538,
      1256170817,
      1037604311,
      2765210733,
      3554079995,
      1131014506,
      879679996,
      2909243462,
      3663771856,
      1141124467,
      855842277,
      2852801631,
      3708648649,
      1342533948,
      654459306,
      3188396048,
      3373015174,
      1466479909,
      544179635,
      3110523913,
      3462522015,
      1591671054,
      702138776,
      2966460450,
      3352799412,
      1504918807,
      783551873,
      3082640443,
      3233442989,
      3988292384,
      2596254646,
      62317068,
      1957810842,
      3939845945,
      2647816111,
      81470997,
      1943803523,
      3814918930,
      2489596804,
      225274430,
      2053790376,
      3826175755,
      2466906013,
      167816743,
      2097651377,
      4027552580,
      2265490386,
      503444072,
      1762050814,
      4150417245,
      2154129355,
      426522225,
      1852507879,
      4275313526,
      2312317920,
      282753626,
      1742555852,
      4189708143,
      2394877945,
      397917763,
      1622183637,
      3604390888,
      2714866558,
      953729732,
      1340076626,
      3518719985,
      2797360999,
      1068828381,
      1219638859,
      3624741850,
      2936675148,
      906185462,
      1090812512,
      3747672003,
      2825379669,
      829329135,
      1181335161,
      3412177804,
      3160834842,
      628085408,
      1382605366,
      3423369109,
      3138078467,
      570562233,
      1426400815,
      3317316542,
      2998733608,
      733239954,
      1555261956,
      3268935591,
      3050360625,
      752459403,
      1541320221,
      2607071920,
      3965973030,
      1969922972,
      40735498,
      2617837225,
      3943577151,
      1913087877,
      83908371,
      2512341634,
      3803740692,
      2075208622,
      213261112,
      2463272603,
      3855990285,
      2094854071,
      198958881,
      2262029012,
      4057260610,
      1759359992,
      534414190,
      2176718541,
      4139329115,
      1873836001,
      414664567,
      2282248934,
      4279200368,
      1711684554,
      285281116,
      2405801727,
      4167216745,
      1634467795,
      376229701,
      2685067896,
      3608007406,
      1308918612,
      956543938,
      2808555105,
      3495958263,
      1231636301,
      1047427035,
      2932959818,
      3654703836,
      1088359270,
      936918e3,
      2847714899,
      3736837829,
      1202900863,
      817233897,
      3183342108,
      3401237130,
      1404277552,
      615818150,
      3134207493,
      3453421203,
      1423857449,
      601450431,
      3009837614,
      3294710456,
      1567103746,
      711928724,
      3020668471,
      3272380065,
      1510334235,
      755167117
    ];
    if (typeof Int32Array !== "undefined") {
      CRC_TABLE = new Int32Array(CRC_TABLE);
    }
    function ensureBuffer(input) {
      if (Buffer2.isBuffer(input)) {
        return input;
      }
      var hasNewBufferAPI = typeof Buffer2.alloc === "function" && typeof Buffer2.from === "function";
      if (typeof input === "number") {
        return hasNewBufferAPI ? Buffer2.alloc(input) : new Buffer2(input);
      } else if (typeof input === "string") {
        return hasNewBufferAPI ? Buffer2.from(input) : new Buffer2(input);
      } else {
        throw new Error("input must be buffer, number, or string, received " + typeof input);
      }
    }
    function bufferizeInt(num) {
      var tmp = ensureBuffer(4);
      tmp.writeInt32BE(num, 0);
      return tmp;
    }
    function _crc32(buf, previous) {
      buf = ensureBuffer(buf);
      if (Buffer2.isBuffer(previous)) {
        previous = previous.readUInt32BE(0);
      }
      var crc = ~~previous ^ -1;
      for (var n = 0; n < buf.length; n++) {
        crc = CRC_TABLE[(crc ^ buf[n]) & 255] ^ crc >>> 8;
      }
      return crc ^ -1;
    }
    function crc32() {
      return bufferizeInt(_crc32.apply(null, arguments));
    }
    crc32.signed = function() {
      return _crc32.apply(null, arguments);
    };
    crc32.unsigned = function() {
      return _crc32.apply(null, arguments) >>> 0;
    };
    module2.exports = crc32;
  }
});

// node_modules/yauzl/index.js
var require_yauzl = __commonJS({
  "node_modules/yauzl/index.js"(exports) {
    var fs = require("fs");
    var zlib = require("zlib");
    var fd_slicer = require_fd_slicer();
    var crc32 = require_buffer_crc32();
    var util = require("util");
    var EventEmitter = require("events").EventEmitter;
    var Transform = require("stream").Transform;
    var PassThrough = require("stream").PassThrough;
    var Writable = require("stream").Writable;
    exports.open = open;
    exports.fromFd = fromFd;
    exports.fromBuffer = fromBuffer;
    exports.fromRandomAccessReader = fromRandomAccessReader;
    exports.dosDateTimeToDate = dosDateTimeToDate;
    exports.validateFileName = validateFileName;
    exports.ZipFile = ZipFile;
    exports.Entry = Entry;
    exports.RandomAccessReader = RandomAccessReader;
    function open(path, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.open(path, "r", function(err, fd) {
        if (err)
          return callback(err);
        fromFd(fd, options, function(err2, zipfile) {
          if (err2)
            fs.close(fd, defaultCallback);
          callback(err2, zipfile);
        });
      });
    }
    function fromFd(fd, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      fs.fstat(fd, function(err, stats) {
        if (err)
          return callback(err);
        var reader = fd_slicer.createFromFd(fd, { autoClose: true });
        fromRandomAccessReader(reader, stats.size, options, callback);
      });
    }
    function fromBuffer(buffer, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      options.autoClose = false;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      var reader = fd_slicer.createFromBuffer(buffer, { maxChunkSize: 65536 });
      fromRandomAccessReader(reader, buffer.length, options, callback);
    }
    function fromRandomAccessReader(reader, totalSize, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = null;
      }
      if (options == null)
        options = {};
      if (options.autoClose == null)
        options.autoClose = true;
      if (options.lazyEntries == null)
        options.lazyEntries = false;
      if (options.decodeStrings == null)
        options.decodeStrings = true;
      var decodeStrings = !!options.decodeStrings;
      if (options.validateEntrySizes == null)
        options.validateEntrySizes = true;
      if (options.strictFileNames == null)
        options.strictFileNames = false;
      if (callback == null)
        callback = defaultCallback;
      if (typeof totalSize !== "number")
        throw new Error("expected totalSize parameter to be a number");
      if (totalSize > Number.MAX_SAFE_INTEGER) {
        throw new Error("zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.");
      }
      reader.ref();
      var eocdrWithoutCommentSize = 22;
      var maxCommentSize = 65535;
      var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);
      var buffer = newBuffer(bufferSize);
      var bufferReadStart = totalSize - buffer.length;
      readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {
        if (err)
          return callback(err);
        for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {
          if (buffer.readUInt32LE(i) !== 101010256)
            continue;
          var eocdrBuffer = buffer.slice(i);
          var diskNumber = eocdrBuffer.readUInt16LE(4);
          if (diskNumber !== 0) {
            return callback(new Error("multi-disk zip files are not supported: found disk number: " + diskNumber));
          }
          var entryCount = eocdrBuffer.readUInt16LE(10);
          var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);
          var commentLength = eocdrBuffer.readUInt16LE(20);
          var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;
          if (commentLength !== expectedCommentLength) {
            return callback(new Error("invalid comment length. expected: " + expectedCommentLength + ". found: " + commentLength));
          }
          var comment = decodeStrings ? decodeBuffer(eocdrBuffer, 22, eocdrBuffer.length, false) : eocdrBuffer.slice(22);
          if (!(entryCount === 65535 || centralDirectoryOffset === 4294967295)) {
            return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
          }
          var zip64EocdlBuffer = newBuffer(20);
          var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;
          readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err2) {
            if (err2)
              return callback(err2);
            if (zip64EocdlBuffer.readUInt32LE(0) !== 117853008) {
              return callback(new Error("invalid zip64 end of central directory locator signature"));
            }
            var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);
            var zip64EocdrBuffer = newBuffer(56);
            readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err3) {
              if (err3)
                return callback(err3);
              if (zip64EocdrBuffer.readUInt32LE(0) !== 101075792) {
                return callback(new Error("invalid zip64 end of central directory record signature"));
              }
              entryCount = readUInt64LE(zip64EocdrBuffer, 32);
              centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);
              return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries, decodeStrings, options.validateEntrySizes, options.strictFileNames));
            });
          });
          return;
        }
        callback(new Error("end of central directory record signature not found"));
      });
    }
    util.inherits(ZipFile, EventEmitter);
    function ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries, decodeStrings, validateEntrySizes, strictFileNames) {
      var self2 = this;
      EventEmitter.call(self2);
      self2.reader = reader;
      self2.reader.on("error", function(err) {
        emitError(self2, err);
      });
      self2.reader.once("close", function() {
        self2.emit("close");
      });
      self2.readEntryCursor = centralDirectoryOffset;
      self2.fileSize = fileSize;
      self2.entryCount = entryCount;
      self2.comment = comment;
      self2.entriesRead = 0;
      self2.autoClose = !!autoClose;
      self2.lazyEntries = !!lazyEntries;
      self2.decodeStrings = !!decodeStrings;
      self2.validateEntrySizes = !!validateEntrySizes;
      self2.strictFileNames = !!strictFileNames;
      self2.isOpen = true;
      self2.emittedError = false;
      if (!self2.lazyEntries)
        self2._readEntry();
    }
    ZipFile.prototype.close = function() {
      if (!this.isOpen)
        return;
      this.isOpen = false;
      this.reader.unref();
    };
    function emitErrorAndAutoClose(self2, err) {
      if (self2.autoClose)
        self2.close();
      emitError(self2, err);
    }
    function emitError(self2, err) {
      if (self2.emittedError)
        return;
      self2.emittedError = true;
      self2.emit("error", err);
    }
    ZipFile.prototype.readEntry = function() {
      if (!this.lazyEntries)
        throw new Error("readEntry() called without lazyEntries:true");
      this._readEntry();
    };
    ZipFile.prototype._readEntry = function() {
      var self2 = this;
      if (self2.entryCount === self2.entriesRead) {
        setImmediate(function() {
          if (self2.autoClose)
            self2.close();
          if (self2.emittedError)
            return;
          self2.emit("end");
        });
        return;
      }
      if (self2.emittedError)
        return;
      var buffer = newBuffer(46);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err) {
        if (err)
          return emitErrorAndAutoClose(self2, err);
        if (self2.emittedError)
          return;
        var entry = new Entry();
        var signature = buffer.readUInt32LE(0);
        if (signature !== 33639248)
          return emitErrorAndAutoClose(self2, new Error("invalid central directory file header signature: 0x" + signature.toString(16)));
        entry.versionMadeBy = buffer.readUInt16LE(4);
        entry.versionNeededToExtract = buffer.readUInt16LE(6);
        entry.generalPurposeBitFlag = buffer.readUInt16LE(8);
        entry.compressionMethod = buffer.readUInt16LE(10);
        entry.lastModFileTime = buffer.readUInt16LE(12);
        entry.lastModFileDate = buffer.readUInt16LE(14);
        entry.crc32 = buffer.readUInt32LE(16);
        entry.compressedSize = buffer.readUInt32LE(20);
        entry.uncompressedSize = buffer.readUInt32LE(24);
        entry.fileNameLength = buffer.readUInt16LE(28);
        entry.extraFieldLength = buffer.readUInt16LE(30);
        entry.fileCommentLength = buffer.readUInt16LE(32);
        entry.internalFileAttributes = buffer.readUInt16LE(36);
        entry.externalFileAttributes = buffer.readUInt32LE(38);
        entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);
        if (entry.generalPurposeBitFlag & 64)
          return emitErrorAndAutoClose(self2, new Error("strong encryption is not supported"));
        self2.readEntryCursor += 46;
        buffer = newBuffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);
        readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, self2.readEntryCursor, function(err2) {
          if (err2)
            return emitErrorAndAutoClose(self2, err2);
          if (self2.emittedError)
            return;
          var isUtf8 = (entry.generalPurposeBitFlag & 2048) !== 0;
          entry.fileName = self2.decodeStrings ? decodeBuffer(buffer, 0, entry.fileNameLength, isUtf8) : buffer.slice(0, entry.fileNameLength);
          var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;
          var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);
          entry.extraFields = [];
          var i = 0;
          while (i < extraFieldBuffer.length - 3) {
            var headerId = extraFieldBuffer.readUInt16LE(i + 0);
            var dataSize = extraFieldBuffer.readUInt16LE(i + 2);
            var dataStart = i + 4;
            var dataEnd = dataStart + dataSize;
            if (dataEnd > extraFieldBuffer.length)
              return emitErrorAndAutoClose(self2, new Error("extra field length exceeds extra field buffer size"));
            var dataBuffer = newBuffer(dataSize);
            extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);
            entry.extraFields.push({
              id: headerId,
              data: dataBuffer
            });
            i = dataEnd;
          }
          entry.fileComment = self2.decodeStrings ? decodeBuffer(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8) : buffer.slice(fileCommentStart, fileCommentStart + entry.fileCommentLength);
          entry.comment = entry.fileComment;
          self2.readEntryCursor += buffer.length;
          self2.entriesRead += 1;
          if (entry.uncompressedSize === 4294967295 || entry.compressedSize === 4294967295 || entry.relativeOffsetOfLocalHeader === 4294967295) {
            var zip64EiefBuffer = null;
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 1) {
                zip64EiefBuffer = extraField.data;
                break;
              }
            }
            if (zip64EiefBuffer == null) {
              return emitErrorAndAutoClose(self2, new Error("expected zip64 extended information extra field"));
            }
            var index = 0;
            if (entry.uncompressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include uncompressed size"));
              }
              entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.compressedSize === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include compressed size"));
              }
              entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
            if (entry.relativeOffsetOfLocalHeader === 4294967295) {
              if (index + 8 > zip64EiefBuffer.length) {
                return emitErrorAndAutoClose(self2, new Error("zip64 extended information extra field does not include relative header offset"));
              }
              entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);
              index += 8;
            }
          }
          if (self2.decodeStrings) {
            for (var i = 0; i < entry.extraFields.length; i++) {
              var extraField = entry.extraFields[i];
              if (extraField.id === 28789) {
                if (extraField.data.length < 6) {
                  continue;
                }
                if (extraField.data.readUInt8(0) !== 1) {
                  continue;
                }
                var oldNameCrc32 = extraField.data.readUInt32LE(1);
                if (crc32.unsigned(buffer.slice(0, entry.fileNameLength)) !== oldNameCrc32) {
                  continue;
                }
                entry.fileName = decodeBuffer(extraField.data, 5, extraField.data.length, true);
                break;
              }
            }
          }
          if (self2.validateEntrySizes && entry.compressionMethod === 0) {
            var expectedCompressedSize = entry.uncompressedSize;
            if (entry.isEncrypted()) {
              expectedCompressedSize += 12;
            }
            if (entry.compressedSize !== expectedCompressedSize) {
              var msg = "compressed/uncompressed size mismatch for stored file: " + entry.compressedSize + " != " + entry.uncompressedSize;
              return emitErrorAndAutoClose(self2, new Error(msg));
            }
          }
          if (self2.decodeStrings) {
            if (!self2.strictFileNames) {
              entry.fileName = entry.fileName.replace(/\\/g, "/");
            }
            var errorMessage = validateFileName(entry.fileName, self2.validateFileNameOptions);
            if (errorMessage != null)
              return emitErrorAndAutoClose(self2, new Error(errorMessage));
          }
          self2.emit("entry", entry);
          if (!self2.lazyEntries)
            self2._readEntry();
        });
      });
    };
    ZipFile.prototype.openReadStream = function(entry, options, callback) {
      var self2 = this;
      var relativeStart = 0;
      var relativeEnd = entry.compressedSize;
      if (callback == null) {
        callback = options;
        options = {};
      } else {
        if (options.decrypt != null) {
          if (!entry.isEncrypted()) {
            throw new Error("options.decrypt can only be specified for encrypted entries");
          }
          if (options.decrypt !== false)
            throw new Error("invalid options.decrypt value: " + options.decrypt);
          if (entry.isCompressed()) {
            if (options.decompress !== false)
              throw new Error("entry is encrypted and compressed, and options.decompress !== false");
          }
        }
        if (options.decompress != null) {
          if (!entry.isCompressed()) {
            throw new Error("options.decompress can only be specified for compressed entries");
          }
          if (!(options.decompress === false || options.decompress === true)) {
            throw new Error("invalid options.decompress value: " + options.decompress);
          }
        }
        if (options.start != null || options.end != null) {
          if (entry.isCompressed() && options.decompress !== false) {
            throw new Error("start/end range not allowed for compressed entry without options.decompress === false");
          }
          if (entry.isEncrypted() && options.decrypt !== false) {
            throw new Error("start/end range not allowed for encrypted entry without options.decrypt === false");
          }
        }
        if (options.start != null) {
          relativeStart = options.start;
          if (relativeStart < 0)
            throw new Error("options.start < 0");
          if (relativeStart > entry.compressedSize)
            throw new Error("options.start > entry.compressedSize");
        }
        if (options.end != null) {
          relativeEnd = options.end;
          if (relativeEnd < 0)
            throw new Error("options.end < 0");
          if (relativeEnd > entry.compressedSize)
            throw new Error("options.end > entry.compressedSize");
          if (relativeEnd < relativeStart)
            throw new Error("options.end < options.start");
        }
      }
      if (!self2.isOpen)
        return callback(new Error("closed"));
      if (entry.isEncrypted()) {
        if (options.decrypt !== false)
          return callback(new Error("entry is encrypted, and options.decrypt !== false"));
      }
      self2.reader.ref();
      var buffer = newBuffer(30);
      readAndAssertNoEof(self2.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {
        try {
          if (err)
            return callback(err);
          var signature = buffer.readUInt32LE(0);
          if (signature !== 67324752) {
            return callback(new Error("invalid local file header signature: 0x" + signature.toString(16)));
          }
          var fileNameLength = buffer.readUInt16LE(26);
          var extraFieldLength = buffer.readUInt16LE(28);
          var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;
          var decompress;
          if (entry.compressionMethod === 0) {
            decompress = false;
          } else if (entry.compressionMethod === 8) {
            decompress = options.decompress != null ? options.decompress : true;
          } else {
            return callback(new Error("unsupported compression method: " + entry.compressionMethod));
          }
          var fileDataStart = localFileHeaderEnd;
          var fileDataEnd = fileDataStart + entry.compressedSize;
          if (entry.compressedSize !== 0) {
            if (fileDataEnd > self2.fileSize) {
              return callback(new Error("file data overflows file bounds: " + fileDataStart + " + " + entry.compressedSize + " > " + self2.fileSize));
            }
          }
          var readStream = self2.reader.createReadStream({
            start: fileDataStart + relativeStart,
            end: fileDataStart + relativeEnd
          });
          var endpointStream = readStream;
          if (decompress) {
            var destroyed = false;
            var inflateFilter = zlib.createInflateRaw();
            readStream.on("error", function(err2) {
              setImmediate(function() {
                if (!destroyed)
                  inflateFilter.emit("error", err2);
              });
            });
            readStream.pipe(inflateFilter);
            if (self2.validateEntrySizes) {
              endpointStream = new AssertByteCountStream(entry.uncompressedSize);
              inflateFilter.on("error", function(err2) {
                setImmediate(function() {
                  if (!destroyed)
                    endpointStream.emit("error", err2);
                });
              });
              inflateFilter.pipe(endpointStream);
            } else {
              endpointStream = inflateFilter;
            }
            endpointStream.destroy = function() {
              destroyed = true;
              if (inflateFilter !== endpointStream)
                inflateFilter.unpipe(endpointStream);
              readStream.unpipe(inflateFilter);
              readStream.destroy();
            };
          }
          callback(null, endpointStream);
        } finally {
          self2.reader.unref();
        }
      });
    };
    function Entry() {
    }
    Entry.prototype.getLastModDate = function() {
      return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);
    };
    Entry.prototype.isEncrypted = function() {
      return (this.generalPurposeBitFlag & 1) !== 0;
    };
    Entry.prototype.isCompressed = function() {
      return this.compressionMethod === 8;
    };
    function dosDateTimeToDate(date, time) {
      var day = date & 31;
      var month = (date >> 5 & 15) - 1;
      var year = (date >> 9 & 127) + 1980;
      var millisecond = 0;
      var second = (time & 31) * 2;
      var minute = time >> 5 & 63;
      var hour = time >> 11 & 31;
      return new Date(year, month, day, hour, minute, second, millisecond);
    }
    function validateFileName(fileName) {
      if (fileName.indexOf("\\") !== -1) {
        return "invalid characters in fileName: " + fileName;
      }
      if (/^[a-zA-Z]:/.test(fileName) || /^\//.test(fileName)) {
        return "absolute path: " + fileName;
      }
      if (fileName.split("/").indexOf("..") !== -1) {
        return "invalid relative path: " + fileName;
      }
      return null;
    }
    function readAndAssertNoEof(reader, buffer, offset, length, position, callback) {
      if (length === 0) {
        return setImmediate(function() {
          callback(null, newBuffer(0));
        });
      }
      reader.read(buffer, offset, length, position, function(err, bytesRead) {
        if (err)
          return callback(err);
        if (bytesRead < length) {
          return callback(new Error("unexpected EOF"));
        }
        callback();
      });
    }
    util.inherits(AssertByteCountStream, Transform);
    function AssertByteCountStream(byteCount) {
      Transform.call(this);
      this.actualByteCount = 0;
      this.expectedByteCount = byteCount;
    }
    AssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {
      this.actualByteCount += chunk.length;
      if (this.actualByteCount > this.expectedByteCount) {
        var msg = "too many bytes in the stream. expected " + this.expectedByteCount + ". got at least " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb(null, chunk);
    };
    AssertByteCountStream.prototype._flush = function(cb) {
      if (this.actualByteCount < this.expectedByteCount) {
        var msg = "not enough bytes in the stream. expected " + this.expectedByteCount + ". got only " + this.actualByteCount;
        return cb(new Error(msg));
      }
      cb();
    };
    util.inherits(RandomAccessReader, EventEmitter);
    function RandomAccessReader() {
      EventEmitter.call(this);
      this.refCount = 0;
    }
    RandomAccessReader.prototype.ref = function() {
      this.refCount += 1;
    };
    RandomAccessReader.prototype.unref = function() {
      var self2 = this;
      self2.refCount -= 1;
      if (self2.refCount > 0)
        return;
      if (self2.refCount < 0)
        throw new Error("invalid unref");
      self2.close(onCloseDone);
      function onCloseDone(err) {
        if (err)
          return self2.emit("error", err);
        self2.emit("close");
      }
    };
    RandomAccessReader.prototype.createReadStream = function(options) {
      var start = options.start;
      var end = options.end;
      if (start === end) {
        var emptyStream = new PassThrough();
        setImmediate(function() {
          emptyStream.end();
        });
        return emptyStream;
      }
      var stream = this._readStreamForRange(start, end);
      var destroyed = false;
      var refUnrefFilter = new RefUnrefFilter(this);
      stream.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            refUnrefFilter.emit("error", err);
        });
      });
      refUnrefFilter.destroy = function() {
        stream.unpipe(refUnrefFilter);
        refUnrefFilter.unref();
        stream.destroy();
      };
      var byteCounter = new AssertByteCountStream(end - start);
      refUnrefFilter.on("error", function(err) {
        setImmediate(function() {
          if (!destroyed)
            byteCounter.emit("error", err);
        });
      });
      byteCounter.destroy = function() {
        destroyed = true;
        refUnrefFilter.unpipe(byteCounter);
        refUnrefFilter.destroy();
      };
      return stream.pipe(refUnrefFilter).pipe(byteCounter);
    };
    RandomAccessReader.prototype._readStreamForRange = function(start, end) {
      throw new Error("not implemented");
    };
    RandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {
      var readStream = this.createReadStream({ start: position, end: position + length });
      var writeStream = new Writable();
      var written = 0;
      writeStream._write = function(chunk, encoding, cb) {
        chunk.copy(buffer, offset + written, 0, chunk.length);
        written += chunk.length;
        cb();
      };
      writeStream.on("finish", callback);
      readStream.on("error", function(error) {
        callback(error);
      });
      readStream.pipe(writeStream);
    };
    RandomAccessReader.prototype.close = function(callback) {
      setImmediate(callback);
    };
    util.inherits(RefUnrefFilter, PassThrough);
    function RefUnrefFilter(context) {
      PassThrough.call(this);
      this.context = context;
      this.context.ref();
      this.unreffedYet = false;
    }
    RefUnrefFilter.prototype._flush = function(cb) {
      this.unref();
      cb();
    };
    RefUnrefFilter.prototype.unref = function(cb) {
      if (this.unreffedYet)
        return;
      this.unreffedYet = true;
      this.context.unref();
    };
    var cp437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0\xA0";
    function decodeBuffer(buffer, start, end, isUtf8) {
      if (isUtf8) {
        return buffer.toString("utf8", start, end);
      } else {
        var result = "";
        for (var i = start; i < end; i++) {
          result += cp437[buffer[i]];
        }
        return result;
      }
    }
    function readUInt64LE(buffer, offset) {
      var lower32 = buffer.readUInt32LE(offset);
      var upper32 = buffer.readUInt32LE(offset + 4);
      return upper32 * 4294967296 + lower32;
    }
    var newBuffer;
    if (typeof Buffer.allocUnsafe === "function") {
      newBuffer = function(len) {
        return Buffer.allocUnsafe(len);
      };
    } else {
      newBuffer = function(len) {
        return new Buffer(len);
      };
    }
    function defaultCallback(err) {
      if (err)
        throw err;
    }
  }
});

// node_modules/mkdirp/index.js
var require_mkdirp = __commonJS({
  "node_modules/mkdirp/index.js"(exports, module2) {
    var path = require("path");
    var fs = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      var cb = f || function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            if (path.dirname(p) === p)
              return cb(er);
            mkdirP(path.dirname(p), opts, function(er2, made2) {
              if (er2)
                cb(er2, made2);
              else
                mkdirP(p, opts, cb, made2);
            });
            break;
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory())
                cb(er, made);
              else
                cb(null, made);
            });
            break;
        }
      });
    }
    mkdirP.sync = function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = { mode: opts };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777;
      }
      if (!made)
        made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory())
              throw err0;
            break;
        }
      }
      return made;
    };
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports, module2) {
    var toString = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports, module2) {
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function")
        throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        if (this.length === 1)
          return this.head.data;
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
          pna.nextTick(emitErrorNT, this, err);
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          pna.nextTick(emitErrorNT, _this, err2);
          if (_this._writableState) {
            _this._writableState.errorEmitted = true;
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node2 = __commonJS({
  "node_modules/util-deprecate/node.js"(exports, module2) {
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node2()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending && !state.finished)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      if (state.corkedRequestsFree) {
        state.corkedRequestsFree.next = corkReq;
      } else {
        state.corkedRequestsFree = corkReq;
      }
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require("string_decoder/").StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require("string_decoder/").StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (ret === false && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", src._readableState.awaitDrain);
            src._readableState.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, unpipeInfo);
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports = module2.exports = Stream.Readable;
      exports.Readable = Stream.Readable;
      exports.Writable = Stream.Writable;
      exports.Duplex = Stream.Duplex;
      exports.Transform = Stream.Transform;
      exports.PassThrough = Stream.PassThrough;
      exports.Stream = Stream;
    } else {
      exports = module2.exports = require_stream_readable();
      exports.Stream = Stream || exports;
      exports.Readable = exports;
      exports.Writable = require_stream_writable();
      exports.Duplex = require_stream_duplex();
      exports.Transform = require_stream_transform();
      exports.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/buffer-from/index.js
var require_buffer_from = __commonJS({
  "node_modules/buffer-from/index.js"(exports, module2) {
    var toString = Object.prototype.toString;
    var isModern = typeof Buffer.alloc === "function" && typeof Buffer.allocUnsafe === "function" && typeof Buffer.from === "function";
    function isArrayBuffer(input) {
      return toString.call(input).slice(8, -1) === "ArrayBuffer";
    }
    function fromArrayBuffer(obj, byteOffset, length) {
      byteOffset >>>= 0;
      var maxLength = obj.byteLength - byteOffset;
      if (maxLength < 0) {
        throw new RangeError("'offset' is out of bounds");
      }
      if (length === void 0) {
        length = maxLength;
      } else {
        length >>>= 0;
        if (length > maxLength) {
          throw new RangeError("'length' is out of bounds");
        }
      }
      return isModern ? Buffer.from(obj.slice(byteOffset, byteOffset + length)) : new Buffer(new Uint8Array(obj.slice(byteOffset, byteOffset + length)));
    }
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer.isEncoding(encoding)) {
        throw new TypeError('"encoding" must be a valid string encoding');
      }
      return isModern ? Buffer.from(string, encoding) : new Buffer(string, encoding);
    }
    function bufferFrom(value, encodingOrOffset, length) {
      if (typeof value === "number") {
        throw new TypeError('"value" argument must not be a number');
      }
      if (isArrayBuffer(value)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      return isModern ? Buffer.from(value) : new Buffer(value);
    }
    module2.exports = bufferFrom;
  }
});

// node_modules/typedarray/index.js
var require_typedarray = __commonJS({
  "node_modules/typedarray/index.js"(exports) {
    var undefined2 = void 0;
    var MAX_ARRAY_LENGTH = 1e5;
    var ECMAScript = function() {
      var opts = Object.prototype.toString, ophop = Object.prototype.hasOwnProperty;
      return {
        Class: function(v) {
          return opts.call(v).replace(/^\[object *|\]$/g, "");
        },
        HasProperty: function(o, p) {
          return p in o;
        },
        HasOwnProperty: function(o, p) {
          return ophop.call(o, p);
        },
        IsCallable: function(o) {
          return typeof o === "function";
        },
        ToInt32: function(v) {
          return v >> 0;
        },
        ToUint32: function(v) {
          return v >>> 0;
        }
      };
    }();
    var LN2 = Math.LN2;
    var abs = Math.abs;
    var floor = Math.floor;
    var log = Math.log;
    var min = Math.min;
    var pow = Math.pow;
    var round = Math.round;
    function configureProperties(obj) {
      if (getOwnPropNames && defineProp) {
        var props = getOwnPropNames(obj), i;
        for (i = 0; i < props.length; i += 1) {
          defineProp(obj, props[i], {
            value: obj[props[i]],
            writable: false,
            enumerable: false,
            configurable: false
          });
        }
      }
    }
    var defineProp;
    if (Object.defineProperty && function() {
      try {
        Object.defineProperty({}, "x", {});
        return true;
      } catch (e) {
        return false;
      }
    }()) {
      defineProp = Object.defineProperty;
    } else {
      defineProp = function(o, p, desc) {
        if (!o === Object(o))
          throw new TypeError("Object.defineProperty called on non-object");
        if (ECMAScript.HasProperty(desc, "get") && Object.prototype.__defineGetter__) {
          Object.prototype.__defineGetter__.call(o, p, desc.get);
        }
        if (ECMAScript.HasProperty(desc, "set") && Object.prototype.__defineSetter__) {
          Object.prototype.__defineSetter__.call(o, p, desc.set);
        }
        if (ECMAScript.HasProperty(desc, "value")) {
          o[p] = desc.value;
        }
        return o;
      };
    }
    var getOwnPropNames = Object.getOwnPropertyNames || function(o) {
      if (o !== Object(o))
        throw new TypeError("Object.getOwnPropertyNames called on non-object");
      var props = [], p;
      for (p in o) {
        if (ECMAScript.HasOwnProperty(o, p)) {
          props.push(p);
        }
      }
      return props;
    };
    function makeArrayAccessors(obj) {
      if (!defineProp) {
        return;
      }
      if (obj.length > MAX_ARRAY_LENGTH)
        throw new RangeError("Array too large for polyfill");
      function makeArrayAccessor(index) {
        defineProp(obj, index, {
          "get": function() {
            return obj._getter(index);
          },
          "set": function(v) {
            obj._setter(index, v);
          },
          enumerable: true,
          configurable: false
        });
      }
      var i;
      for (i = 0; i < obj.length; i += 1) {
        makeArrayAccessor(i);
      }
    }
    function as_signed(value, bits) {
      var s = 32 - bits;
      return value << s >> s;
    }
    function as_unsigned(value, bits) {
      var s = 32 - bits;
      return value << s >>> s;
    }
    function packI8(n) {
      return [n & 255];
    }
    function unpackI8(bytes) {
      return as_signed(bytes[0], 8);
    }
    function packU8(n) {
      return [n & 255];
    }
    function unpackU8(bytes) {
      return as_unsigned(bytes[0], 8);
    }
    function packU8Clamped(n) {
      n = round(Number(n));
      return [n < 0 ? 0 : n > 255 ? 255 : n & 255];
    }
    function packI16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackI16(bytes) {
      return as_signed(bytes[0] << 8 | bytes[1], 16);
    }
    function packU16(n) {
      return [n >> 8 & 255, n & 255];
    }
    function unpackU16(bytes) {
      return as_unsigned(bytes[0] << 8 | bytes[1], 16);
    }
    function packI32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackI32(bytes) {
      return as_signed(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packU32(n) {
      return [n >> 24 & 255, n >> 16 & 255, n >> 8 & 255, n & 255];
    }
    function unpackU32(bytes) {
      return as_unsigned(bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], 32);
    }
    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << ebits - 1) - 1, s, e, f, ln, i, bits, str, bytes;
      function roundToEven(n) {
        var w = floor(n), f2 = n - w;
        if (f2 < 0.5)
          return w;
        if (f2 > 0.5)
          return w + 1;
        return w % 2 ? w + 1 : w;
      }
      if (v !== v) {
        e = (1 << ebits) - 1;
        f = pow(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = v < 0 ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = 1 / v === -Infinity ? 1 : 0;
      } else {
        s = v < 0;
        v = abs(v);
        if (v >= pow(2, 1 - bias)) {
          e = min(floor(log(v) / LN2), 1023);
          f = roundToEven(v / pow(2, e) * pow(2, fbits));
          if (f / pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            e = e + bias;
            f = f - pow(2, fbits);
          }
        } else {
          e = 0;
          f = roundToEven(v / pow(2, 1 - bias - fbits));
        }
      }
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join("");
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.substring(0, 8), 2));
        str = str.substring(8);
      }
      return bytes;
    }
    function unpackIEEE754(bytes, ebits, fbits) {
      var bits = [], i, j, b, str, bias, s, e, f;
      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join("");
      bias = (1 << ebits - 1) - 1;
      s = parseInt(str.substring(0, 1), 2) ? -1 : 1;
      e = parseInt(str.substring(1, 1 + ebits), 2);
      f = parseInt(str.substring(1 + ebits), 2);
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        return s * pow(2, e - bias) * (1 + f / pow(2, fbits));
      } else if (f !== 0) {
        return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }
    function unpackF64(b) {
      return unpackIEEE754(b, 11, 52);
    }
    function packF64(v) {
      return packIEEE754(v, 11, 52);
    }
    function unpackF32(b) {
      return unpackIEEE754(b, 8, 23);
    }
    function packF32(v) {
      return packIEEE754(v, 8, 23);
    }
    (function() {
      var ArrayBuffer2 = function ArrayBuffer3(length) {
        length = ECMAScript.ToInt32(length);
        if (length < 0)
          throw new RangeError("ArrayBuffer size is not a small enough positive integer");
        this.byteLength = length;
        this._bytes = [];
        this._bytes.length = length;
        var i;
        for (i = 0; i < this.byteLength; i += 1) {
          this._bytes[i] = 0;
        }
        configureProperties(this);
      };
      exports.ArrayBuffer = exports.ArrayBuffer || ArrayBuffer2;
      var ArrayBufferView = function ArrayBufferView2() {
      };
      function makeConstructor(bytesPerElement, pack, unpack) {
        var ctor;
        ctor = function(buffer, byteOffset, length) {
          var array, sequence, i, s;
          if (!arguments.length || typeof arguments[0] === "number") {
            this.length = ECMAScript.ToInt32(arguments[0]);
            if (length < 0)
              throw new RangeError("ArrayBufferView size is not a small enough positive integer");
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
          } else if (typeof arguments[0] === "object" && arguments[0].constructor === ctor) {
            array = arguments[0];
            this.length = array.length;
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              this._setter(i, array._getter(i));
            }
          } else if (typeof arguments[0] === "object" && !(arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            sequence = arguments[0];
            this.length = ECMAScript.ToUint32(sequence.length);
            this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            this.buffer = new ArrayBuffer2(this.byteLength);
            this.byteOffset = 0;
            for (i = 0; i < this.length; i += 1) {
              s = sequence[i];
              this._setter(i, Number(s));
            }
          } else if (typeof arguments[0] === "object" && (arguments[0] instanceof ArrayBuffer2 || ECMAScript.Class(arguments[0]) === "ArrayBuffer")) {
            this.buffer = buffer;
            this.byteOffset = ECMAScript.ToUint32(byteOffset);
            if (this.byteOffset > this.buffer.byteLength) {
              throw new RangeError("byteOffset out of range");
            }
            if (this.byteOffset % this.BYTES_PER_ELEMENT) {
              throw new RangeError("ArrayBuffer length minus the byteOffset is not a multiple of the element size.");
            }
            if (arguments.length < 3) {
              this.byteLength = this.buffer.byteLength - this.byteOffset;
              if (this.byteLength % this.BYTES_PER_ELEMENT) {
                throw new RangeError("length of buffer minus byteOffset not a multiple of the element size");
              }
              this.length = this.byteLength / this.BYTES_PER_ELEMENT;
            } else {
              this.length = ECMAScript.ToUint32(length);
              this.byteLength = this.length * this.BYTES_PER_ELEMENT;
            }
            if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
              throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
          this.constructor = ctor;
          configureProperties(this);
          makeArrayAccessors(this);
        };
        ctor.prototype = new ArrayBufferView();
        ctor.prototype.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._pack = pack;
        ctor.prototype._unpack = unpack;
        ctor.BYTES_PER_ELEMENT = bytesPerElement;
        ctor.prototype._getter = function(index) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = [], i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            bytes.push(this.buffer._bytes[o]);
          }
          return this._unpack(bytes);
        };
        ctor.prototype.get = ctor.prototype._getter;
        ctor.prototype._setter = function(index, value) {
          if (arguments.length < 2)
            throw new SyntaxError("Not enough arguments");
          index = ECMAScript.ToUint32(index);
          if (index >= this.length) {
            return undefined2;
          }
          var bytes = this._pack(value), i, o;
          for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT; i < this.BYTES_PER_ELEMENT; i += 1, o += 1) {
            this.buffer._bytes[o] = bytes[i];
          }
        };
        ctor.prototype.set = function(index, value) {
          if (arguments.length < 1)
            throw new SyntaxError("Not enough arguments");
          var array, sequence, offset, len, i, s, d, byteOffset, byteLength, tmp;
          if (typeof arguments[0] === "object" && arguments[0].constructor === this.constructor) {
            array = arguments[0];
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + array.length > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;
            byteLength = array.length * this.BYTES_PER_ELEMENT;
            if (array.buffer === this.buffer) {
              tmp = [];
              for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {
                tmp[i] = array.buffer._bytes[s];
              }
              for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {
                this.buffer._bytes[d] = tmp[i];
              }
            } else {
              for (i = 0, s = array.byteOffset, d = byteOffset; i < byteLength; i += 1, s += 1, d += 1) {
                this.buffer._bytes[d] = array.buffer._bytes[s];
              }
            }
          } else if (typeof arguments[0] === "object" && typeof arguments[0].length !== "undefined") {
            sequence = arguments[0];
            len = ECMAScript.ToUint32(sequence.length);
            offset = ECMAScript.ToUint32(arguments[1]);
            if (offset + len > this.length) {
              throw new RangeError("Offset plus length of array is out of range");
            }
            for (i = 0; i < len; i += 1) {
              s = sequence[i];
              this._setter(offset + i, Number(s));
            }
          } else {
            throw new TypeError("Unexpected argument type(s)");
          }
        };
        ctor.prototype.subarray = function(start, end) {
          function clamp(v, min2, max) {
            return v < min2 ? min2 : v > max ? max : v;
          }
          start = ECMAScript.ToInt32(start);
          end = ECMAScript.ToInt32(end);
          if (arguments.length < 1) {
            start = 0;
          }
          if (arguments.length < 2) {
            end = this.length;
          }
          if (start < 0) {
            start = this.length + start;
          }
          if (end < 0) {
            end = this.length + end;
          }
          start = clamp(start, 0, this.length);
          end = clamp(end, 0, this.length);
          var len = end - start;
          if (len < 0) {
            len = 0;
          }
          return new this.constructor(this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);
        };
        return ctor;
      }
      var Int8Array = makeConstructor(1, packI8, unpackI8);
      var Uint8Array2 = makeConstructor(1, packU8, unpackU8);
      var Uint8ClampedArray2 = makeConstructor(1, packU8Clamped, unpackU8);
      var Int16Array = makeConstructor(2, packI16, unpackI16);
      var Uint16Array = makeConstructor(2, packU16, unpackU16);
      var Int32Array2 = makeConstructor(4, packI32, unpackI32);
      var Uint32Array = makeConstructor(4, packU32, unpackU32);
      var Float32Array = makeConstructor(4, packF32, unpackF32);
      var Float64Array = makeConstructor(8, packF64, unpackF64);
      exports.Int8Array = exports.Int8Array || Int8Array;
      exports.Uint8Array = exports.Uint8Array || Uint8Array2;
      exports.Uint8ClampedArray = exports.Uint8ClampedArray || Uint8ClampedArray2;
      exports.Int16Array = exports.Int16Array || Int16Array;
      exports.Uint16Array = exports.Uint16Array || Uint16Array;
      exports.Int32Array = exports.Int32Array || Int32Array2;
      exports.Uint32Array = exports.Uint32Array || Uint32Array;
      exports.Float32Array = exports.Float32Array || Float32Array;
      exports.Float64Array = exports.Float64Array || Float64Array;
    })();
    (function() {
      function r(array, index) {
        return ECMAScript.IsCallable(array.get) ? array.get(index) : array[index];
      }
      var IS_BIG_ENDIAN = function() {
        var u16array = new exports.Uint16Array([4660]), u8array = new exports.Uint8Array(u16array.buffer);
        return r(u8array, 0) === 18;
      }();
      var DataView = function DataView2(buffer, byteOffset, byteLength) {
        if (arguments.length === 0) {
          buffer = new exports.ArrayBuffer(0);
        } else if (!(buffer instanceof exports.ArrayBuffer || ECMAScript.Class(buffer) === "ArrayBuffer")) {
          throw new TypeError("TypeError");
        }
        this.buffer = buffer || new exports.ArrayBuffer(0);
        this.byteOffset = ECMAScript.ToUint32(byteOffset);
        if (this.byteOffset > this.buffer.byteLength) {
          throw new RangeError("byteOffset out of range");
        }
        if (arguments.length < 3) {
          this.byteLength = this.buffer.byteLength - this.byteOffset;
        } else {
          this.byteLength = ECMAScript.ToUint32(byteLength);
        }
        if (this.byteOffset + this.byteLength > this.buffer.byteLength) {
          throw new RangeError("byteOffset and length reference an area beyond the end of the buffer");
        }
        configureProperties(this);
      };
      function makeGetter(arrayType) {
        return function(byteOffset, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          byteOffset += this.byteOffset;
          var uint8Array = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT), bytes = [], i;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(uint8Array, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          return r(new arrayType(new exports.Uint8Array(bytes).buffer), 0);
        };
      }
      DataView.prototype.getUint8 = makeGetter(exports.Uint8Array);
      DataView.prototype.getInt8 = makeGetter(exports.Int8Array);
      DataView.prototype.getUint16 = makeGetter(exports.Uint16Array);
      DataView.prototype.getInt16 = makeGetter(exports.Int16Array);
      DataView.prototype.getUint32 = makeGetter(exports.Uint32Array);
      DataView.prototype.getInt32 = makeGetter(exports.Int32Array);
      DataView.prototype.getFloat32 = makeGetter(exports.Float32Array);
      DataView.prototype.getFloat64 = makeGetter(exports.Float64Array);
      function makeSetter(arrayType) {
        return function(byteOffset, value, littleEndian) {
          byteOffset = ECMAScript.ToUint32(byteOffset);
          if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength) {
            throw new RangeError("Array index out of range");
          }
          var typeArray = new arrayType([value]), byteArray = new exports.Uint8Array(typeArray.buffer), bytes = [], i, byteView;
          for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1) {
            bytes.push(r(byteArray, i));
          }
          if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN)) {
            bytes.reverse();
          }
          byteView = new exports.Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);
          byteView.set(bytes);
        };
      }
      DataView.prototype.setUint8 = makeSetter(exports.Uint8Array);
      DataView.prototype.setInt8 = makeSetter(exports.Int8Array);
      DataView.prototype.setUint16 = makeSetter(exports.Uint16Array);
      DataView.prototype.setInt16 = makeSetter(exports.Int16Array);
      DataView.prototype.setUint32 = makeSetter(exports.Uint32Array);
      DataView.prototype.setInt32 = makeSetter(exports.Int32Array);
      DataView.prototype.setFloat32 = makeSetter(exports.Float32Array);
      DataView.prototype.setFloat64 = makeSetter(exports.Float64Array);
      exports.DataView = exports.DataView || DataView;
    })();
  }
});

// node_modules/concat-stream/index.js
var require_concat_stream = __commonJS({
  "node_modules/concat-stream/index.js"(exports, module2) {
    var Writable = require_readable().Writable;
    var inherits = require_inherits();
    var bufferFrom = require_buffer_from();
    if (typeof Uint8Array === "undefined") {
      U8 = require_typedarray().Uint8Array;
    } else {
      U8 = Uint8Array;
    }
    var U8;
    function ConcatStream(opts, cb) {
      if (!(this instanceof ConcatStream))
        return new ConcatStream(opts, cb);
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      if (!opts)
        opts = {};
      var encoding = opts.encoding;
      var shouldInferEncoding = false;
      if (!encoding) {
        shouldInferEncoding = true;
      } else {
        encoding = String(encoding).toLowerCase();
        if (encoding === "u8" || encoding === "uint8") {
          encoding = "uint8array";
        }
      }
      Writable.call(this, { objectMode: true });
      this.encoding = encoding;
      this.shouldInferEncoding = shouldInferEncoding;
      if (cb)
        this.on("finish", function() {
          cb(this.getBody());
        });
      this.body = [];
    }
    module2.exports = ConcatStream;
    inherits(ConcatStream, Writable);
    ConcatStream.prototype._write = function(chunk, enc, next) {
      this.body.push(chunk);
      next();
    };
    ConcatStream.prototype.inferEncoding = function(buff) {
      var firstBuffer = buff === void 0 ? this.body[0] : buff;
      if (Buffer.isBuffer(firstBuffer))
        return "buffer";
      if (typeof Uint8Array !== "undefined" && firstBuffer instanceof Uint8Array)
        return "uint8array";
      if (Array.isArray(firstBuffer))
        return "array";
      if (typeof firstBuffer === "string")
        return "string";
      if (Object.prototype.toString.call(firstBuffer) === "[object Object]")
        return "object";
      return "buffer";
    };
    ConcatStream.prototype.getBody = function() {
      if (!this.encoding && this.body.length === 0)
        return [];
      if (this.shouldInferEncoding)
        this.encoding = this.inferEncoding();
      if (this.encoding === "array")
        return arrayConcat(this.body);
      if (this.encoding === "string")
        return stringConcat(this.body);
      if (this.encoding === "buffer")
        return bufferConcat(this.body);
      if (this.encoding === "uint8array")
        return u8Concat(this.body);
      return this.body;
    };
    var isArray = Array.isArray || function(arr) {
      return Object.prototype.toString.call(arr) == "[object Array]";
    };
    function isArrayish(arr) {
      return /Array\]$/.test(Object.prototype.toString.call(arr));
    }
    function isBufferish(p) {
      return typeof p === "string" || isArrayish(p) || p && typeof p.subarray === "function";
    }
    function stringConcat(parts) {
      var strings = [];
      var needsToString = false;
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (typeof p === "string") {
          strings.push(p);
        } else if (Buffer.isBuffer(p)) {
          strings.push(p);
        } else if (isBufferish(p)) {
          strings.push(bufferFrom(p));
        } else {
          strings.push(bufferFrom(String(p)));
        }
      }
      if (Buffer.isBuffer(parts[0])) {
        strings = Buffer.concat(strings);
        strings = strings.toString("utf8");
      } else {
        strings = strings.join("");
      }
      return strings;
    }
    function bufferConcat(parts) {
      var bufs = [];
      for (var i = 0; i < parts.length; i++) {
        var p = parts[i];
        if (Buffer.isBuffer(p)) {
          bufs.push(p);
        } else if (isBufferish(p)) {
          bufs.push(bufferFrom(p));
        } else {
          bufs.push(bufferFrom(String(p)));
        }
      }
      return Buffer.concat(bufs);
    }
    function arrayConcat(parts) {
      var res = [];
      for (var i = 0; i < parts.length; i++) {
        res.push.apply(res, parts[i]);
      }
      return res;
    }
    function u8Concat(parts) {
      var len = 0;
      for (var i = 0; i < parts.length; i++) {
        if (typeof parts[i] === "string") {
          parts[i] = bufferFrom(parts[i]);
        }
        len += parts[i].length;
      }
      var u8 = new U8(len);
      for (var i = 0, offset = 0; i < parts.length; i++) {
        var part = parts[i];
        for (var j = 0; j < part.length; j++) {
          u8[offset++] = part[j];
        }
      }
      return u8;
    }
  }
});

// node_modules/extract-zip/node_modules/ms/index.js
var require_ms2 = __commonJS({
  "node_modules/extract-zip/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/extract-zip/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/debug.js"(exports, module2) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms2();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if (typeof formatter === "function") {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      if (typeof exports.init === "function") {
        exports.init(debug);
      }
      return debug;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/extract-zip/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/browser.js"(exports, module2) {
    exports = module2.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = typeof chrome != "undefined" && typeof chrome.storage != "undefined" ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%")
          return;
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return typeof console === "object" && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces == null) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/extract-zip/node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/node.js"(exports, module2) {
    var tty = require("tty");
    var util = require("util");
    exports = module2.exports = require_debug();
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val))
        val = true;
      else if (/^(no|off|false|disabled)$/i.test(val))
        val = false;
      else if (val === "null")
        val = null;
      else
        val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (fd !== 1 && fd !== 2) {
      util.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream = fd === 1 ? process.stdout : fd === 2 ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  [3" + c + ";1m" + name + " [0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("[3" + c + "m+" + exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = new Date().toUTCString() + " " + name + " " + args[0];
      }
    }
    function log() {
      return stream.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces == null) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream2;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream2 = new tty.WriteStream(fd2);
          stream2._type = "tty";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        case "FILE":
          var fs = require("fs");
          stream2 = new fs.SyncWriteStream(fd2, { autoClose: false });
          stream2._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net = require("net");
          stream2 = new net.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream2.readable = false;
          stream2.read = null;
          stream2._type = "pipe";
          if (stream2._handle && stream2._handle.unref) {
            stream2._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream2.fd = fd2;
      stream2._isStdio = true;
      return stream2;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    exports.enable(load());
  }
});

// node_modules/extract-zip/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/extract-zip/node_modules/debug/src/index.js"(exports, module2) {
    if (typeof process !== "undefined" && process.type === "renderer") {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/extract-zip/index.js
var require_extract_zip = __commonJS({
  "node_modules/extract-zip/index.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var yauzl = require_yauzl();
    var mkdirp = require_mkdirp();
    var concat = require_concat_stream();
    var debug = require_src2()("extract-zip");
    module2.exports = function(zipPath, opts, cb) {
      debug("creating target directory", opts.dir);
      if (path.isAbsolute(opts.dir) === false) {
        return cb(new Error("Target directory is expected to be absolute"));
      }
      mkdirp(opts.dir, function(err) {
        if (err)
          return cb(err);
        fs.realpath(opts.dir, function(err2, canonicalDir) {
          if (err2)
            return cb(err2);
          opts.dir = canonicalDir;
          openZip(opts);
        });
      });
      function openZip() {
        debug("opening", zipPath, "with opts", opts);
        yauzl.open(zipPath, { lazyEntries: true }, function(err, zipfile) {
          if (err)
            return cb(err);
          var cancelled = false;
          zipfile.on("error", function(err2) {
            if (err2) {
              cancelled = true;
              return cb(err2);
            }
          });
          zipfile.readEntry();
          zipfile.on("close", function() {
            if (!cancelled) {
              debug("zip extraction complete");
              cb();
            }
          });
          zipfile.on("entry", function(entry) {
            if (cancelled) {
              debug("skipping entry", entry.fileName, { cancelled });
              return;
            }
            debug("zipfile entry", entry.fileName);
            if (/^__MACOSX\//.test(entry.fileName)) {
              zipfile.readEntry();
              return;
            }
            var destDir = path.dirname(path.join(opts.dir, entry.fileName));
            mkdirp(destDir, function(err2) {
              if (err2) {
                cancelled = true;
                zipfile.close();
                return cb(err2);
              }
              fs.realpath(destDir, function(err3, canonicalDestDir) {
                if (err3) {
                  cancelled = true;
                  zipfile.close();
                  return cb(err3);
                }
                var relativeDestDir = path.relative(opts.dir, canonicalDestDir);
                if (relativeDestDir.split(path.sep).indexOf("..") !== -1) {
                  cancelled = true;
                  zipfile.close();
                  return cb(new Error('Out of bound path "' + canonicalDestDir + '" found while processing file ' + entry.fileName));
                }
                extractEntry(entry, function(err4) {
                  if (err4) {
                    cancelled = true;
                    zipfile.close();
                    return cb(err4);
                  }
                  debug("finished processing", entry.fileName);
                  zipfile.readEntry();
                });
              });
            });
          });
          function extractEntry(entry, done) {
            if (cancelled) {
              debug("skipping entry extraction", entry.fileName, { cancelled });
              return setImmediate(done);
            }
            if (opts.onEntry) {
              opts.onEntry(entry, zipfile);
            }
            var dest = path.join(opts.dir, entry.fileName);
            var mode = entry.externalFileAttributes >> 16 & 65535;
            var IFMT = 61440;
            var IFDIR = 16384;
            var IFLNK = 40960;
            var symlink = (mode & IFMT) === IFLNK;
            var isDir = (mode & IFMT) === IFDIR;
            if (!isDir && entry.fileName.slice(-1) === "/") {
              isDir = true;
            }
            var madeBy = entry.versionMadeBy >> 8;
            if (!isDir)
              isDir = madeBy === 0 && entry.externalFileAttributes === 16;
            if (mode === 0) {
              if (isDir) {
                if (opts.defaultDirMode)
                  mode = parseInt(opts.defaultDirMode, 10);
                if (!mode)
                  mode = 493;
              } else {
                if (opts.defaultFileMode)
                  mode = parseInt(opts.defaultFileMode, 10);
                if (!mode)
                  mode = 420;
              }
            }
            debug("extracting entry", { filename: entry.fileName, isDir, isSymlink: symlink });
            var umask = ~process.umask();
            var procMode = mode & umask;
            var destDir = dest;
            if (!isDir)
              destDir = path.dirname(dest);
            debug("mkdirp", { dir: destDir });
            mkdirp(destDir, function(err2) {
              if (err2) {
                debug("mkdirp error", destDir, { error: err2 });
                cancelled = true;
                return done(err2);
              }
              if (isDir)
                return done();
              debug("opening read stream", dest);
              zipfile.openReadStream(entry, function(err3, readStream) {
                if (err3) {
                  debug("openReadStream error", err3);
                  cancelled = true;
                  return done(err3);
                }
                readStream.on("error", function(err4) {
                  console.log("read err", err4);
                });
                if (symlink)
                  writeSymlink();
                else
                  writeStream();
                function writeStream() {
                  var writeStream2 = fs.createWriteStream(dest, { mode: procMode });
                  readStream.pipe(writeStream2);
                  writeStream2.on("finish", function() {
                    done();
                  });
                  writeStream2.on("error", function(err4) {
                    debug("write error", { error: err4 });
                    cancelled = true;
                    return done(err4);
                  });
                }
                function writeSymlink() {
                  readStream.pipe(concat(function(data) {
                    var link = data.toString();
                    debug("creating symlink", link, dest);
                    fs.symlink(link, dest, function(err4) {
                      if (err4)
                        cancelled = true;
                      done(err4);
                    });
                  }));
                }
              });
            });
          }
        });
      }
    };
  }
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
  "node_modules/fs.realpath/old.js"(exports) {
    var pathModule = require("path");
    var isWindows = process.platform === "win32";
    var fs = require("fs");
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    var normalize = pathModule.normalize;
    if (isWindows) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    exports.realpathSync = function realpathSync(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs.statSync(base);
            linkTarget = fs.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    exports.realpath = function realpath(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows && !knownHard[base]) {
          fs.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs.readlink(base, function(err3, target) {
            if (!isWindows)
              seenLinks[id] = target;
            gotTarget(err3, target);
          });
        });
      }
      function gotTarget(err, target, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
  }
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
  "node_modules/fs.realpath/index.js"(exports, module2) {
    module2.exports = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs = require("fs");
    var origRealpath = fs.realpath;
    var origRealpathSync = fs.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = require_old();
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs.realpath = realpath;
      fs.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs.realpath = origRealpath;
      fs.realpathSync = origRealpathSync;
    }
  }
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS({
  "node_modules/concat-map/index.js"(exports, module2) {
    module2.exports = function(xs, fn) {
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x))
          res.push.apply(res, x);
        else
          res.push(x);
      }
      return res;
    };
    var isArray = Array.isArray || function(xs) {
      return Object.prototype.toString.call(xs) === "[object Array]";
    };
  }
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
  "node_modules/balanced-match/index.js"(exports, module2) {
    "use strict";
    module2.exports = balanced;
    function balanced(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg, str) {
      var m = str.match(reg);
      return m ? m[0] : null;
    }
    balanced.range = range;
    function range(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i = ai;
      if (ai >= 0 && bi > 0) {
        begs = [];
        left = str.length;
        while (i >= 0 && !result) {
          if (i == ai) {
            begs.push(i);
            ai = str.indexOf(a, i + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i + 1);
          }
          i = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
  "node_modules/brace-expansion/index.js"(exports, module2) {
    var concatMap = require_concat_map();
    var balanced = require_balanced_match();
    module2.exports = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre = m.pre;
      var body = m.body;
      var post = m.post;
      var p = pre.split(",");
      p[p.length - 1] += "{" + body + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el) {
      return /^-?0\d/.test(el);
    }
    function lte(i, y) {
      return i <= y;
    }
    function gte(i, y) {
      return i >= y;
    }
    function expand(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m || /\$$/.test(m.pre))
        return [str];
      var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
      var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
      var isSequence = isNumericSequence || isAlphaSequence;
      var isOptions = m.body.indexOf(",") >= 0;
      if (!isSequence && !isOptions) {
        if (m.post.match(/,.*\}/)) {
          str = m.pre + "{" + m.body + escClose + m.post;
          return expand(str);
        }
        return [str];
      }
      var n;
      if (isSequence) {
        n = m.body.split(/\.\./);
      } else {
        n = parseCommaParts(m.body);
        if (n.length === 1) {
          n = expand(n[0], false).map(embrace);
          if (n.length === 1) {
            var post = m.post.length ? expand(m.post, false) : [""];
            return post.map(function(p) {
              return m.pre + n[0] + p;
            });
          }
        }
      }
      var pre = m.pre;
      var post = m.post.length ? expand(m.post, false) : [""];
      var N;
      if (isSequence) {
        var x = numeric(n[0]);
        var y = numeric(n[1]);
        var width = Math.max(n[0].length, n[1].length);
        var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
        var test = lte;
        var reverse = y < x;
        if (reverse) {
          incr *= -1;
          test = gte;
        }
        var pad = n.some(isPadded);
        N = [];
        for (var i = x; test(i, y); i += incr) {
          var c;
          if (isAlphaSequence) {
            c = String.fromCharCode(i);
            if (c === "\\")
              c = "";
          } else {
            c = String(i);
            if (pad) {
              var need = width - c.length;
              if (need > 0) {
                var z = new Array(need + 1).join("0");
                if (i < 0)
                  c = "-" + z + c.slice(1);
                else
                  c = z + c;
              }
            }
          }
          N.push(c);
        }
      } else {
        N = concatMap(n, function(el) {
          return expand(el, false);
        });
      }
      for (var j = 0; j < N.length; j++) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre + N[j] + post[k];
          if (!isTop || isSequence || expansion)
            expansions.push(expansion);
        }
      }
      return expansions;
    }
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
  "node_modules/minimatch/minimatch.js"(exports, module2) {
    module2.exports = minimatch;
    minimatch.Minimatch = Minimatch;
    var path = { sep: "/" };
    try {
      path = require("path");
    } catch (er) {
    }
    var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
    var expand = require_brace_expansion();
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var reSpecials = charSet("().*{}+?[]^$\\!");
    function charSet(s) {
      return s.split("").reduce(function(set, c) {
        set[c] = true;
        return set;
      }, {});
    }
    var slashSplit = /\/+/;
    minimatch.filter = filter;
    function filter(pattern, options) {
      options = options || {};
      return function(p, i, list) {
        return minimatch(p, pattern, options);
      };
    }
    function ext(a, b) {
      a = a || {};
      b = b || {};
      var t = {};
      Object.keys(b).forEach(function(k) {
        t[k] = b[k];
      });
      Object.keys(a).forEach(function(k) {
        t[k] = a[k];
      });
      return t;
    }
    minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return minimatch;
      var orig = minimatch;
      var m = function minimatch2(p, pattern, options) {
        return orig.minimatch(p, pattern, ext(def, options));
      };
      m.Minimatch = function Minimatch2(pattern, options) {
        return new orig.Minimatch(pattern, ext(def, options));
      };
      return m;
    };
    Minimatch.defaults = function(def) {
      if (!def || !Object.keys(def).length)
        return Minimatch;
      return minimatch.defaults(def).Minimatch;
    };
    function minimatch(p, pattern, options) {
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      if (!options.nocomment && pattern.charAt(0) === "#") {
        return false;
      }
      if (pattern.trim() === "")
        return p === "";
      return new Minimatch(pattern, options).match(p);
    }
    function Minimatch(pattern, options) {
      if (!(this instanceof Minimatch)) {
        return new Minimatch(pattern, options);
      }
      if (typeof pattern !== "string") {
        throw new TypeError("glob pattern string required");
      }
      if (!options)
        options = {};
      pattern = pattern.trim();
      if (path.sep !== "/") {
        pattern = pattern.split(path.sep).join("/");
      }
      this.options = options;
      this.set = [];
      this.pattern = pattern;
      this.regexp = null;
      this.negate = false;
      this.comment = false;
      this.empty = false;
      this.make();
    }
    Minimatch.prototype.debug = function() {
    };
    Minimatch.prototype.make = make;
    function make() {
      if (this._made)
        return;
      var pattern = this.pattern;
      var options = this.options;
      if (!options.nocomment && pattern.charAt(0) === "#") {
        this.comment = true;
        return;
      }
      if (!pattern) {
        this.empty = true;
        return;
      }
      this.parseNegate();
      var set = this.globSet = this.braceExpand();
      if (options.debug)
        this.debug = console.error;
      this.debug(this.pattern, set);
      set = this.globParts = set.map(function(s) {
        return s.split(slashSplit);
      });
      this.debug(this.pattern, set);
      set = set.map(function(s, si, set2) {
        return s.map(this.parse, this);
      }, this);
      this.debug(this.pattern, set);
      set = set.filter(function(s) {
        return s.indexOf(false) === -1;
      });
      this.debug(this.pattern, set);
      this.set = set;
    }
    Minimatch.prototype.parseNegate = parseNegate;
    function parseNegate() {
      var pattern = this.pattern;
      var negate = false;
      var options = this.options;
      var negateOffset = 0;
      if (options.nonegate)
        return;
      for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
        negate = !negate;
        negateOffset++;
      }
      if (negateOffset)
        this.pattern = pattern.substr(negateOffset);
      this.negate = negate;
    }
    minimatch.braceExpand = function(pattern, options) {
      return braceExpand(pattern, options);
    };
    Minimatch.prototype.braceExpand = braceExpand;
    function braceExpand(pattern, options) {
      if (!options) {
        if (this instanceof Minimatch) {
          options = this.options;
        } else {
          options = {};
        }
      }
      pattern = typeof pattern === "undefined" ? this.pattern : pattern;
      if (typeof pattern === "undefined") {
        throw new TypeError("undefined pattern");
      }
      if (options.nobrace || !pattern.match(/\{.*\}/)) {
        return [pattern];
      }
      return expand(pattern);
    }
    Minimatch.prototype.parse = parse;
    var SUBPARSE = {};
    function parse(pattern, isSub) {
      if (pattern.length > 1024 * 64) {
        throw new TypeError("pattern is too long");
      }
      var options = this.options;
      if (!options.noglobstar && pattern === "**")
        return GLOBSTAR;
      if (pattern === "")
        return "";
      var re = "";
      var hasMagic = !!options.nocase;
      var escaping = false;
      var patternListStack = [];
      var negativeLists = [];
      var stateChar;
      var inClass = false;
      var reClassStart = -1;
      var classStart = -1;
      var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
      var self2 = this;
      function clearStateChar() {
        if (stateChar) {
          switch (stateChar) {
            case "*":
              re += star;
              hasMagic = true;
              break;
            case "?":
              re += qmark;
              hasMagic = true;
              break;
            default:
              re += "\\" + stateChar;
              break;
          }
          self2.debug("clearStateChar %j %j", stateChar, re);
          stateChar = false;
        }
      }
      for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
        this.debug("%s	%s %s %j", pattern, i, re, c);
        if (escaping && reSpecials[c]) {
          re += "\\" + c;
          escaping = false;
          continue;
        }
        switch (c) {
          case "/":
            return false;
          case "\\":
            clearStateChar();
            escaping = true;
            continue;
          case "?":
          case "*":
          case "+":
          case "@":
          case "!":
            this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
            if (inClass) {
              this.debug("  in class");
              if (c === "!" && i === classStart + 1)
                c = "^";
              re += c;
              continue;
            }
            self2.debug("call clearStateChar %j", stateChar);
            clearStateChar();
            stateChar = c;
            if (options.noext)
              clearStateChar();
            continue;
          case "(":
            if (inClass) {
              re += "(";
              continue;
            }
            if (!stateChar) {
              re += "\\(";
              continue;
            }
            patternListStack.push({
              type: stateChar,
              start: i - 1,
              reStart: re.length,
              open: plTypes[stateChar].open,
              close: plTypes[stateChar].close
            });
            re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
            this.debug("plType %j %j", stateChar, re);
            stateChar = false;
            continue;
          case ")":
            if (inClass || !patternListStack.length) {
              re += "\\)";
              continue;
            }
            clearStateChar();
            hasMagic = true;
            var pl = patternListStack.pop();
            re += pl.close;
            if (pl.type === "!") {
              negativeLists.push(pl);
            }
            pl.reEnd = re.length;
            continue;
          case "|":
            if (inClass || !patternListStack.length || escaping) {
              re += "\\|";
              escaping = false;
              continue;
            }
            clearStateChar();
            re += "|";
            continue;
          case "[":
            clearStateChar();
            if (inClass) {
              re += "\\" + c;
              continue;
            }
            inClass = true;
            classStart = i;
            reClassStart = re.length;
            re += c;
            continue;
          case "]":
            if (i === classStart + 1 || !inClass) {
              re += "\\" + c;
              escaping = false;
              continue;
            }
            if (inClass) {
              var cs = pattern.substring(classStart + 1, i);
              try {
                RegExp("[" + cs + "]");
              } catch (er) {
                var sp = this.parse(cs, SUBPARSE);
                re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
                hasMagic = hasMagic || sp[1];
                inClass = false;
                continue;
              }
            }
            hasMagic = true;
            inClass = false;
            re += c;
            continue;
          default:
            clearStateChar();
            if (escaping) {
              escaping = false;
            } else if (reSpecials[c] && !(c === "^" && inClass)) {
              re += "\\";
            }
            re += c;
        }
      }
      if (inClass) {
        cs = pattern.substr(classStart + 1);
        sp = this.parse(cs, SUBPARSE);
        re = re.substr(0, reClassStart) + "\\[" + sp[0];
        hasMagic = hasMagic || sp[1];
      }
      for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
        var tail = re.slice(pl.reStart + pl.open.length);
        this.debug("setting tail", re, pl);
        tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
          if (!$2) {
            $2 = "\\";
          }
          return $1 + $1 + $2 + "|";
        });
        this.debug("tail=%j\n   %s", tail, tail, pl, re);
        var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
        hasMagic = true;
        re = re.slice(0, pl.reStart) + t + "\\(" + tail;
      }
      clearStateChar();
      if (escaping) {
        re += "\\\\";
      }
      var addPatternStart = false;
      switch (re.charAt(0)) {
        case ".":
        case "[":
        case "(":
          addPatternStart = true;
      }
      for (var n = negativeLists.length - 1; n > -1; n--) {
        var nl = negativeLists[n];
        var nlBefore = re.slice(0, nl.reStart);
        var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
        var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
        var nlAfter = re.slice(nl.reEnd);
        nlLast += nlAfter;
        var openParensBefore = nlBefore.split("(").length - 1;
        var cleanAfter = nlAfter;
        for (i = 0; i < openParensBefore; i++) {
          cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
        }
        nlAfter = cleanAfter;
        var dollar = "";
        if (nlAfter === "" && isSub !== SUBPARSE) {
          dollar = "$";
        }
        var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
        re = newRe;
      }
      if (re !== "" && hasMagic) {
        re = "(?=.)" + re;
      }
      if (addPatternStart) {
        re = patternStart + re;
      }
      if (isSub === SUBPARSE) {
        return [re, hasMagic];
      }
      if (!hasMagic) {
        return globUnescape(pattern);
      }
      var flags = options.nocase ? "i" : "";
      try {
        var regExp = new RegExp("^" + re + "$", flags);
      } catch (er) {
        return new RegExp("$.");
      }
      regExp._glob = pattern;
      regExp._src = re;
      return regExp;
    }
    minimatch.makeRe = function(pattern, options) {
      return new Minimatch(pattern, options || {}).makeRe();
    };
    Minimatch.prototype.makeRe = makeRe;
    function makeRe() {
      if (this.regexp || this.regexp === false)
        return this.regexp;
      var set = this.set;
      if (!set.length) {
        this.regexp = false;
        return this.regexp;
      }
      var options = this.options;
      var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
      var flags = options.nocase ? "i" : "";
      var re = set.map(function(pattern) {
        return pattern.map(function(p) {
          return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
        }).join("\\/");
      }).join("|");
      re = "^(?:" + re + ")$";
      if (this.negate)
        re = "^(?!" + re + ").*$";
      try {
        this.regexp = new RegExp(re, flags);
      } catch (ex) {
        this.regexp = false;
      }
      return this.regexp;
    }
    minimatch.match = function(list, pattern, options) {
      options = options || {};
      var mm = new Minimatch(pattern, options);
      list = list.filter(function(f) {
        return mm.match(f);
      });
      if (mm.options.nonull && !list.length) {
        list.push(pattern);
      }
      return list;
    };
    Minimatch.prototype.match = match;
    function match(f, partial) {
      this.debug("match", f, this.pattern);
      if (this.comment)
        return false;
      if (this.empty)
        return f === "";
      if (f === "/" && partial)
        return true;
      var options = this.options;
      if (path.sep !== "/") {
        f = f.split(path.sep).join("/");
      }
      f = f.split(slashSplit);
      this.debug(this.pattern, "split", f);
      var set = this.set;
      this.debug(this.pattern, "set", set);
      var filename;
      var i;
      for (i = f.length - 1; i >= 0; i--) {
        filename = f[i];
        if (filename)
          break;
      }
      for (i = 0; i < set.length; i++) {
        var pattern = set[i];
        var file = f;
        if (options.matchBase && pattern.length === 1) {
          file = [filename];
        }
        var hit = this.matchOne(file, pattern, partial);
        if (hit) {
          if (options.flipNegate)
            return true;
          return !this.negate;
        }
      }
      if (options.flipNegate)
        return false;
      return this.negate;
    }
    Minimatch.prototype.matchOne = function(file, pattern, partial) {
      var options = this.options;
      this.debug("matchOne", { "this": this, file, pattern });
      this.debug("matchOne", file.length, pattern.length);
      for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
        this.debug("matchOne loop");
        var p = pattern[pi];
        var f = file[fi];
        this.debug(pattern, p, f);
        if (p === false)
          return false;
        if (p === GLOBSTAR) {
          this.debug("GLOBSTAR", [pattern, p, f]);
          var fr = fi;
          var pr = pi + 1;
          if (pr === pl) {
            this.debug("** at the end");
            for (; fi < fl; fi++) {
              if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
                return false;
            }
            return true;
          }
          while (fr < fl) {
            var swallowee = file[fr];
            this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
            if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
              this.debug("globstar found match!", fr, fl, swallowee);
              return true;
            } else {
              if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
                this.debug("dot detected!", file, fr, pattern, pr);
                break;
              }
              this.debug("globstar swallow a segment, and continue");
              fr++;
            }
          }
          if (partial) {
            this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
            if (fr === fl)
              return true;
          }
          return false;
        }
        var hit;
        if (typeof p === "string") {
          if (options.nocase) {
            hit = f.toLowerCase() === p.toLowerCase();
          } else {
            hit = f === p;
          }
          this.debug("string match", p, f, hit);
        } else {
          hit = f.match(p);
          this.debug("pattern match", p, f, hit);
        }
        if (!hit)
          return false;
      }
      if (fi === fl && pi === pl) {
        return true;
      } else if (fi === fl) {
        return partial;
      } else if (pi === pl) {
        var emptyFileEnd = fi === fl - 1 && file[fi] === "";
        return emptyFileEnd;
      }
      throw new Error("wtf?");
    };
    function globUnescape(s) {
      return s.replace(/\\(.)/g, "$1");
    }
    function regExpEscape(s) {
      return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result = splitDeviceRe.exec(path);
      var device = result[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/glob/common.js
var require_common2 = __commonJS({
  "node_modules/glob/common.js"(exports) {
    exports.alphasort = alphasort;
    exports.alphasorti = alphasorti;
    exports.setopts = setopts;
    exports.ownProp = ownProp;
    exports.makeAbs = makeAbs;
    exports.finish = finish;
    exports.mark = mark;
    exports.isIgnored = isIgnored;
    exports.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var path = require("path");
    var minimatch = require_minimatch();
    var isAbsolute = require_path_is_absolute();
    var Minimatch = minimatch.Minimatch;
    function alphasorti(a, b) {
      return a.toLowerCase().localeCompare(b.toLowerCase());
    }
    function alphasort(a, b) {
      return a.localeCompare(b);
    }
    function setupIgnores(self2, options) {
      self2.ignore = options.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern) {
      var gmatcher = null;
      if (pattern.slice(-3) === "/**") {
        var gpattern = pattern.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern, options) {
      if (!options)
        options = {};
      if (options.matchBase && pattern.indexOf("/") === -1) {
        if (options.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern = "**/" + pattern;
      }
      self2.silent = !!options.silent;
      self2.pattern = pattern;
      self2.strict = options.strict !== false;
      self2.realpath = !!options.realpath;
      self2.realpathCache = options.realpathCache || Object.create(null);
      self2.follow = !!options.follow;
      self2.dot = !!options.dot;
      self2.mark = !!options.mark;
      self2.nodir = !!options.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options.sync;
      self2.nounique = !!options.nounique;
      self2.nonull = !!options.nonull;
      self2.nosort = !!options.nosort;
      self2.nocase = !!options.nocase;
      self2.stat = !!options.stat;
      self2.noprocess = !!options.noprocess;
      self2.absolute = !!options.absolute;
      self2.maxLength = options.maxLength || Infinity;
      self2.cache = options.cache || Object.create(null);
      self2.statCache = options.statCache || Object.create(null);
      self2.symlinks = options.symlinks || Object.create(null);
      setupIgnores(self2, options);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options, "cwd"))
        self2.cwd = cwd;
      else {
        self2.cwd = path.resolve(options.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      if (process.platform === "win32")
        self2.root = self2.root.replace(/\\/g, "/");
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      if (process.platform === "win32")
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      self2.nomount = !!options.nomount;
      options.nonegate = true;
      options.nocomment = true;
      self2.minimatch = new Minimatch(pattern, options);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : Object.create(null);
      for (var i = 0, l = self2.matches.length; i < l; i++) {
        var matches = self2.matches[i];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(self2.nocase ? alphasorti : alphasort);
      if (self2.mark) {
        for (var i = 0; i < all.length; i++) {
          all[i] = self2._mark(all[i]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
  "node_modules/glob/sync.js"(exports, module2) {
    module2.exports = globSync;
    globSync.GlobSync = GlobSync;
    var fs = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var Glob = require_glob().Glob;
    var util = require("util");
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    function globSync(pattern, options) {
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      return new GlobSync(pattern, options).found;
    }
    function GlobSync(pattern, options) {
      if (!pattern)
        throw new Error("must provide pattern");
      if (typeof options === "function" || arguments.length === 3)
        throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
      if (!(this instanceof GlobSync))
        return new GlobSync(pattern, options);
      setopts(this, pattern, options);
      if (this.noprocess)
        return this;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false);
      }
      this._finish();
    }
    GlobSync.prototype._finish = function() {
      assert(this instanceof GlobSync);
      if (this.realpath) {
        var self2 = this;
        this.matches.forEach(function(matchset, index) {
          var set = self2.matches[index] = Object.create(null);
          for (var p in matchset) {
            try {
              p = self2._makeAbs(p);
              var real = rp.realpathSync(p, self2.realpathCache);
              set[real] = true;
            } catch (er) {
              if (er.syscall === "stat")
                set[self2._makeAbs(p)] = true;
              else
                throw er;
            }
          }
        });
      }
      common.finish(this);
    };
    GlobSync.prototype._process = function(pattern, index, inGlobStar) {
      assert(this instanceof GlobSync);
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return;
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
    };
    GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return;
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix.slice(-1) !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return;
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix)
          newPattern = [prefix, e];
        else
          newPattern = [e];
        this._process(newPattern.concat(remain), index, inGlobStar);
      }
    };
    GlobSync.prototype._emitMatch = function(index, e) {
      if (isIgnored(this, e))
        return;
      var abs = this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute) {
        e = abs;
      }
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      if (this.stat)
        this._stat(e);
    };
    GlobSync.prototype._readdirInGlobStar = function(abs) {
      if (this.follow)
        return this._readdir(abs, false);
      var entries;
      var lstat;
      var stat;
      try {
        lstat = fs.lstatSync(abs);
      } catch (er) {
        if (er.code === "ENOENT") {
          return null;
        }
      }
      var isSym = lstat && lstat.isSymbolicLink();
      this.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory())
        this.cache[abs] = "FILE";
      else
        entries = this._readdir(abs, false);
      return entries;
    };
    GlobSync.prototype._readdir = function(abs, inGlobStar) {
      var entries;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return null;
        if (Array.isArray(c))
          return c;
      }
      try {
        return this._readdirEntries(abs, fs.readdirSync(abs));
      } catch (er) {
        this._readdirError(abs, er);
        return null;
      }
    };
    GlobSync.prototype._readdirEntries = function(abs, entries) {
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return entries;
    };
    GlobSync.prototype._readdirError = function(f, er) {
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            throw error;
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict)
            throw er;
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
    };
    GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
      var entries = this._readdir(abs, inGlobStar);
      if (!entries)
        return;
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false);
      var len = entries.length;
      var isSym = this.symlinks[abs];
      if (isSym && inGlobStar)
        return;
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true);
      }
    };
    GlobSync.prototype._processSimple = function(prefix, index) {
      var exists = this._stat(prefix);
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return;
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
    };
    GlobSync.prototype._stat = function(f) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return false;
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return c;
        if (needDir && c === "FILE")
          return false;
      }
      var exists;
      var stat = this.statCache[abs];
      if (!stat) {
        var lstat;
        try {
          lstat = fs.lstatSync(abs);
        } catch (er) {
          if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
            this.statCache[abs] = false;
            return false;
          }
        }
        if (lstat && lstat.isSymbolicLink()) {
          try {
            stat = fs.statSync(abs);
          } catch (er) {
            stat = lstat;
          }
        } else {
          stat = lstat;
        }
      }
      this.statCache[abs] = stat;
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return false;
      return c;
    };
    GlobSync.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    GlobSync.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports, module2) {
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb)
        return wrappy(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS({
  "node_modules/once/once.js"(exports, module2) {
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  }
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
  "node_modules/inflight/inflight.js"(exports, module2) {
    var wrappy = require_wrappy();
    var reqs = Object.create(null);
    var once = require_once();
    module2.exports = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i = 0; i < len; i++) {
            cbs[i].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i = 0; i < length; i++)
        array[i] = args[i];
      return array;
    }
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
  "node_modules/glob/glob.js"(exports, module2) {
    module2.exports = glob;
    var fs = require("fs");
    var rp = require_fs();
    var minimatch = require_minimatch();
    var Minimatch = minimatch.Minimatch;
    var inherits = require_inherits();
    var EE = require("events").EventEmitter;
    var path = require("path");
    var assert = require("assert");
    var isAbsolute = require_path_is_absolute();
    var globSync = require_sync();
    var common = require_common2();
    var alphasort = common.alphasort;
    var alphasorti = common.alphasorti;
    var setopts = common.setopts;
    var ownProp = common.ownProp;
    var inflight = require_inflight();
    var util = require("util");
    var childrenIgnored = common.childrenIgnored;
    var isIgnored = common.isIgnored;
    var once = require_once();
    function glob(pattern, options, cb) {
      if (typeof options === "function")
        cb = options, options = {};
      if (!options)
        options = {};
      if (options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return globSync(pattern, options);
      }
      return new Glob(pattern, options, cb);
    }
    glob.sync = globSync;
    var GlobSync = glob.GlobSync = globSync.GlobSync;
    glob.glob = glob;
    function extend(origin, add) {
      if (add === null || typeof add !== "object") {
        return origin;
      }
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    }
    glob.hasMagic = function(pattern, options_) {
      var options = extend({}, options_);
      options.noprocess = true;
      var g = new Glob(pattern, options);
      var set = g.minimatch.set;
      if (!pattern)
        return false;
      if (set.length > 1)
        return true;
      for (var j = 0; j < set[0].length; j++) {
        if (typeof set[0][j] !== "string")
          return true;
      }
      return false;
    };
    glob.Glob = Glob;
    inherits(Glob, EE);
    function Glob(pattern, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      if (options && options.sync) {
        if (cb)
          throw new TypeError("callback provided to sync glob");
        return new GlobSync(pattern, options);
      }
      if (!(this instanceof Glob))
        return new Glob(pattern, options, cb);
      setopts(this, pattern, options);
      this._didRealPath = false;
      var n = this.minimatch.set.length;
      this.matches = new Array(n);
      if (typeof cb === "function") {
        cb = once(cb);
        this.on("error", cb);
        this.on("end", function(matches) {
          cb(null, matches);
        });
      }
      var self2 = this;
      this._processing = 0;
      this._emitQueue = [];
      this._processQueue = [];
      this.paused = false;
      if (this.noprocess)
        return this;
      if (n === 0)
        return done();
      var sync = true;
      for (var i = 0; i < n; i++) {
        this._process(this.minimatch.set[i], i, false, done);
      }
      sync = false;
      function done() {
        --self2._processing;
        if (self2._processing <= 0) {
          if (sync) {
            process.nextTick(function() {
              self2._finish();
            });
          } else {
            self2._finish();
          }
        }
      }
    }
    Glob.prototype._finish = function() {
      assert(this instanceof Glob);
      if (this.aborted)
        return;
      if (this.realpath && !this._didRealpath)
        return this._realpath();
      common.finish(this);
      this.emit("end", this.found);
    };
    Glob.prototype._realpath = function() {
      if (this._didRealpath)
        return;
      this._didRealpath = true;
      var n = this.matches.length;
      if (n === 0)
        return this._finish();
      var self2 = this;
      for (var i = 0; i < this.matches.length; i++)
        this._realpathSet(i, next);
      function next() {
        if (--n === 0)
          self2._finish();
      }
    };
    Glob.prototype._realpathSet = function(index, cb) {
      var matchset = this.matches[index];
      if (!matchset)
        return cb();
      var found = Object.keys(matchset);
      var self2 = this;
      var n = found.length;
      if (n === 0)
        return cb();
      var set = this.matches[index] = Object.create(null);
      found.forEach(function(p, i) {
        p = self2._makeAbs(p);
        rp.realpath(p, self2.realpathCache, function(er, real) {
          if (!er)
            set[real] = true;
          else if (er.syscall === "stat")
            set[p] = true;
          else
            self2.emit("error", er);
          if (--n === 0) {
            self2.matches[index] = set;
            cb();
          }
        });
      });
    };
    Glob.prototype._mark = function(p) {
      return common.mark(this, p);
    };
    Glob.prototype._makeAbs = function(f) {
      return common.makeAbs(this, f);
    };
    Glob.prototype.abort = function() {
      this.aborted = true;
      this.emit("abort");
    };
    Glob.prototype.pause = function() {
      if (!this.paused) {
        this.paused = true;
        this.emit("pause");
      }
    };
    Glob.prototype.resume = function() {
      if (this.paused) {
        this.emit("resume");
        this.paused = false;
        if (this._emitQueue.length) {
          var eq = this._emitQueue.slice(0);
          this._emitQueue.length = 0;
          for (var i = 0; i < eq.length; i++) {
            var e = eq[i];
            this._emitMatch(e[0], e[1]);
          }
        }
        if (this._processQueue.length) {
          var pq = this._processQueue.slice(0);
          this._processQueue.length = 0;
          for (var i = 0; i < pq.length; i++) {
            var p = pq[i];
            this._processing--;
            this._process(p[0], p[1], p[2], p[3]);
          }
        }
      }
    };
    Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
      assert(this instanceof Glob);
      assert(typeof cb === "function");
      if (this.aborted)
        return;
      this._processing++;
      if (this.paused) {
        this._processQueue.push([pattern, index, inGlobStar, cb]);
        return;
      }
      var n = 0;
      while (typeof pattern[n] === "string") {
        n++;
      }
      var prefix;
      switch (n) {
        case pattern.length:
          this._processSimple(pattern.join("/"), index, cb);
          return;
        case 0:
          prefix = null;
          break;
        default:
          prefix = pattern.slice(0, n).join("/");
          break;
      }
      var remain = pattern.slice(n);
      var read;
      if (prefix === null)
        read = ".";
      else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
        if (!prefix || !isAbsolute(prefix))
          prefix = "/" + prefix;
        read = prefix;
      } else
        read = prefix;
      var abs = this._makeAbs(read);
      if (childrenIgnored(this, read))
        return cb();
      var isGlobStar = remain[0] === minimatch.GLOBSTAR;
      if (isGlobStar)
        this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
      else
        this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
    };
    Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var pn = remain[0];
      var negate = !!this.minimatch.negate;
      var rawGlob = pn._glob;
      var dotOk = this.dot || rawGlob.charAt(0) === ".";
      var matchedEntries = [];
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (e.charAt(0) !== "." || dotOk) {
          var m;
          if (negate && !prefix) {
            m = !e.match(pn);
          } else {
            m = e.match(pn);
          }
          if (m)
            matchedEntries.push(e);
        }
      }
      var len = matchedEntries.length;
      if (len === 0)
        return cb();
      if (remain.length === 1 && !this.mark && !this.stat) {
        if (!this.matches[index])
          this.matches[index] = Object.create(null);
        for (var i = 0; i < len; i++) {
          var e = matchedEntries[i];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          if (e.charAt(0) === "/" && !this.nomount) {
            e = path.join(this.root, e);
          }
          this._emitMatch(index, e);
        }
        return cb();
      }
      remain.shift();
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        var newPattern;
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        this._process([e].concat(remain), index, inGlobStar, cb);
      }
      cb();
    };
    Glob.prototype._emitMatch = function(index, e) {
      if (this.aborted)
        return;
      if (isIgnored(this, e))
        return;
      if (this.paused) {
        this._emitQueue.push([index, e]);
        return;
      }
      var abs = isAbsolute(e) ? e : this._makeAbs(e);
      if (this.mark)
        e = this._mark(e);
      if (this.absolute)
        e = abs;
      if (this.matches[index][e])
        return;
      if (this.nodir) {
        var c = this.cache[abs];
        if (c === "DIR" || Array.isArray(c))
          return;
      }
      this.matches[index][e] = true;
      var st = this.statCache[abs];
      if (st)
        this.emit("stat", e, st);
      this.emit("match", e);
    };
    Glob.prototype._readdirInGlobStar = function(abs, cb) {
      if (this.aborted)
        return;
      if (this.follow)
        return this._readdir(abs, false, cb);
      var lstatkey = "lstat\0" + abs;
      var self2 = this;
      var lstatcb = inflight(lstatkey, lstatcb_);
      if (lstatcb)
        fs.lstat(abs, lstatcb);
      function lstatcb_(er, lstat) {
        if (er && er.code === "ENOENT")
          return cb();
        var isSym = lstat && lstat.isSymbolicLink();
        self2.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory()) {
          self2.cache[abs] = "FILE";
          cb();
        } else
          self2._readdir(abs, false, cb);
      }
    };
    Glob.prototype._readdir = function(abs, inGlobStar, cb) {
      if (this.aborted)
        return;
      cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
      if (!cb)
        return;
      if (inGlobStar && !ownProp(this.symlinks, abs))
        return this._readdirInGlobStar(abs, cb);
      if (ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (!c || c === "FILE")
          return cb();
        if (Array.isArray(c))
          return cb(null, c);
      }
      var self2 = this;
      fs.readdir(abs, readdirCb(this, abs, cb));
    };
    function readdirCb(self2, abs, cb) {
      return function(er, entries) {
        if (er)
          self2._readdirError(abs, er, cb);
        else
          self2._readdirEntries(abs, entries, cb);
      };
    }
    Glob.prototype._readdirEntries = function(abs, entries, cb) {
      if (this.aborted)
        return;
      if (!this.mark && !this.stat) {
        for (var i = 0; i < entries.length; i++) {
          var e = entries[i];
          if (abs === "/")
            e = abs + e;
          else
            e = abs + "/" + e;
          this.cache[e] = true;
        }
      }
      this.cache[abs] = entries;
      return cb(null, entries);
    };
    Glob.prototype._readdirError = function(f, er, cb) {
      if (this.aborted)
        return;
      switch (er.code) {
        case "ENOTSUP":
        case "ENOTDIR":
          var abs = this._makeAbs(f);
          this.cache[abs] = "FILE";
          if (abs === this.cwdAbs) {
            var error = new Error(er.code + " invalid cwd " + this.cwd);
            error.path = this.cwd;
            error.code = er.code;
            this.emit("error", error);
            this.abort();
          }
          break;
        case "ENOENT":
        case "ELOOP":
        case "ENAMETOOLONG":
        case "UNKNOWN":
          this.cache[this._makeAbs(f)] = false;
          break;
        default:
          this.cache[this._makeAbs(f)] = false;
          if (this.strict) {
            this.emit("error", er);
            this.abort();
          }
          if (!this.silent)
            console.error("glob error", er);
          break;
      }
      return cb();
    };
    Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
      var self2 = this;
      this._readdir(abs, inGlobStar, function(er, entries) {
        self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
      });
    };
    Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
      if (!entries)
        return cb();
      var remainWithoutGlobStar = remain.slice(1);
      var gspref = prefix ? [prefix] : [];
      var noGlobStar = gspref.concat(remainWithoutGlobStar);
      this._process(noGlobStar, index, false, cb);
      var isSym = this.symlinks[abs];
      var len = entries.length;
      if (isSym && inGlobStar)
        return cb();
      for (var i = 0; i < len; i++) {
        var e = entries[i];
        if (e.charAt(0) === "." && !this.dot)
          continue;
        var instead = gspref.concat(entries[i], remainWithoutGlobStar);
        this._process(instead, index, true, cb);
        var below = gspref.concat(entries[i], remain);
        this._process(below, index, true, cb);
      }
      cb();
    };
    Glob.prototype._processSimple = function(prefix, index, cb) {
      var self2 = this;
      this._stat(prefix, function(er, exists) {
        self2._processSimple2(prefix, index, er, exists, cb);
      });
    };
    Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      if (!exists)
        return cb();
      if (prefix && isAbsolute(prefix) && !this.nomount) {
        var trail = /[\/\\]$/.test(prefix);
        if (prefix.charAt(0) === "/") {
          prefix = path.join(this.root, prefix);
        } else {
          prefix = path.resolve(this.root, prefix);
          if (trail)
            prefix += "/";
        }
      }
      if (process.platform === "win32")
        prefix = prefix.replace(/\\/g, "/");
      this._emitMatch(index, prefix);
      cb();
    };
    Glob.prototype._stat = function(f, cb) {
      var abs = this._makeAbs(f);
      var needDir = f.slice(-1) === "/";
      if (f.length > this.maxLength)
        return cb();
      if (!this.stat && ownProp(this.cache, abs)) {
        var c = this.cache[abs];
        if (Array.isArray(c))
          c = "DIR";
        if (!needDir || c === "DIR")
          return cb(null, c);
        if (needDir && c === "FILE")
          return cb();
      }
      var exists;
      var stat = this.statCache[abs];
      if (stat !== void 0) {
        if (stat === false)
          return cb(null, stat);
        else {
          var type = stat.isDirectory() ? "DIR" : "FILE";
          if (needDir && type === "FILE")
            return cb();
          else
            return cb(null, type, stat);
        }
      }
      var self2 = this;
      var statcb = inflight("stat\0" + abs, lstatcb_);
      if (statcb)
        fs.lstat(abs, statcb);
      function lstatcb_(er, lstat) {
        if (lstat && lstat.isSymbolicLink()) {
          return fs.stat(abs, function(er2, stat2) {
            if (er2)
              self2._stat2(f, abs, null, lstat, cb);
            else
              self2._stat2(f, abs, er2, stat2, cb);
          });
        } else {
          self2._stat2(f, abs, er, lstat, cb);
        }
      }
    };
    Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
      if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
        this.statCache[abs] = false;
        return cb();
      }
      var needDir = f.slice(-1) === "/";
      this.statCache[abs] = stat;
      if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
        return cb(null, false, stat);
      var c = true;
      if (stat)
        c = stat.isDirectory() ? "DIR" : "FILE";
      this.cache[abs] = this.cache[abs] || c;
      if (needDir && c === "FILE")
        return cb();
      return cb(null, c, stat);
    };
  }
});

// node_modules/puppeteer/node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS({
  "node_modules/puppeteer/node_modules/rimraf/rimraf.js"(exports, module2) {
    module2.exports = rimraf;
    rimraf.sync = rimrafSync;
    var assert = require("assert");
    var path = require("path");
    var fs = require("fs");
    var glob = void 0;
    try {
      glob = require_glob();
    } catch (_err) {
    }
    var _0666 = parseInt("666", 8);
    var defaultGlobOpts = {
      nosort: true,
      silent: true
    };
    var timeout = 0;
    var isWindows = process.platform === "win32";
    function defaults(options) {
      var methods = [
        "unlink",
        "chmod",
        "stat",
        "lstat",
        "rmdir",
        "readdir"
      ];
      methods.forEach(function(m) {
        options[m] = options[m] || fs[m];
        m = m + "Sync";
        options[m] = options[m] || fs[m];
      });
      options.maxBusyTries = options.maxBusyTries || 3;
      options.emfileWait = options.emfileWait || 1e3;
      if (options.glob === false) {
        options.disableGlob = true;
      }
      if (options.disableGlob !== true && glob === void 0) {
        throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
      }
      options.disableGlob = options.disableGlob || false;
      options.glob = options.glob || defaultGlobOpts;
    }
    function rimraf(p, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = {};
      }
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert.equal(typeof cb, "function", "rimraf: callback function required");
      assert(options, "rimraf: invalid options argument provided");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      defaults(options);
      var busyTries = 0;
      var errState = null;
      var n = 0;
      if (options.disableGlob || !glob.hasMagic(p))
        return afterGlob(null, [p]);
      options.lstat(p, function(er, stat) {
        if (!er)
          return afterGlob(null, [p]);
        glob(p, options.glob, afterGlob);
      });
      function next(er) {
        errState = errState || er;
        if (--n === 0)
          cb(errState);
      }
      function afterGlob(er, results) {
        if (er)
          return cb(er);
        n = results.length;
        if (n === 0)
          return cb();
        results.forEach(function(p2) {
          rimraf_(p2, options, function CB(er2) {
            if (er2) {
              if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
                busyTries++;
                var time = busyTries * 100;
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, time);
              }
              if (er2.code === "EMFILE" && timeout < options.emfileWait) {
                return setTimeout(function() {
                  rimraf_(p2, options, CB);
                }, timeout++);
              }
              if (er2.code === "ENOENT")
                er2 = null;
            }
            timeout = 0;
            next(er2);
          });
        });
      }
    }
    function rimraf_(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.lstat(p, function(er, st) {
        if (er && er.code === "ENOENT")
          return cb(null);
        if (er && er.code === "EPERM" && isWindows)
          fixWinEPERM(p, options, er, cb);
        if (st && st.isDirectory())
          return rmdir(p, options, er, cb);
        options.unlink(p, function(er2) {
          if (er2) {
            if (er2.code === "ENOENT")
              return cb(null);
            if (er2.code === "EPERM")
              return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
            if (er2.code === "EISDIR")
              return rmdir(p, options, er2, cb);
          }
          return cb(er2);
        });
      });
    }
    function fixWinEPERM(p, options, er, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      if (er)
        assert(er instanceof Error);
      options.chmod(p, _0666, function(er2) {
        if (er2)
          cb(er2.code === "ENOENT" ? null : er);
        else
          options.stat(p, function(er3, stats) {
            if (er3)
              cb(er3.code === "ENOENT" ? null : er);
            else if (stats.isDirectory())
              rmdir(p, options, er, cb);
            else
              options.unlink(p, cb);
          });
      });
    }
    function fixWinEPERMSync(p, options, er) {
      assert(p);
      assert(options);
      if (er)
        assert(er instanceof Error);
      try {
        options.chmodSync(p, _0666);
      } catch (er2) {
        if (er2.code === "ENOENT")
          return;
        else
          throw er;
      }
      try {
        var stats = options.statSync(p);
      } catch (er3) {
        if (er3.code === "ENOENT")
          return;
        else
          throw er;
      }
      if (stats.isDirectory())
        rmdirSync(p, options, er);
      else
        options.unlinkSync(p);
    }
    function rmdir(p, options, originalEr, cb) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      assert(typeof cb === "function");
      options.rmdir(p, function(er) {
        if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
          rmkids(p, options, cb);
        else if (er && er.code === "ENOTDIR")
          cb(originalEr);
        else
          cb(er);
      });
    }
    function rmkids(p, options, cb) {
      assert(p);
      assert(options);
      assert(typeof cb === "function");
      options.readdir(p, function(er, files) {
        if (er)
          return cb(er);
        var n = files.length;
        if (n === 0)
          return options.rmdir(p, cb);
        var errState;
        files.forEach(function(f) {
          rimraf(path.join(p, f), options, function(er2) {
            if (errState)
              return;
            if (er2)
              return cb(errState = er2);
            if (--n === 0)
              options.rmdir(p, cb);
          });
        });
      });
    }
    function rimrafSync(p, options) {
      options = options || {};
      defaults(options);
      assert(p, "rimraf: missing path");
      assert.equal(typeof p, "string", "rimraf: path should be a string");
      assert(options, "rimraf: missing options");
      assert.equal(typeof options, "object", "rimraf: options should be object");
      var results;
      if (options.disableGlob || !glob.hasMagic(p)) {
        results = [p];
      } else {
        try {
          options.lstatSync(p);
          results = [p];
        } catch (er) {
          results = glob.sync(p, options.glob);
        }
      }
      if (!results.length)
        return;
      for (var i = 0; i < results.length; i++) {
        var p = results[i];
        try {
          var st = options.lstatSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM" && isWindows)
            fixWinEPERMSync(p, options, er);
        }
        try {
          if (st && st.isDirectory())
            rmdirSync(p, options, null);
          else
            options.unlinkSync(p);
        } catch (er) {
          if (er.code === "ENOENT")
            return;
          if (er.code === "EPERM")
            return isWindows ? fixWinEPERMSync(p, options, er) : rmdirSync(p, options, er);
          if (er.code !== "EISDIR")
            throw er;
          rmdirSync(p, options, er);
        }
      }
    }
    function rmdirSync(p, options, originalEr) {
      assert(p);
      assert(options);
      if (originalEr)
        assert(originalEr instanceof Error);
      try {
        options.rmdirSync(p);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "ENOTDIR")
          throw originalEr;
        if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
          rmkidsSync(p, options);
      }
    }
    function rmkidsSync(p, options) {
      assert(p);
      assert(options);
      options.readdirSync(p).forEach(function(f) {
        rimrafSync(path.join(p, f), options);
      });
      var retries = isWindows ? 100 : 1;
      var i = 0;
      do {
        var threw = true;
        try {
          var ret = options.rmdirSync(p, options);
          threw = false;
          return ret;
        } finally {
          if (++i < retries && threw)
            continue;
        }
      } while (true);
    }
  }
});

// node_modules/puppeteer/node_modules/agent-base/patch-core.js
var require_patch_core = __commonJS({
  "node_modules/puppeteer/node_modules/agent-base/patch-core.js"() {
    "use strict";
    var url = require("url");
    var https = require("https");
    var patchMarker = "__agent_base_https_request_patched__";
    if (!https.request[patchMarker]) {
      https.request = function(request) {
        return function(_options, cb) {
          let options;
          if (typeof _options === "string") {
            options = url.parse(_options);
          } else {
            options = Object.assign({}, _options);
          }
          if (options.port == null) {
            options.port = 443;
          }
          options.secureEndpoint = true;
          return request.call(https, options, cb);
        };
      }(https.request);
      https.request[patchMarker] = true;
    }
    https.get = function(_url, _options, cb) {
      let options;
      if (typeof _url === "string" && _options && typeof _options !== "function") {
        options = Object.assign({}, url.parse(_url), _options);
      } else if (!_options && !cb) {
        options = _url;
      } else if (!cb) {
        options = _url;
        cb = _options;
      }
      const req = https.request(options, cb);
      req.end();
      return req;
    };
  }
});

// node_modules/es6-promise/dist/es6-promise.js
var require_es6_promise = __commonJS({
  "node_modules/es6-promise/dist/es6-promise.js"(exports, module2) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.ES6Promise = factory();
    })(exports, function() {
      "use strict";
      function objectOrFunction(x) {
        var type = typeof x;
        return x !== null && (type === "object" || type === "function");
      }
      function isFunction(x) {
        return typeof x === "function";
      }
      var _isArray = void 0;
      if (Array.isArray) {
        _isArray = Array.isArray;
      } else {
        _isArray = function(x) {
          return Object.prototype.toString.call(x) === "[object Array]";
        };
      }
      var isArray = _isArray;
      var len = 0;
      var vertxNext = void 0;
      var customSchedulerFn = void 0;
      var asap = function asap2(callback, arg) {
        queue[len] = callback;
        queue[len + 1] = arg;
        len += 2;
        if (len === 2) {
          if (customSchedulerFn) {
            customSchedulerFn(flush);
          } else {
            scheduleFlush();
          }
        }
      };
      function setScheduler(scheduleFn) {
        customSchedulerFn = scheduleFn;
      }
      function setAsap(asapFn) {
        asap = asapFn;
      }
      var browserWindow = typeof window !== "undefined" ? window : void 0;
      var browserGlobal = browserWindow || {};
      var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
      var isNode = typeof self === "undefined" && typeof process !== "undefined" && {}.toString.call(process) === "[object process]";
      var isWorker = typeof Uint8ClampedArray !== "undefined" && typeof importScripts !== "undefined" && typeof MessageChannel !== "undefined";
      function useNextTick() {
        return function() {
          return process.nextTick(flush);
        };
      }
      function useVertxTimer() {
        if (typeof vertxNext !== "undefined") {
          return function() {
            vertxNext(flush);
          };
        }
        return useSetTimeout();
      }
      function useMutationObserver() {
        var iterations = 0;
        var observer = new BrowserMutationObserver(flush);
        var node = document.createTextNode("");
        observer.observe(node, { characterData: true });
        return function() {
          node.data = iterations = ++iterations % 2;
        };
      }
      function useMessageChannel() {
        var channel = new MessageChannel();
        channel.port1.onmessage = flush;
        return function() {
          return channel.port2.postMessage(0);
        };
      }
      function useSetTimeout() {
        var globalSetTimeout = setTimeout;
        return function() {
          return globalSetTimeout(flush, 1);
        };
      }
      var queue = new Array(1e3);
      function flush() {
        for (var i = 0; i < len; i += 2) {
          var callback = queue[i];
          var arg = queue[i + 1];
          callback(arg);
          queue[i] = void 0;
          queue[i + 1] = void 0;
        }
        len = 0;
      }
      function attemptVertx() {
        try {
          var vertx = Function("return this")().require("vertx");
          vertxNext = vertx.runOnLoop || vertx.runOnContext;
          return useVertxTimer();
        } catch (e) {
          return useSetTimeout();
        }
      }
      var scheduleFlush = void 0;
      if (isNode) {
        scheduleFlush = useNextTick();
      } else if (BrowserMutationObserver) {
        scheduleFlush = useMutationObserver();
      } else if (isWorker) {
        scheduleFlush = useMessageChannel();
      } else if (browserWindow === void 0 && typeof require === "function") {
        scheduleFlush = attemptVertx();
      } else {
        scheduleFlush = useSetTimeout();
      }
      function then(onFulfillment, onRejection) {
        var parent = this;
        var child = new this.constructor(noop);
        if (child[PROMISE_ID] === void 0) {
          makePromise(child);
        }
        var _state = parent._state;
        if (_state) {
          var callback = arguments[_state - 1];
          asap(function() {
            return invokeCallback(_state, child, callback, parent._result);
          });
        } else {
          subscribe(parent, child, onFulfillment, onRejection);
        }
        return child;
      }
      function resolve$1(object) {
        var Constructor = this;
        if (object && typeof object === "object" && object.constructor === Constructor) {
          return object;
        }
        var promise = new Constructor(noop);
        resolve(promise, object);
        return promise;
      }
      var PROMISE_ID = Math.random().toString(36).substring(2);
      function noop() {
      }
      var PENDING = void 0;
      var FULFILLED = 1;
      var REJECTED = 2;
      function selfFulfillment() {
        return new TypeError("You cannot resolve a promise with itself");
      }
      function cannotReturnOwn() {
        return new TypeError("A promises callback cannot return that same promise.");
      }
      function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
        try {
          then$$1.call(value, fulfillmentHandler, rejectionHandler);
        } catch (e) {
          return e;
        }
      }
      function handleForeignThenable(promise, thenable, then$$1) {
        asap(function(promise2) {
          var sealed = false;
          var error = tryThen(then$$1, thenable, function(value) {
            if (sealed) {
              return;
            }
            sealed = true;
            if (thenable !== value) {
              resolve(promise2, value);
            } else {
              fulfill(promise2, value);
            }
          }, function(reason) {
            if (sealed) {
              return;
            }
            sealed = true;
            reject(promise2, reason);
          }, "Settle: " + (promise2._label || " unknown promise"));
          if (!sealed && error) {
            sealed = true;
            reject(promise2, error);
          }
        }, promise);
      }
      function handleOwnThenable(promise, thenable) {
        if (thenable._state === FULFILLED) {
          fulfill(promise, thenable._result);
        } else if (thenable._state === REJECTED) {
          reject(promise, thenable._result);
        } else {
          subscribe(thenable, void 0, function(value) {
            return resolve(promise, value);
          }, function(reason) {
            return reject(promise, reason);
          });
        }
      }
      function handleMaybeThenable(promise, maybeThenable, then$$1) {
        if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
          handleOwnThenable(promise, maybeThenable);
        } else {
          if (then$$1 === void 0) {
            fulfill(promise, maybeThenable);
          } else if (isFunction(then$$1)) {
            handleForeignThenable(promise, maybeThenable, then$$1);
          } else {
            fulfill(promise, maybeThenable);
          }
        }
      }
      function resolve(promise, value) {
        if (promise === value) {
          reject(promise, selfFulfillment());
        } else if (objectOrFunction(value)) {
          var then$$1 = void 0;
          try {
            then$$1 = value.then;
          } catch (error) {
            reject(promise, error);
            return;
          }
          handleMaybeThenable(promise, value, then$$1);
        } else {
          fulfill(promise, value);
        }
      }
      function publishRejection(promise) {
        if (promise._onerror) {
          promise._onerror(promise._result);
        }
        publish(promise);
      }
      function fulfill(promise, value) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._result = value;
        promise._state = FULFILLED;
        if (promise._subscribers.length !== 0) {
          asap(publish, promise);
        }
      }
      function reject(promise, reason) {
        if (promise._state !== PENDING) {
          return;
        }
        promise._state = REJECTED;
        promise._result = reason;
        asap(publishRejection, promise);
      }
      function subscribe(parent, child, onFulfillment, onRejection) {
        var _subscribers = parent._subscribers;
        var length = _subscribers.length;
        parent._onerror = null;
        _subscribers[length] = child;
        _subscribers[length + FULFILLED] = onFulfillment;
        _subscribers[length + REJECTED] = onRejection;
        if (length === 0 && parent._state) {
          asap(publish, parent);
        }
      }
      function publish(promise) {
        var subscribers = promise._subscribers;
        var settled = promise._state;
        if (subscribers.length === 0) {
          return;
        }
        var child = void 0, callback = void 0, detail = promise._result;
        for (var i = 0; i < subscribers.length; i += 3) {
          child = subscribers[i];
          callback = subscribers[i + settled];
          if (child) {
            invokeCallback(settled, child, callback, detail);
          } else {
            callback(detail);
          }
        }
        promise._subscribers.length = 0;
      }
      function invokeCallback(settled, promise, callback, detail) {
        var hasCallback = isFunction(callback), value = void 0, error = void 0, succeeded = true;
        if (hasCallback) {
          try {
            value = callback(detail);
          } catch (e) {
            succeeded = false;
            error = e;
          }
          if (promise === value) {
            reject(promise, cannotReturnOwn());
            return;
          }
        } else {
          value = detail;
        }
        if (promise._state !== PENDING) {
        } else if (hasCallback && succeeded) {
          resolve(promise, value);
        } else if (succeeded === false) {
          reject(promise, error);
        } else if (settled === FULFILLED) {
          fulfill(promise, value);
        } else if (settled === REJECTED) {
          reject(promise, value);
        }
      }
      function initializePromise(promise, resolver) {
        try {
          resolver(function resolvePromise(value) {
            resolve(promise, value);
          }, function rejectPromise(reason) {
            reject(promise, reason);
          });
        } catch (e) {
          reject(promise, e);
        }
      }
      var id = 0;
      function nextId() {
        return id++;
      }
      function makePromise(promise) {
        promise[PROMISE_ID] = id++;
        promise._state = void 0;
        promise._result = void 0;
        promise._subscribers = [];
      }
      function validationError() {
        return new Error("Array Methods must be provided an Array");
      }
      var Enumerator = function() {
        function Enumerator2(Constructor, input) {
          this._instanceConstructor = Constructor;
          this.promise = new Constructor(noop);
          if (!this.promise[PROMISE_ID]) {
            makePromise(this.promise);
          }
          if (isArray(input)) {
            this.length = input.length;
            this._remaining = input.length;
            this._result = new Array(this.length);
            if (this.length === 0) {
              fulfill(this.promise, this._result);
            } else {
              this.length = this.length || 0;
              this._enumerate(input);
              if (this._remaining === 0) {
                fulfill(this.promise, this._result);
              }
            }
          } else {
            reject(this.promise, validationError());
          }
        }
        Enumerator2.prototype._enumerate = function _enumerate(input) {
          for (var i = 0; this._state === PENDING && i < input.length; i++) {
            this._eachEntry(input[i], i);
          }
        };
        Enumerator2.prototype._eachEntry = function _eachEntry(entry, i) {
          var c = this._instanceConstructor;
          var resolve$$1 = c.resolve;
          if (resolve$$1 === resolve$1) {
            var _then = void 0;
            var error = void 0;
            var didError = false;
            try {
              _then = entry.then;
            } catch (e) {
              didError = true;
              error = e;
            }
            if (_then === then && entry._state !== PENDING) {
              this._settledAt(entry._state, i, entry._result);
            } else if (typeof _then !== "function") {
              this._remaining--;
              this._result[i] = entry;
            } else if (c === Promise$1) {
              var promise = new c(noop);
              if (didError) {
                reject(promise, error);
              } else {
                handleMaybeThenable(promise, entry, _then);
              }
              this._willSettleAt(promise, i);
            } else {
              this._willSettleAt(new c(function(resolve$$12) {
                return resolve$$12(entry);
              }), i);
            }
          } else {
            this._willSettleAt(resolve$$1(entry), i);
          }
        };
        Enumerator2.prototype._settledAt = function _settledAt(state, i, value) {
          var promise = this.promise;
          if (promise._state === PENDING) {
            this._remaining--;
            if (state === REJECTED) {
              reject(promise, value);
            } else {
              this._result[i] = value;
            }
          }
          if (this._remaining === 0) {
            fulfill(promise, this._result);
          }
        };
        Enumerator2.prototype._willSettleAt = function _willSettleAt(promise, i) {
          var enumerator = this;
          subscribe(promise, void 0, function(value) {
            return enumerator._settledAt(FULFILLED, i, value);
          }, function(reason) {
            return enumerator._settledAt(REJECTED, i, reason);
          });
        };
        return Enumerator2;
      }();
      function all(entries) {
        return new Enumerator(this, entries).promise;
      }
      function race(entries) {
        var Constructor = this;
        if (!isArray(entries)) {
          return new Constructor(function(_, reject2) {
            return reject2(new TypeError("You must pass an array to race."));
          });
        } else {
          return new Constructor(function(resolve2, reject2) {
            var length = entries.length;
            for (var i = 0; i < length; i++) {
              Constructor.resolve(entries[i]).then(resolve2, reject2);
            }
          });
        }
      }
      function reject$1(reason) {
        var Constructor = this;
        var promise = new Constructor(noop);
        reject(promise, reason);
        return promise;
      }
      function needsResolver() {
        throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      }
      function needsNew() {
        throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
      }
      var Promise$1 = function() {
        function Promise2(resolver) {
          this[PROMISE_ID] = nextId();
          this._result = this._state = void 0;
          this._subscribers = [];
          if (noop !== resolver) {
            typeof resolver !== "function" && needsResolver();
            this instanceof Promise2 ? initializePromise(this, resolver) : needsNew();
          }
        }
        Promise2.prototype.catch = function _catch(onRejection) {
          return this.then(null, onRejection);
        };
        Promise2.prototype.finally = function _finally(callback) {
          var promise = this;
          var constructor = promise.constructor;
          if (isFunction(callback)) {
            return promise.then(function(value) {
              return constructor.resolve(callback()).then(function() {
                return value;
              });
            }, function(reason) {
              return constructor.resolve(callback()).then(function() {
                throw reason;
              });
            });
          }
          return promise.then(callback, callback);
        };
        return Promise2;
      }();
      Promise$1.prototype.then = then;
      Promise$1.all = all;
      Promise$1.race = race;
      Promise$1.resolve = resolve$1;
      Promise$1.reject = reject$1;
      Promise$1._setScheduler = setScheduler;
      Promise$1._setAsap = setAsap;
      Promise$1._asap = asap;
      function polyfill() {
        var local = void 0;
        if (typeof global !== "undefined") {
          local = global;
        } else if (typeof self !== "undefined") {
          local = self;
        } else {
          try {
            local = Function("return this")();
          } catch (e) {
            throw new Error("polyfill failed because global object is unavailable in this environment");
          }
        }
        var P = local.Promise;
        if (P) {
          var promiseToString = null;
          try {
            promiseToString = Object.prototype.toString.call(P.resolve());
          } catch (e) {
          }
          if (promiseToString === "[object Promise]" && !P.cast) {
            return;
          }
        }
        local.Promise = Promise$1;
      }
      Promise$1.polyfill = polyfill;
      Promise$1.Promise = Promise$1;
      return Promise$1;
    });
  }
});

// node_modules/es6-promisify/dist/promise.js
var require_promise = __commonJS({
  "node_modules/es6-promisify/dist/promise.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      "use strict";
      var globalObject = void 0;
      function isFunction(x) {
        return typeof x === "function";
      }
      if (global !== void 0) {
        globalObject = global;
      } else if (window !== void 0 && window.document) {
        globalObject = window;
      } else {
        globalObject = self;
      }
      var hasPromiseSupport = function() {
        if (!globalObject.hasOwnProperty("Promise")) {
          return false;
        }
        var P = globalObject.Promise;
        if (!P.hasOwnProperty("resolve") || !P.hasOwnProperty("reject")) {
          return false;
        }
        if (!P.hasOwnProperty("all") || !P.hasOwnProperty("race")) {
          return false;
        }
        return function() {
          var resolve = void 0;
          var p = new globalObject.Promise(function(r) {
            resolve = r;
          });
          if (p) {
            return isFunction(resolve);
          }
          return false;
        }();
      }();
      if (hasPromiseSupport) {
        return globalObject.Promise;
      }
      return require_es6_promise().Promise;
    }();
  }
});

// node_modules/es6-promisify/dist/promisify.js
var require_promisify = __commonJS({
  "node_modules/es6-promisify/dist/promisify.js"(exports, module2) {
    "use strict";
    module2.exports = function() {
      "use strict";
      var ES6Promise = require_promise();
      function thatLooksLikeAPromiseToMe(o) {
        return o && typeof o.then === "function" && typeof o.catch === "function";
      }
      return function promisify(original, settings) {
        return function() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var returnMultipleArguments = settings && settings.multiArgs;
          var target = void 0;
          if (settings && settings.thisArg) {
            target = settings.thisArg;
          } else if (settings) {
            target = settings;
          }
          return new ES6Promise(function(resolve, reject) {
            args.push(function callback(err) {
              if (err) {
                return reject(err);
              }
              for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                values[_key2 - 1] = arguments[_key2];
              }
              if (!!returnMultipleArguments === false) {
                return resolve(values[0]);
              }
              resolve(values);
            });
            var response = original.apply(target, args);
            if (thatLooksLikeAPromiseToMe(response)) {
              resolve(response);
            }
          });
        };
      };
    }();
  }
});

// node_modules/puppeteer/node_modules/agent-base/index.js
var require_agent_base = __commonJS({
  "node_modules/puppeteer/node_modules/agent-base/index.js"(exports, module2) {
    "use strict";
    require_patch_core();
    var inherits = require("util").inherits;
    var promisify = require_promisify();
    var EventEmitter = require("events").EventEmitter;
    module2.exports = Agent;
    function isAgent(v) {
      return v && typeof v.addRequest === "function";
    }
    function Agent(callback, _opts) {
      if (!(this instanceof Agent)) {
        return new Agent(callback, _opts);
      }
      EventEmitter.call(this);
      this._promisifiedCallback = false;
      let opts = _opts;
      if (typeof callback === "function") {
        this.callback = callback;
      } else if (callback) {
        opts = callback;
      }
      this.timeout = opts && opts.timeout || null;
      this.options = opts;
    }
    inherits(Agent, EventEmitter);
    Agent.prototype.callback = function callback(req, opts) {
      throw new Error('"agent-base" has no default implementation, you must subclass and override `callback()`');
    };
    Agent.prototype.addRequest = function addRequest(req, _opts) {
      const ownOpts = Object.assign({}, _opts);
      if (ownOpts.host == null) {
        ownOpts.host = "localhost";
      }
      if (ownOpts.port == null) {
        ownOpts.port = ownOpts.secureEndpoint ? 443 : 80;
      }
      const opts = Object.assign({}, this.options, ownOpts);
      if (opts.host && opts.path) {
        delete opts.path;
      }
      delete opts.agent;
      delete opts.hostname;
      delete opts._defaultAgent;
      delete opts.defaultPort;
      delete opts.createConnection;
      req._last = true;
      req.shouldKeepAlive = false;
      let timeout;
      let timedOut = false;
      const timeoutMs = this.timeout;
      const freeSocket = this.freeSocket;
      function onerror(err) {
        if (req._hadError)
          return;
        req.emit("error", err);
        req._hadError = true;
      }
      function ontimeout() {
        timeout = null;
        timedOut = true;
        const err = new Error('A "socket" was not created for HTTP request before ' + timeoutMs + "ms");
        err.code = "ETIMEOUT";
        onerror(err);
      }
      function callbackError(err) {
        if (timedOut)
          return;
        if (timeout != null) {
          clearTimeout(timeout);
          timeout = null;
        }
        onerror(err);
      }
      function onsocket(socket) {
        if (timedOut)
          return;
        if (timeout != null) {
          clearTimeout(timeout);
          timeout = null;
        }
        if (isAgent(socket)) {
          socket.addRequest(req, opts);
        } else if (socket) {
          let onfree = function() {
            freeSocket(socket, opts);
          };
          socket.on("free", onfree);
          req.onSocket(socket);
        } else {
          const err = new Error("no Duplex stream was returned to agent-base for `" + req.method + " " + req.path + "`");
          onerror(err);
        }
      }
      if (!this._promisifiedCallback && this.callback.length >= 3) {
        this.callback = promisify(this.callback, this);
        this._promisifiedCallback = true;
      }
      if (timeoutMs > 0) {
        timeout = setTimeout(ontimeout, timeoutMs);
      }
      try {
        Promise.resolve(this.callback(req, opts)).then(onsocket, callbackError);
      } catch (err) {
        Promise.reject(err).catch(callbackError);
      }
    };
    Agent.prototype.freeSocket = function freeSocket(socket, opts) {
      socket.destroy();
    };
  }
});

// node_modules/puppeteer/node_modules/ms/index.js
var require_ms3 = __commonJS({
  "node_modules/puppeteer/node_modules/ms/index.js"(exports, module2) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/common.js"(exports, module2) {
    "use strict";
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms3();
      Object.keys(env).forEach(function(key) {
        createDebug[key] = env[key];
      });
      createDebug.instances = [];
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        var hash = 0;
        for (var i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        var prevTime;
        function debug() {
          if (!debug.enabled) {
            return;
          }
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var self2 = debug;
          var curr = Number(new Date());
          var ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          var index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
            if (match === "%%") {
              return match;
            }
            index++;
            var formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              var val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          var logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.enabled = createDebug.enabled(namespace);
        debug.useColors = createDebug.useColors();
        debug.color = selectColor(namespace);
        debug.destroy = destroy;
        debug.extend = extend;
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        createDebug.instances.push(debug);
        return debug;
      }
      function destroy() {
        var index = createDebug.instances.indexOf(this);
        if (index !== -1) {
          createDebug.instances.splice(index, 1);
          return true;
        }
        return false;
      }
      function extend(namespace, delimiter) {
        return createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.names = [];
        createDebug.skips = [];
        var i;
        var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        var len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
        for (i = 0; i < createDebug.instances.length; i++) {
          var instance = createDebug.instances[i];
          instance.enabled = createDebug.enabled(instance.namespace);
        }
      }
      function disable() {
        createDebug.enable("");
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        var i;
        var len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/browser.js"(exports, module2) {
    "use strict";
    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      var _console;
      return (typeof console === "undefined" ? "undefined" : _typeof(console)) === "object" && console.log && (_console = console).log.apply(_console, arguments);
    }
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common3()(exports);
    var formatters = module2.exports.formatters;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/node.js
var require_node4 = __commonJS({
  "node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/node.js"(exports, module2) {
    "use strict";
    var tty = require("tty");
    var util = require("util");
    exports.init = init;
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
      }
    } catch (error) {
    }
    var supportsColor;
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      var name = this.namespace, useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
        var prefix = "  ".concat(colorCode, ";1m").concat(name, " [0m");
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return new Date().toISOString() + " ";
    }
    function log() {
      return process.stderr.write(util.format.apply(util, arguments) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init(debug) {
      debug.inspectOpts = {};
      var keys = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys.length; i++) {
        debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
      }
    }
    module2.exports = require_common3()(exports);
    var formatters = module2.exports.formatters;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts).split("\n").map(function(str) {
        return str.trim();
      }).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/puppeteer/node_modules/https-proxy-agent/node_modules/debug/src/index.js"(exports, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser3();
    } else {
      module2.exports = require_node4();
    }
  }
});

// node_modules/puppeteer/node_modules/https-proxy-agent/index.js
var require_https_proxy_agent = __commonJS({
  "node_modules/puppeteer/node_modules/https-proxy-agent/index.js"(exports, module2) {
    var net = require("net");
    var tls = require("tls");
    var url = require("url");
    var assert = require("assert");
    var Agent = require_agent_base();
    var inherits = require("util").inherits;
    var debug = require_src3()("https-proxy-agent");
    module2.exports = HttpsProxyAgent;
    function HttpsProxyAgent(opts) {
      if (!(this instanceof HttpsProxyAgent))
        return new HttpsProxyAgent(opts);
      if (typeof opts == "string")
        opts = url.parse(opts);
      if (!opts)
        throw new Error("an HTTP(S) proxy server `host` and `port` must be specified!");
      debug("creating new HttpsProxyAgent instance: %o", opts);
      Agent.call(this, opts);
      var proxy = Object.assign({}, opts);
      this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false;
      proxy.host = proxy.hostname || proxy.host;
      proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);
      if (this.secureProxy && !("ALPNProtocols" in proxy)) {
        proxy.ALPNProtocols = ["http 1.1"];
      }
      if (proxy.host && proxy.path) {
        delete proxy.path;
        delete proxy.pathname;
      }
      this.proxy = proxy;
      this.defaultPort = 443;
    }
    inherits(HttpsProxyAgent, Agent);
    HttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {
      var proxy = this.proxy;
      var socket;
      if (this.secureProxy) {
        socket = tls.connect(proxy);
      } else {
        socket = net.connect(proxy);
      }
      var buffers = [];
      var buffersLength = 0;
      function read() {
        var b = socket.read();
        if (b)
          ondata(b);
        else
          socket.once("readable", read);
      }
      function cleanup() {
        socket.removeListener("end", onend);
        socket.removeListener("error", onerror);
        socket.removeListener("close", onclose);
        socket.removeListener("readable", read);
      }
      function onclose(err) {
        debug("onclose had error %o", err);
      }
      function onend() {
        debug("onend");
      }
      function onerror(err) {
        cleanup();
        fn(err);
      }
      function ondata(b) {
        buffers.push(b);
        buffersLength += b.length;
        var buffered = Buffer.concat(buffers, buffersLength);
        var str = buffered.toString("ascii");
        if (!~str.indexOf("\r\n\r\n")) {
          debug("have not received end of HTTP headers yet...");
          read();
          return;
        }
        var firstLine = str.substring(0, str.indexOf("\r\n"));
        var statusCode = +firstLine.split(" ")[1];
        debug("got proxy server response: %o", firstLine);
        if (statusCode == 200) {
          var sock = socket;
          buffers = buffered = null;
          if (opts.secureEndpoint) {
            debug("upgrading proxy-connected socket to TLS connection: %o", opts.host);
            opts.socket = socket;
            opts.servername = opts.servername || opts.host;
            opts.host = null;
            opts.hostname = null;
            opts.port = null;
            sock = tls.connect(opts);
          }
          cleanup();
          req.once("socket", resume);
          fn(null, sock);
        } else {
          cleanup();
          socket.destroy();
          socket = new net.Socket();
          socket.readable = true;
          buffers = buffered;
          req.once("socket", onsocket);
          fn(null, socket);
        }
      }
      function onsocket(socket2) {
        debug("replaying proxy buffer for failed request");
        assert(socket2.listenerCount("data") > 0);
        socket2.push(buffers);
        buffers = null;
      }
      socket.on("error", onerror);
      socket.on("close", onclose);
      socket.on("end", onend);
      read();
      var hostname = opts.host + ":" + opts.port;
      var msg = "CONNECT " + hostname + " HTTP/1.1\r\n";
      var headers = Object.assign({}, proxy.headers);
      if (proxy.auth) {
        headers["Proxy-Authorization"] = "Basic " + Buffer.from(proxy.auth).toString("base64");
      }
      var host = opts.host;
      if (!isDefaultPort(opts.port, opts.secureEndpoint)) {
        host += ":" + opts.port;
      }
      headers["Host"] = host;
      headers["Connection"] = "close";
      Object.keys(headers).forEach(function(name) {
        msg += name + ": " + headers[name] + "\r\n";
      });
      socket.write(msg + "\r\n");
    };
    function resume(socket) {
      socket.resume();
    }
    function isDefaultPort(port, secure) {
      return Boolean(!secure && port === 80 || secure && port === 443);
    }
  }
});

// node_modules/proxy-from-env/index.js
var require_proxy_from_env = __commonJS({
  "node_modules/proxy-from-env/index.js"(exports) {
    "use strict";
    var parseUrl = require("url").parse;
    var DEFAULT_PORTS = {
      ftp: 21,
      gopher: 70,
      http: 80,
      https: 443,
      ws: 80,
      wss: 443
    };
    var stringEndsWith = String.prototype.endsWith || function(s) {
      return s.length <= this.length && this.indexOf(s, this.length - s.length) !== -1;
    };
    function getProxyForUrl(url) {
      var parsedUrl = typeof url === "string" ? parseUrl(url) : url || {};
      var proto = parsedUrl.protocol;
      var hostname = parsedUrl.host;
      var port = parsedUrl.port;
      if (typeof hostname !== "string" || !hostname || typeof proto !== "string") {
        return "";
      }
      proto = proto.split(":", 1)[0];
      hostname = hostname.replace(/:\d*$/, "");
      port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
      if (!shouldProxy(hostname, port)) {
        return "";
      }
      var proxy = getEnv("npm_config_" + proto + "_proxy") || getEnv(proto + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
      if (proxy && proxy.indexOf("://") === -1) {
        proxy = proto + "://" + proxy;
      }
      return proxy;
    }
    function shouldProxy(hostname, port) {
      var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
      if (!NO_PROXY) {
        return true;
      }
      if (NO_PROXY === "*") {
        return false;
      }
      return NO_PROXY.split(/[,\s]/).every(function(proxy) {
        if (!proxy) {
          return true;
        }
        var parsedProxy = proxy.match(/^(.+):(\d+)$/);
        var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
        var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
        if (parsedProxyPort && parsedProxyPort !== port) {
          return true;
        }
        if (!/^[.*]/.test(parsedProxyHostname)) {
          return hostname !== parsedProxyHostname;
        }
        if (parsedProxyHostname.charAt(0) === "*") {
          parsedProxyHostname = parsedProxyHostname.slice(1);
        }
        return !stringEndsWith.call(hostname, parsedProxyHostname);
      });
    }
    function getEnv(key) {
      return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
    }
    exports.getProxyForUrl = getProxyForUrl;
  }
});

// node_modules/puppeteer/lib/BrowserFetcher.js
var require_BrowserFetcher = __commonJS({
  "node_modules/puppeteer/lib/BrowserFetcher.js"(exports, module2) {
    var os = require("os");
    var fs = require("fs");
    var path = require("path");
    var extract = require_extract_zip();
    var util = require("util");
    var URL = require("url");
    var { helper, assert } = require_helper();
    var removeRecursive = require_rimraf();
    var ProxyAgent = require_https_proxy_agent();
    var getProxyForUrl = require_proxy_from_env().getProxyForUrl;
    var DEFAULT_DOWNLOAD_HOST = "https://storage.googleapis.com";
    var supportedPlatforms = ["mac", "linux", "win32", "win64"];
    var downloadURLs = {
      linux: "%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip",
      mac: "%s/chromium-browser-snapshots/Mac/%d/%s.zip",
      win32: "%s/chromium-browser-snapshots/Win/%d/%s.zip",
      win64: "%s/chromium-browser-snapshots/Win_x64/%d/%s.zip"
    };
    function archiveName(platform, revision) {
      if (platform === "linux")
        return "chrome-linux";
      if (platform === "mac")
        return "chrome-mac";
      if (platform === "win32" || platform === "win64") {
        return parseInt(revision, 10) > 591479 ? "chrome-win" : "chrome-win32";
      }
      return null;
    }
    function downloadURL(platform, host, revision) {
      return util.format(downloadURLs[platform], host, revision, archiveName(platform, revision));
    }
    var readdirAsync = helper.promisify(fs.readdir.bind(fs));
    var mkdirAsync = helper.promisify(fs.mkdir.bind(fs));
    var unlinkAsync = helper.promisify(fs.unlink.bind(fs));
    var chmodAsync = helper.promisify(fs.chmod.bind(fs));
    function existsAsync(filePath) {
      let fulfill = null;
      const promise = new Promise((x) => fulfill = x);
      fs.access(filePath, (err) => fulfill(!err));
      return promise;
    }
    var BrowserFetcher = class {
      constructor(projectRoot, options = {}) {
        this._downloadsFolder = options.path || path.join(projectRoot, ".local-chromium");
        this._downloadHost = options.host || DEFAULT_DOWNLOAD_HOST;
        this._platform = options.platform || "";
        if (!this._platform) {
          const platform = os.platform();
          if (platform === "darwin")
            this._platform = "mac";
          else if (platform === "linux")
            this._platform = "linux";
          else if (platform === "win32")
            this._platform = os.arch() === "x64" ? "win64" : "win32";
          assert(this._platform, "Unsupported platform: " + os.platform());
        }
        assert(supportedPlatforms.includes(this._platform), "Unsupported platform: " + this._platform);
      }
      platform() {
        return this._platform;
      }
      canDownload(revision) {
        const url = downloadURL(this._platform, this._downloadHost, revision);
        let resolve;
        const promise = new Promise((x) => resolve = x);
        const request = httpRequest(url, "HEAD", (response) => {
          resolve(response.statusCode === 200);
        });
        request.on("error", (error) => {
          console.error(error);
          resolve(false);
        });
        return promise;
      }
      async download(revision, progressCallback) {
        const url = downloadURL(this._platform, this._downloadHost, revision);
        const zipPath = path.join(this._downloadsFolder, `download-${this._platform}-${revision}.zip`);
        const folderPath = this._getFolderPath(revision);
        if (await existsAsync(folderPath))
          return this.revisionInfo(revision);
        if (!await existsAsync(this._downloadsFolder))
          await mkdirAsync(this._downloadsFolder);
        try {
          await downloadFile(url, zipPath, progressCallback);
          await extractZip(zipPath, folderPath);
        } finally {
          if (await existsAsync(zipPath))
            await unlinkAsync(zipPath);
        }
        const revisionInfo = this.revisionInfo(revision);
        if (revisionInfo)
          await chmodAsync(revisionInfo.executablePath, 493);
        return revisionInfo;
      }
      async localRevisions() {
        if (!await existsAsync(this._downloadsFolder))
          return [];
        const fileNames = await readdirAsync(this._downloadsFolder);
        return fileNames.map((fileName) => parseFolderPath(fileName)).filter((entry) => entry && entry.platform === this._platform).map((entry) => entry.revision);
      }
      async remove(revision) {
        const folderPath = this._getFolderPath(revision);
        assert(await existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);
        await new Promise((fulfill) => removeRecursive(folderPath, fulfill));
      }
      revisionInfo(revision) {
        const folderPath = this._getFolderPath(revision);
        let executablePath = "";
        if (this._platform === "mac")
          executablePath = path.join(folderPath, archiveName(this._platform, revision), "Chromium.app", "Contents", "MacOS", "Chromium");
        else if (this._platform === "linux")
          executablePath = path.join(folderPath, archiveName(this._platform, revision), "chrome");
        else if (this._platform === "win32" || this._platform === "win64")
          executablePath = path.join(folderPath, archiveName(this._platform, revision), "chrome.exe");
        else
          throw new Error("Unsupported platform: " + this._platform);
        const url = downloadURL(this._platform, this._downloadHost, revision);
        const local = fs.existsSync(folderPath);
        return { revision, executablePath, folderPath, local, url };
      }
      _getFolderPath(revision) {
        return path.join(this._downloadsFolder, this._platform + "-" + revision);
      }
    };
    module2.exports = BrowserFetcher;
    function parseFolderPath(folderPath) {
      const name = path.basename(folderPath);
      const splits = name.split("-");
      if (splits.length !== 2)
        return null;
      const [platform, revision] = splits;
      if (!supportedPlatforms.includes(platform))
        return null;
      return { platform, revision };
    }
    function downloadFile(url, destinationPath, progressCallback) {
      let fulfill, reject;
      let downloadedBytes = 0;
      let totalBytes = 0;
      const promise = new Promise((x, y) => {
        fulfill = x;
        reject = y;
      });
      const request = httpRequest(url, "GET", (response) => {
        if (response.statusCode !== 200) {
          const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
          response.resume();
          reject(error);
          return;
        }
        const file = fs.createWriteStream(destinationPath);
        file.on("finish", () => fulfill());
        file.on("error", (error) => reject(error));
        response.pipe(file);
        totalBytes = parseInt(response.headers["content-length"], 10);
        if (progressCallback)
          response.on("data", onData);
      });
      request.on("error", (error) => reject(error));
      return promise;
      function onData(chunk) {
        downloadedBytes += chunk.length;
        progressCallback(downloadedBytes, totalBytes);
      }
    }
    function extractZip(zipPath, folderPath) {
      return new Promise((fulfill, reject) => extract(zipPath, { dir: folderPath }, (err) => {
        if (err)
          reject(err);
        else
          fulfill();
      }));
    }
    function httpRequest(url, method, response) {
      const options = URL.parse(url);
      options.method = method;
      const proxyURL = getProxyForUrl(url);
      if (proxyURL) {
        const parsedProxyURL = URL.parse(proxyURL);
        parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
        options.agent = new ProxyAgent(parsedProxyURL);
        options.rejectUnauthorized = false;
      }
      const requestCallback = (res) => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)
          httpRequest(res.headers.location, method, response);
        else
          response(res);
      };
      const request = options.protocol === "https:" ? require("https").request(options, requestCallback) : require("http").request(options, requestCallback);
      request.end();
      return request;
    }
  }
});

// node_modules/async-limiter/index.js
var require_async_limiter = __commonJS({
  "node_modules/async-limiter/index.js"(exports, module2) {
    "use strict";
    function Queue(options) {
      if (!(this instanceof Queue)) {
        return new Queue(options);
      }
      options = options || {};
      this.concurrency = options.concurrency || Infinity;
      this.pending = 0;
      this.jobs = [];
      this.cbs = [];
      this._done = done.bind(this);
    }
    var arrayAddMethods = [
      "push",
      "unshift",
      "splice"
    ];
    arrayAddMethods.forEach(function(method) {
      Queue.prototype[method] = function() {
        var methodResult = Array.prototype[method].apply(this.jobs, arguments);
        this._run();
        return methodResult;
      };
    });
    Object.defineProperty(Queue.prototype, "length", {
      get: function() {
        return this.pending + this.jobs.length;
      }
    });
    Queue.prototype._run = function() {
      if (this.pending === this.concurrency) {
        return;
      }
      if (this.jobs.length) {
        var job = this.jobs.shift();
        this.pending++;
        job(this._done);
        this._run();
      }
      if (this.pending === 0) {
        while (this.cbs.length !== 0) {
          var cb = this.cbs.pop();
          process.nextTick(cb);
        }
      }
    };
    Queue.prototype.onDone = function(cb) {
      if (typeof cb === "function") {
        this.cbs.push(cb);
        this._run();
      }
    };
    function done() {
      this.pending--;
      this._run();
    }
    module2.exports = Queue;
  }
});

// node_modules/puppeteer/node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/constants.js"(exports, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: ["nodebuffer", "arraybuffer", "fragments"],
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      EMPTY_BUFFER: Buffer.alloc(0),
      NOOP: () => {
      }
    };
  }
});

// node_modules/puppeteer/node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/buffer-util.js"(exports, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    function concat(list, totalLength) {
      if (list.length === 0)
        return EMPTY_BUFFER;
      if (list.length === 1)
        return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      var offset = 0;
      for (var i = 0; i < list.length; i++) {
        const buf = list[i];
        buf.copy(target, offset);
        offset += buf.length;
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (var i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      const length = buffer.length;
      for (var i = 0; i < length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.byteLength === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data))
        return data;
      var buf;
      if (data instanceof ArrayBuffer) {
        buf = Buffer.from(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = viewToBuffer(data);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    function viewToBuffer(view) {
      const buf = Buffer.from(view.buffer);
      if (view.byteLength !== view.buffer.byteLength) {
        return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);
      }
      return buf;
    }
    try {
      const bufferUtil = require("bufferutil");
      const bu = bufferUtil.BufferUtil || bufferUtil;
      module2.exports = {
        concat,
        mask(source, mask, output, offset, length) {
          if (length < 48)
            _mask(source, mask, output, offset, length);
          else
            bu.mask(source, mask, output, offset, length);
        },
        toArrayBuffer,
        toBuffer,
        unmask(buffer, mask) {
          if (buffer.length < 32)
            _unmask(buffer, mask);
          else
            bu.unmask(buffer, mask);
        }
      };
    } catch (e) {
      module2.exports = {
        concat,
        mask: _mask,
        toArrayBuffer,
        toBuffer,
        unmask: _unmask
      };
    }
  }
});

// node_modules/puppeteer/node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/permessage-deflate.js"(exports, module2) {
    "use strict";
    var Limiter = require_async_limiter();
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var { kStatusCode, NOOP } = require_constants();
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var EMPTY_BLOCK = Buffer.from([0]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter({ concurrency });
        }
      }
      static get extensionName() {
        return "permessage-deflate";
      }
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          this._deflate.close();
          this._deflate = null;
        }
      }
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params;
      }
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            var value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      decompress(data, fin, callback) {
        zlibLimiter.push((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      compress(data, fin, callback) {
        zlibLimiter.push((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw(Object.assign({}, this._options.zlibInflateOptions, { windowBits }));
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin)
          this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
          }
          callback(null, data2);
        });
      }
      _compress(data, fin, callback) {
        if (!data || data.length === 0) {
          process.nextTick(callback, null, EMPTY_BLOCK);
          return;
        }
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw(Object.assign({}, this._options.zlibDeflateOptions, { windowBits }));
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("error", NOOP);
          this._deflate.on("data", deflateOnData);
        }
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          var data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin)
            data2 = data2.slice(0, data2.length - 4);
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.close();
            this._deflate = null;
          } else {
            this._deflate[kTotalLength] = 0;
            this._deflate[kBuffers] = [];
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/puppeteer/node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/event-target.js"(exports, module2) {
    "use strict";
    var Event2 = class {
      constructor(type, target) {
        this.target = target;
        this.type = type;
      }
    };
    var MessageEvent = class extends Event2 {
      constructor(data, target) {
        super("message", target);
        this.data = data;
      }
    };
    var CloseEvent = class extends Event2 {
      constructor(code, reason, target) {
        super("close", target);
        this.wasClean = target._closeFrameReceived && target._closeFrameSent;
        this.reason = reason;
        this.code = code;
      }
    };
    var OpenEvent = class extends Event2 {
      constructor(target) {
        super("open", target);
      }
    };
    var ErrorEvent = class extends Event2 {
      constructor(error, target) {
        super("error", target);
        this.message = error.message;
        this.error = error;
      }
    };
    var EventTarget = {
      addEventListener(method, listener) {
        if (typeof listener !== "function")
          return;
        function onMessage(data) {
          listener.call(this, new MessageEvent(data, this));
        }
        function onClose(code, message) {
          listener.call(this, new CloseEvent(code, message, this));
        }
        function onError(error) {
          listener.call(this, new ErrorEvent(error, this));
        }
        function onOpen() {
          listener.call(this, new OpenEvent(this));
        }
        if (method === "message") {
          onMessage._listener = listener;
          this.on(method, onMessage);
        } else if (method === "close") {
          onClose._listener = listener;
          this.on(method, onClose);
        } else if (method === "error") {
          onError._listener = listener;
          this.on(method, onError);
        } else if (method === "open") {
          onOpen._listener = listener;
          this.on(method, onOpen);
        } else {
          this.on(method, listener);
        }
      },
      removeEventListener(method, listener) {
        const listeners = this.listeners(method);
        for (var i = 0; i < listeners.length; i++) {
          if (listeners[i] === listener || listeners[i]._listener === listener) {
            this.removeListener(method, listeners[i]);
          }
        }
      }
    };
    module2.exports = EventTarget;
  }
});

// node_modules/puppeteer/node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/extension.js"(exports, module2) {
    "use strict";
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
    ];
    function push(dest, name, elem) {
      if (Object.prototype.hasOwnProperty.call(dest, name))
        dest[name].push(elem);
      else
        dest[name] = [elem];
    }
    function parse(header) {
      const offers = {};
      if (header === void 0 || header === "")
        return offers;
      var params = {};
      var mustUnescape = false;
      var isEscaping = false;
      var inQuotes = false;
      var extensionName;
      var paramName;
      var start = -1;
      var end = -1;
      for (var i = 0; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = {};
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = {};
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1)
              start = i;
            else if (!mustUnescape)
              mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1)
                start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1)
              start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1)
              end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1)
              end = i;
            var value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = {};
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1)
        end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, {});
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        var configurations = extensions[extension];
        if (!Array.isArray(configurations))
          configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(Object.keys(params).map((k) => {
            var values = params[k];
            if (!Array.isArray(values))
              values = [values];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse };
  }
});

// node_modules/puppeteer/node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/validation.js"(exports) {
    "use strict";
    try {
      const isValidUTF8 = require("utf-8-validate");
      exports.isValidUTF8 = typeof isValidUTF8 === "object" ? isValidUTF8.Validation.isValidUTF8 : isValidUTF8;
    } catch (e) {
      exports.isValidUTF8 = () => true;
    }
    exports.isValidStatusCode = (code) => {
      return code >= 1e3 && code <= 1013 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    };
  }
});

// node_modules/puppeteer/node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/receiver.js"(exports, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var Receiver = class extends Writable {
      constructor(binaryType, extensions, maxPayload) {
        super();
        this._binaryType = binaryType || BINARY_TYPES[0];
        this[kWebSocket] = void 0;
        this._extensions = extensions || {};
        this._maxPayload = maxPayload | 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._state = GET_INFO;
        this._loop = false;
      }
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO)
          return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length)
          return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = buf.slice(n);
          return buf.slice(0, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          if (n >= buf.length) {
            this._buffers.shift().copy(dst, dst.length - n);
          } else {
            buf.copy(dst, dst.length - n, 0, n);
            this._buffers[0] = buf.slice(n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      startLoop(cb) {
        var err;
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              err = this.getInfo();
              break;
            case GET_PAYLOAD_LENGTH_16:
              err = this.getPayloadLength16();
              break;
            case GET_PAYLOAD_LENGTH_64:
              err = this.getPayloadLength64();
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              err = this.getData(cb);
              break;
            default:
              this._loop = false;
              return;
          }
        } while (this._loop);
        cb(err);
      }
      getInfo() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          this._loop = false;
          return error(RangeError, "RSV2 and RSV3 must be clear", true, 1002);
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          this._loop = false;
          return error(RangeError, "RSV1 must be clear", true, 1002);
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (!this._fragmented) {
            this._loop = false;
            return error(RangeError, "invalid opcode 0", true, 1002);
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            this._loop = false;
            return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            this._loop = false;
            return error(RangeError, "FIN must be set", true, 1002);
          }
          if (compressed) {
            this._loop = false;
            return error(RangeError, "RSV1 must be clear", true, 1002);
          }
          if (this._payloadLength > 125) {
            this._loop = false;
            return error(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002);
          }
        } else {
          this._loop = false;
          return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);
        }
        if (!this._fin && !this._fragmented)
          this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._payloadLength === 126)
          this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127)
          this._state = GET_PAYLOAD_LENGTH_64;
        else
          return this.haveLength();
      }
      getPayloadLength16() {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        return this.haveLength();
      }
      getPayloadLength64() {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          this._loop = false;
          return error(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009);
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        return this.haveLength();
      }
      haveLength() {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            this._loop = false;
            return error(RangeError, "Max payload size exceeded", false, 1009);
          }
        }
        if (this._masked)
          this._state = GET_MASK;
        else
          this._state = GET_DATA;
      }
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      getData(cb) {
        var data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked)
            unmask(data, this._mask);
        }
        if (this._opcode > 7)
          return this.controlMessage(data);
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        return this.dataMessage();
      }
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err)
            return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              return cb(error(RangeError, "Max payload size exceeded", false, 1009));
            }
            this._fragments.push(buf);
          }
          const er = this.dataMessage();
          if (er)
            return cb(er);
          this.startLoop(cb);
        });
      }
      dataMessage() {
        if (this._fin) {
          const messageLength = this._messageLength;
          const fragments = this._fragments;
          this._totalPayloadLength = 0;
          this._messageLength = 0;
          this._fragmented = 0;
          this._fragments = [];
          if (this._opcode === 2) {
            var data;
            if (this._binaryType === "nodebuffer") {
              data = concat(fragments, messageLength);
            } else if (this._binaryType === "arraybuffer") {
              data = toArrayBuffer(concat(fragments, messageLength));
            } else {
              data = fragments;
            }
            this.emit("message", data);
          } else {
            const buf = concat(fragments, messageLength);
            if (!isValidUTF8(buf)) {
              this._loop = false;
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("message", buf.toString());
          }
        }
        this._state = GET_INFO;
      }
      controlMessage(data) {
        if (this._opcode === 8) {
          this._loop = false;
          if (data.length === 0) {
            this.emit("conclude", 1005, "");
            this.end();
          } else if (data.length === 1) {
            return error(RangeError, "invalid payload length 1", true, 1002);
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              return error(RangeError, `invalid status code ${code}`, true, 1002);
            }
            const buf = data.slice(2);
            if (!isValidUTF8(buf)) {
              return error(Error, "invalid UTF-8 sequence", true, 1007);
            }
            this.emit("conclude", code, buf.toString());
            this.end();
          }
        } else if (this._opcode === 9) {
          this.emit("ping", data);
        } else {
          this.emit("pong", data);
        }
        this._state = GET_INFO;
      }
    };
    module2.exports = Receiver;
    function error(ErrorCtor, message, prefix, statusCode) {
      const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
      Error.captureStackTrace(err, error);
      err[kStatusCode] = statusCode;
      return err;
    }
  }
});

// node_modules/puppeteer/node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/sender.js"(exports, module2) {
    "use strict";
    var { randomBytes } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var Sender = class {
      constructor(socket, extensions) {
        this._extensions = extensions || {};
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      static frame(data, options) {
        const merge = options.mask && options.readOnly;
        var offset = options.mask ? 6 : 2;
        var payloadLength = data.length;
        if (data.length >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (data.length > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1)
          target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(data.length, 2);
        } else if (payloadLength === 127) {
          target.writeUInt32BE(0, 2);
          target.writeUInt32BE(data.length, 6);
        }
        if (!options.mask)
          return [target, data];
        const mask = randomBytes(4);
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (merge) {
          applyMask(data, mask, target, offset, data.length);
          return [target];
        }
        applyMask(data, mask, data, 0, data.length);
        return [target, data];
      }
      close(code, data, mask, cb) {
        var buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || data === "") {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));
          buf.writeUInt16BE(code, 0);
          buf.write(data, 2);
        }
        if (this._deflating) {
          this.enqueue([this.doClose, buf, mask, cb]);
        } else {
          this.doClose(buf, mask, cb);
        }
      }
      doClose(data, mask, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 8,
          mask,
          readOnly: false
        }), cb);
      }
      ping(data, mask, cb) {
        const buf = toBuffer(data);
        if (this._deflating) {
          this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
        } else {
          this.doPing(buf, mask, toBuffer.readOnly, cb);
        }
      }
      doPing(data, mask, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 9,
          mask,
          readOnly
        }), cb);
      }
      pong(data, mask, cb) {
        const buf = toBuffer(data);
        if (this._deflating) {
          this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
        } else {
          this.doPong(buf, mask, toBuffer.readOnly, cb);
        }
      }
      doPong(data, mask, readOnly, cb) {
        this.sendFrame(Sender.frame(data, {
          fin: true,
          rsv1: false,
          opcode: 10,
          mask,
          readOnly
        }), cb);
      }
      send(data, options, cb) {
        const buf = toBuffer(data);
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        var opcode = options.binary ? 2 : 1;
        var rsv1 = options.compress;
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate) {
            rsv1 = buf.length >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin)
          this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            fin: options.fin,
            rsv1,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          };
          if (this._deflating) {
            this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
          } else {
            this.dispatch(buf, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender.frame(buf, {
            fin: options.fin,
            rsv1: false,
            opcode,
            mask: options.mask,
            readOnly: toBuffer.readOnly
          }), cb);
        }
      }
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[1].length;
          params[0].apply(this, params.slice(1));
        }
      }
      enqueue(params) {
        this._bufferedBytes += params[1].length;
        this._queue.push(params);
      }
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender;
  }
});

// node_modules/puppeteer/node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/websocket.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var crypto = require("crypto");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var url = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var EventTarget = require_event_target();
    var extension = require_extension();
    var Receiver = require_receiver();
    var Sender = require_sender();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var protocolVersions = [8, 13];
    var closeTimeout = 30 * 1e3;
    var WebSocket = class extends EventEmitter {
      constructor(address, protocols, options) {
        super();
        this.readyState = WebSocket.CONNECTING;
        this.protocol = "";
        this._binaryType = BINARY_TYPES[0];
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = "";
        this._closeTimer = null;
        this._closeCode = 1006;
        this._extensions = {};
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._isServer = false;
          this._redirects = 0;
          if (Array.isArray(protocols)) {
            protocols = protocols.join(", ");
          } else if (typeof protocols === "object" && protocols !== null) {
            options = protocols;
            protocols = void 0;
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._isServer = true;
        }
      }
      get CONNECTING() {
        return WebSocket.CONNECTING;
      }
      get CLOSING() {
        return WebSocket.CLOSING;
      }
      get CLOSED() {
        return WebSocket.CLOSED;
      }
      get OPEN() {
        return WebSocket.OPEN;
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type))
          return;
        this._binaryType = type;
        if (this._receiver)
          this._receiver._binaryType = type;
      }
      get bufferedAmount() {
        if (!this._socket)
          return 0;
        return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;
      }
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      setSocket(socket, head, maxPayload) {
        const receiver = new Receiver(this._binaryType, this._extensions, maxPayload);
        this._sender = new Sender(socket, this._extensions);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        socket.setTimeout(0);
        socket.setNoDelay();
        if (head.length > 0)
          socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this.readyState = WebSocket.OPEN;
        this.emit("open");
      }
      emitClose() {
        this.readyState = WebSocket.CLOSED;
        if (!this._socket) {
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this.emit("close", this._closeCode, this._closeMessage);
      }
      close(code, data) {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this.readyState === WebSocket.CLOSING) {
          if (this._closeFrameSent && this._closeFrameReceived)
            this._socket.end();
          return;
        }
        this.readyState = WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err)
            return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived)
            this._socket.end();
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      ping(data, mask, cb) {
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      pong(data, mask, cb) {
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        if (mask === void 0)
          mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      send(data, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (this.readyState !== WebSocket.OPEN) {
          const err = new Error(`WebSocket is not open: readyState ${this.readyState} (${readyStates[this.readyState]})`);
          if (cb)
            return cb(err);
          throw err;
        }
        if (typeof data === "number")
          data = data.toString();
        const opts = Object.assign({
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true
        }, options);
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      terminate() {
        if (this.readyState === WebSocket.CLOSED)
          return;
        if (this.readyState === WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          return abortHandshake(this, this._req, msg);
        }
        if (this._socket) {
          this.readyState = WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    readyStates.forEach((readyState, i) => {
      WebSocket[readyState] = i;
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket.prototype, `on${method}`, {
        get() {
          const listeners = this.listeners(method);
          for (var i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              return listeners[i]._listener;
          }
          return void 0;
        },
        set(listener) {
          const listeners = this.listeners(method);
          for (var i = 0; i < listeners.length; i++) {
            if (listeners[i]._listener)
              this.removeListener(method, listeners[i]);
          }
          this.addEventListener(method, listener);
        }
      });
    });
    WebSocket.prototype.addEventListener = EventTarget.addEventListener;
    WebSocket.prototype.removeEventListener = EventTarget.removeEventListener;
    module2.exports = WebSocket;
    function initAsClient(websocket, address, protocols, options) {
      const opts = Object.assign({
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10
      }, options, {
        createConnection: void 0,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: void 0,
        auth: void 0,
        host: void 0,
        path: void 0,
        port: void 0
      });
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      var parsedUrl;
      if (typeof address === "object" && address.href !== void 0) {
        parsedUrl = address;
        websocket.url = address.href;
      } else {
        parsedUrl = url.URL ? new url.URL(address) : url.parse(address);
        websocket.url = address;
      }
      const isUnixSocket = parsedUrl.protocol === "ws+unix:";
      if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {
        throw new Error(`Invalid URL: ${websocket.url}`);
      }
      const isSecure = parsedUrl.protocol === "wss:" || parsedUrl.protocol === "https:";
      const defaultPort = isSecure ? 443 : 80;
      const key = crypto.randomBytes(16).toString("base64");
      const get = isSecure ? https.get : http.get;
      const path = parsedUrl.search ? `${parsedUrl.pathname || "/"}${parsedUrl.search}` : parsedUrl.pathname || "/";
      var perMessageDeflate;
      opts.createConnection = isSecure ? tlsConnect : netConnect;
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = Object.assign({
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      }, opts.headers);
      opts.path = path;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = extension.format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols) {
        opts.headers["Sec-WebSocket-Protocol"] = protocols;
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.auth) {
        opts.auth = parsedUrl.auth;
      } else if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isUnixSocket) {
        const parts = path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      var req = websocket._req = get(opts);
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (websocket._req.aborted)
          return;
        req = websocket._req = null;
        websocket.readyState = WebSocket.CLOSING;
        websocket.emit("error", err);
        websocket.emitClose();
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          const addr = url.URL ? new url.URL(location, address) : url.resolve(address, location);
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket.CONNECTING)
          return;
        req = websocket._req = null;
        const digest = crypto.createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        const protList = (protocols || "").split(/, */);
        var protError;
        if (!protocols && serverProt) {
          protError = "Server sent a subprotocol but none was requested";
        } else if (protocols && !serverProt) {
          protError = "Server sent no subprotocol";
        } else if (serverProt && !protList.includes(serverProt)) {
          protError = "Server sent an invalid subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt)
          websocket.protocol = serverProt;
        if (perMessageDeflate) {
          try {
            const extensions = extension.parse(res.headers["sec-websocket-extensions"]);
            if (extensions[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
              websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Extensions header");
            return;
          }
        }
        websocket.setSocket(socket, head, opts.maxPayload);
      });
    }
    function netConnect(options) {
      if (options.protocolVersion)
        options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      options.servername = options.servername || options.host;
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket.readyState = WebSocket.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream.abort();
        stream.once("abort", websocket.emitClose.bind(websocket));
        websocket.emit("error", err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket._socket.resume();
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (code === 1005)
        websocket.close();
      else
        websocket.close(code, reason);
    }
    function receiverOnDrain() {
      this[kWebSocket]._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      websocket._socket.removeListener("data", socketOnData);
      websocket.readyState = WebSocket.CLOSING;
      websocket._closeCode = err[kStatusCode];
      websocket.emit("error", err);
      websocket._socket.destroy();
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data) {
      this[kWebSocket].emit("message", data);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      websocket.pong(data, !websocket._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("end", socketOnEnd);
      websocket.readyState = WebSocket.CLOSING;
      websocket._socket.read();
      websocket._receiver.end();
      this.removeListener("data", socketOnData);
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket.readyState = WebSocket.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      websocket.readyState = WebSocket.CLOSING;
      this.destroy();
    }
  }
});

// node_modules/puppeteer/node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/puppeteer/node_modules/ws/lib/websocket-server.js"(exports, module2) {
    "use strict";
    var EventEmitter = require("events");
    var crypto = require("crypto");
    var http = require("http");
    var PerMessageDeflate = require_permessage_deflate();
    var extension = require_extension();
    var WebSocket = require_websocket();
    var { GUID } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var WebSocketServer = class extends EventEmitter {
      constructor(options, callback) {
        super();
        options = Object.assign({
          maxPayload: 100 * 1024 * 1024,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null
        }, options);
        if (options.port == null && !options.server && !options.noServer) {
          throw new TypeError('One of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, (ws) => {
                this.emit("connection", ws, req);
              });
            }
          });
        }
        if (options.perMessageDeflate === true)
          options.perMessageDeflate = {};
        if (options.clientTracking)
          this.clients = new Set();
        this.options = options;
      }
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server)
          return null;
        return this._server.address();
      }
      close(cb) {
        if (cb)
          this.once("close", cb);
        if (this.clients) {
          for (const client of this.clients)
            client.terminate();
        }
        const server = this._server;
        if (server) {
          this._removeListeners();
          this._removeListeners = this._server = null;
          if (this.options.port != null) {
            server.close(() => this.emit("close"));
            return;
          }
        }
        process.nextTick(emitClose, this);
      }
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path)
            return false;
        }
        return true;
      }
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"] !== void 0 ? req.headers["sec-websocket-key"].trim() : false;
        const version = +req.headers["sec-websocket-version"];
        const extensions = {};
        if (req.method !== "GET" || req.headers.upgrade.toLowerCase() !== "websocket" || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
          return abortHandshake(socket, 400);
        }
        if (this.options.perMessageDeflate) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(req.headers["sec-websocket-extensions"]);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            return abortHandshake(socket, 400);
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.connection.authorized || req.connection.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(key, extensions, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info))
            return abortHandshake(socket, 401);
        }
        this.completeUpgrade(key, extensions, req, socket, head, cb);
      }
      completeUpgrade(key, extensions, req, socket, head, cb) {
        if (!socket.readable || !socket.writable)
          return socket.destroy();
        const digest = crypto.createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new WebSocket(null);
        var protocol = req.headers["sec-websocket-protocol"];
        if (protocol) {
          protocol = protocol.split(",").map(trim);
          if (this.options.handleProtocols) {
            protocol = this.options.handleProtocols(protocol, req);
          } else {
            protocol = protocol[0];
          }
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws.protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, this.options.maxPayload);
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => this.clients.delete(ws));
        }
        cb(ws);
      }
    };
    module2.exports = WebSocketServer;
    function addListeners(server, map) {
      for (const event of Object.keys(map))
        server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      if (socket.writable) {
        message = message || http.STATUS_CODES[code];
        headers = Object.assign({
          Connection: "close",
          "Content-type": "text/html",
          "Content-Length": Buffer.byteLength(message)
        }, headers);
        socket.write(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
      }
      socket.removeListener("error", socketOnError);
      socket.destroy();
    }
    function trim(str) {
      return str.trim();
    }
  }
});

// node_modules/puppeteer/node_modules/ws/index.js
var require_ws = __commonJS({
  "node_modules/puppeteer/node_modules/ws/index.js"(exports, module2) {
    "use strict";
    var WebSocket = require_websocket();
    WebSocket.Server = require_websocket_server();
    WebSocket.Receiver = require_receiver();
    WebSocket.Sender = require_sender();
    module2.exports = WebSocket;
  }
});

// node_modules/puppeteer/lib/WebSocketTransport.js
var require_WebSocketTransport = __commonJS({
  "node_modules/puppeteer/lib/WebSocketTransport.js"(exports, module2) {
    var WebSocket = require_ws();
    var WebSocketTransport = class {
      static create(url) {
        return new Promise((resolve, reject) => {
          const ws = new WebSocket(url, [], { perMessageDeflate: false });
          ws.addEventListener("open", () => resolve(new WebSocketTransport(ws)));
          ws.addEventListener("error", reject);
        });
      }
      constructor(ws) {
        this._ws = ws;
        this._ws.addEventListener("message", (event) => {
          if (this.onmessage)
            this.onmessage.call(null, event.data);
        });
        this._ws.addEventListener("close", (event) => {
          if (this.onclose)
            this.onclose.call(null);
        });
        this._ws.addEventListener("error", () => {
        });
        this.onmessage = null;
        this.onclose = null;
      }
      send(message) {
        this._ws.send(message);
      }
      close() {
        this._ws.close();
      }
    };
    module2.exports = WebSocketTransport;
  }
});

// node_modules/puppeteer/lib/PipeTransport.js
var require_PipeTransport = __commonJS({
  "node_modules/puppeteer/lib/PipeTransport.js"(exports, module2) {
    var { helper } = require_helper();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        this._pipeWrite = pipeWrite;
        this._pendingMessage = "";
        this._eventListeners = [
          helper.addEventListener(pipeRead, "data", (buffer) => this._dispatch(buffer)),
          helper.addEventListener(pipeRead, "close", () => {
            if (this.onclose)
              this.onclose.call(null);
          })
        ];
        this.onmessage = null;
        this.onclose = null;
      }
      send(message) {
        this._pipeWrite.write(message);
        this._pipeWrite.write("\0");
      }
      _dispatch(buffer) {
        let end = buffer.indexOf("\0");
        if (end === -1) {
          this._pendingMessage += buffer.toString();
          return;
        }
        const message = this._pendingMessage + buffer.toString(void 0, 0, end);
        if (this.onmessage)
          this.onmessage.call(null, message);
        let start = end + 1;
        end = buffer.indexOf("\0", start);
        while (end !== -1) {
          if (this.onmessage)
            this.onmessage.call(null, buffer.toString(void 0, start, end));
          start = end + 1;
          end = buffer.indexOf("\0", start);
        }
        this._pendingMessage = buffer.toString(void 0, start);
      }
      close() {
        this._pipeWrite = null;
        helper.removeEventListeners(this._eventListeners);
      }
    };
    module2.exports = PipeTransport;
  }
});

// node_modules/puppeteer/lib/Launcher.js
var require_Launcher = __commonJS({
  "node_modules/puppeteer/lib/Launcher.js"(exports, module2) {
    var os = require("os");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var URL = require("url");
    var removeFolder = require_rimraf();
    var childProcess = require("child_process");
    var BrowserFetcher = require_BrowserFetcher();
    var { Connection } = require_Connection();
    var { Browser } = require_Browser();
    var readline = require("readline");
    var fs = require("fs");
    var { helper, assert, debugError } = require_helper();
    var { TimeoutError } = require_Errors();
    var WebSocketTransport = require_WebSocketTransport();
    var PipeTransport = require_PipeTransport();
    var mkdtempAsync = helper.promisify(fs.mkdtemp);
    var removeFolderAsync = helper.promisify(removeFolder);
    var CHROME_PROFILE_PATH = path.join(os.tmpdir(), "puppeteer_dev_profile-");
    var DEFAULT_ARGS = [
      "--disable-background-networking",
      "--enable-features=NetworkService,NetworkServiceInProcess",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-features=site-per-process,TranslateUI,BlinkGenPropertyTrees",
      "--disable-hang-monitor",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-sync",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--enable-automation",
      "--password-store=basic",
      "--use-mock-keychain"
    ];
    var Launcher = class {
      constructor(projectRoot, preferredRevision, isPuppeteerCore) {
        this._projectRoot = projectRoot;
        this._preferredRevision = preferredRevision;
        this._isPuppeteerCore = isPuppeteerCore;
      }
      async launch(options = {}) {
        const {
          ignoreDefaultArgs = false,
          args = [],
          dumpio = false,
          executablePath = null,
          pipe = false,
          env = process.env,
          handleSIGINT = true,
          handleSIGTERM = true,
          handleSIGHUP = true,
          ignoreHTTPSErrors = false,
          defaultViewport = { width: 800, height: 600 },
          slowMo = 0,
          timeout = 3e4
        } = options;
        const chromeArguments = [];
        if (!ignoreDefaultArgs)
          chromeArguments.push(...this.defaultArgs(options));
        else if (Array.isArray(ignoreDefaultArgs))
          chromeArguments.push(...this.defaultArgs(options).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
        else
          chromeArguments.push(...args);
        let temporaryUserDataDir = null;
        if (!chromeArguments.some((argument) => argument.startsWith("--remote-debugging-")))
          chromeArguments.push(pipe ? "--remote-debugging-pipe" : "--remote-debugging-port=0");
        if (!chromeArguments.some((arg) => arg.startsWith("--user-data-dir"))) {
          temporaryUserDataDir = await mkdtempAsync(CHROME_PROFILE_PATH);
          chromeArguments.push(`--user-data-dir=${temporaryUserDataDir}`);
        }
        let chromeExecutable = executablePath;
        if (!executablePath) {
          const { missingText, executablePath: executablePath2 } = this._resolveExecutablePath();
          if (missingText)
            throw new Error(missingText);
          chromeExecutable = executablePath2;
        }
        const usePipe = chromeArguments.includes("--remote-debugging-pipe");
        const stdio = usePipe ? ["ignore", "ignore", "ignore", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
        const chromeProcess = childProcess.spawn(chromeExecutable, chromeArguments, {
          detached: process.platform !== "win32",
          env,
          stdio
        });
        if (dumpio) {
          chromeProcess.stderr.pipe(process.stderr);
          chromeProcess.stdout.pipe(process.stdout);
        }
        let chromeClosed = false;
        const waitForChromeToClose = new Promise((fulfill, reject) => {
          chromeProcess.once("exit", () => {
            chromeClosed = true;
            if (temporaryUserDataDir) {
              removeFolderAsync(temporaryUserDataDir).then(() => fulfill()).catch((err) => console.error(err));
            } else {
              fulfill();
            }
          });
        });
        const listeners = [helper.addEventListener(process, "exit", killChrome)];
        if (handleSIGINT)
          listeners.push(helper.addEventListener(process, "SIGINT", () => {
            killChrome();
            process.exit(130);
          }));
        if (handleSIGTERM)
          listeners.push(helper.addEventListener(process, "SIGTERM", gracefullyCloseChrome));
        if (handleSIGHUP)
          listeners.push(helper.addEventListener(process, "SIGHUP", gracefullyCloseChrome));
        let connection = null;
        try {
          if (!usePipe) {
            const browserWSEndpoint = await waitForWSEndpoint(chromeProcess, timeout, this._preferredRevision);
            const transport = await WebSocketTransport.create(browserWSEndpoint);
            connection = new Connection(browserWSEndpoint, transport, slowMo);
          } else {
            const transport = new PipeTransport(chromeProcess.stdio[3], chromeProcess.stdio[4]);
            connection = new Connection("", transport, slowMo);
          }
          const browser = await Browser.create(connection, [], ignoreHTTPSErrors, defaultViewport, chromeProcess, gracefullyCloseChrome);
          await browser.waitForTarget((t) => t.type() === "page");
          return browser;
        } catch (e) {
          killChrome();
          throw e;
        }
        function gracefullyCloseChrome() {
          helper.removeEventListeners(listeners);
          if (temporaryUserDataDir) {
            killChrome();
          } else if (connection) {
            connection.send("Browser.close").catch((error) => {
              debugError(error);
              killChrome();
            });
          }
          return waitForChromeToClose;
        }
        function killChrome() {
          helper.removeEventListeners(listeners);
          if (chromeProcess.pid && !chromeProcess.killed && !chromeClosed) {
            try {
              if (process.platform === "win32")
                childProcess.execSync(`taskkill /pid ${chromeProcess.pid} /T /F`);
              else
                process.kill(-chromeProcess.pid, "SIGKILL");
            } catch (e) {
            }
          }
          try {
            removeFolder.sync(temporaryUserDataDir);
          } catch (e) {
          }
        }
      }
      defaultArgs(options = {}) {
        const {
          devtools = false,
          headless = !devtools,
          args = [],
          userDataDir = null
        } = options;
        const chromeArguments = [...DEFAULT_ARGS];
        if (userDataDir)
          chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (devtools)
          chromeArguments.push("--auto-open-devtools-for-tabs");
        if (headless) {
          chromeArguments.push("--headless", "--hide-scrollbars", "--mute-audio");
          if (os.platform() === "win32")
            chromeArguments.push("--disable-gpu");
        }
        if (args.every((arg) => arg.startsWith("-")))
          chromeArguments.push("about:blank");
        chromeArguments.push(...args);
        return chromeArguments;
      }
      executablePath() {
        return this._resolveExecutablePath().executablePath;
      }
      async connect(options) {
        const {
          browserWSEndpoint,
          browserURL,
          ignoreHTTPSErrors = false,
          defaultViewport = { width: 800, height: 600 },
          transport,
          slowMo = 0
        } = options;
        assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
        let connection = null;
        if (transport) {
          connection = new Connection("", transport, slowMo);
        } else if (browserWSEndpoint) {
          const connectionTransport = await WebSocketTransport.create(browserWSEndpoint);
          connection = new Connection(browserWSEndpoint, connectionTransport, slowMo);
        } else if (browserURL) {
          const connectionURL = await getWSEndpoint(browserURL);
          const connectionTransport = await WebSocketTransport.create(connectionURL);
          connection = new Connection(connectionURL, connectionTransport, slowMo);
        }
        const { browserContextIds } = await connection.send("Target.getBrowserContexts");
        return Browser.create(connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, null, () => connection.send("Browser.close").catch(debugError));
      }
      _resolveExecutablePath() {
        const browserFetcher = new BrowserFetcher(this._projectRoot);
        if (!this._isPuppeteerCore) {
          const executablePath = process.env.PUPPETEER_EXECUTABLE_PATH || process.env.npm_config_puppeteer_executable_path || process.env.npm_package_config_puppeteer_executable_path;
          if (executablePath) {
            const missingText2 = !fs.existsSync(executablePath) ? "Tried to use PUPPETEER_EXECUTABLE_PATH env variable to launch browser but did not find any executable at: " + executablePath : null;
            return { executablePath, missingText: missingText2 };
          }
          const revision = process.env["PUPPETEER_CHROMIUM_REVISION"];
          if (revision) {
            const revisionInfo2 = browserFetcher.revisionInfo(revision);
            const missingText2 = !revisionInfo2.local ? "Tried to use PUPPETEER_CHROMIUM_REVISION env variable to launch browser but did not find executable at: " + revisionInfo2.executablePath : null;
            return { executablePath: revisionInfo2.executablePath, missingText: missingText2 };
          }
        }
        const revisionInfo = browserFetcher.revisionInfo(this._preferredRevision);
        const missingText = !revisionInfo.local ? `Chromium revision is not downloaded. Run "npm install" or "yarn install"` : null;
        return { executablePath: revisionInfo.executablePath, missingText };
      }
    };
    function waitForWSEndpoint(chromeProcess, timeout, preferredRevision) {
      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({ input: chromeProcess.stderr });
        let stderr = "";
        const listeners = [
          helper.addEventListener(rl, "line", onLine),
          helper.addEventListener(rl, "close", () => onClose()),
          helper.addEventListener(chromeProcess, "exit", () => onClose()),
          helper.addEventListener(chromeProcess, "error", (error) => onClose(error))
        ];
        const timeoutId = timeout ? setTimeout(onTimeout, timeout) : 0;
        function onClose(error) {
          cleanup();
          reject(new Error([
            "Failed to launch chrome!" + (error ? " " + error.message : ""),
            stderr,
            "",
            "TROUBLESHOOTING: https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md",
            ""
          ].join("\n")));
        }
        function onTimeout() {
          cleanup();
          reject(new TimeoutError(`Timed out after ${timeout} ms while trying to connect to Chrome! The only Chrome revision guaranteed to work is r${preferredRevision}`));
        }
        function onLine(line) {
          stderr += line + "\n";
          const match = line.match(/^DevTools listening on (ws:\/\/.*)$/);
          if (!match)
            return;
          cleanup();
          resolve(match[1]);
        }
        function cleanup() {
          if (timeoutId)
            clearTimeout(timeoutId);
          helper.removeEventListeners(listeners);
        }
      });
    }
    function getWSEndpoint(browserURL) {
      let resolve, reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      const endpointURL = URL.resolve(browserURL, "/json/version");
      const protocol = endpointURL.startsWith("https") ? https : http;
      const requestOptions = Object.assign(URL.parse(endpointURL), { method: "GET" });
      const request = protocol.request(requestOptions, (res) => {
        let data = "";
        if (res.statusCode !== 200) {
          res.resume();
          reject(new Error("HTTP " + res.statusCode));
          return;
        }
        res.setEncoding("utf8");
        res.on("data", (chunk) => data += chunk);
        res.on("end", () => resolve(JSON.parse(data).webSocketDebuggerUrl));
      });
      request.on("error", reject);
      request.end();
      return promise.catch((e) => {
        e.message = `Failed to fetch browser webSocket url from ${endpointURL}: ` + e.message;
        throw e;
      });
    }
    module2.exports = Launcher;
  }
});

// node_modules/puppeteer/lib/DeviceDescriptors.js
var require_DeviceDescriptors = __commonJS({
  "node_modules/puppeteer/lib/DeviceDescriptors.js"(exports, module2) {
    module2.exports = [
      {
        "name": "Blackberry PlayBook",
        "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        "viewport": {
          "width": 600,
          "height": 1024,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Blackberry PlayBook landscape",
        "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        "viewport": {
          "width": 1024,
          "height": 600,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "BlackBerry Z30",
        "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "BlackBerry Z30 landscape",
        "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy Note 3",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy Note 3 landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy Note II",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy Note II landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy S III",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy S III landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy S5",
        "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy S5 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPad",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 768,
          "height": 1024,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPad landscape",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 768,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPad Mini",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 768,
          "height": 1024,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPad Mini landscape",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 768,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPad Pro",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 1366,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPad Pro landscape",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1366,
          "height": 1024,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 4",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        "viewport": {
          "width": 320,
          "height": 480,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 4 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        "viewport": {
          "width": 480,
          "height": 320,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 5",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 320,
          "height": 568,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 5 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 568,
          "height": 320,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 6",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 6 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 6 Plus",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 6 Plus landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 7",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 7 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 7 Plus",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 7 Plus landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 8",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 8 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 8 Plus",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 8 Plus landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone SE",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 320,
          "height": 568,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone SE landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 568,
          "height": 320,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone X",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 812,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone X landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 812,
          "height": 375,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "JioPhone 2",
        "userAgent": "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        "viewport": {
          "width": 240,
          "height": 320,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "JioPhone 2 landscape",
        "userAgent": "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        "viewport": {
          "width": 320,
          "height": 240,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Kindle Fire HDX",
        "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        "viewport": {
          "width": 800,
          "height": 1280,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Kindle Fire HDX landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        "viewport": {
          "width": 1280,
          "height": 800,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "LG Optimus L70",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 384,
          "height": 640,
          "deviceScaleFactor": 1.25,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "LG Optimus L70 landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 384,
          "deviceScaleFactor": 1.25,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Microsoft Lumia 550",
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Microsoft Lumia 950",
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 4,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Microsoft Lumia 950 landscape",
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 4,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 10",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 800,
          "height": 1280,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 10 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 1280,
          "height": 800,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 4",
        "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 384,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 4 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 384,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 5",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 5 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 5X",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 5X landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 6",
        "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 6 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 6P",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 6P landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 7",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 600,
          "height": 960,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 7 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 960,
          "height": 600,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nokia Lumia 520",
        "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        "viewport": {
          "width": 320,
          "height": 533,
          "deviceScaleFactor": 1.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nokia Lumia 520 landscape",
        "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        "viewport": {
          "width": 533,
          "height": 320,
          "deviceScaleFactor": 1.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nokia N9",
        "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        "viewport": {
          "width": 480,
          "height": 854,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nokia N9 landscape",
        "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        "viewport": {
          "width": 854,
          "height": 480,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Pixel 2",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 411,
          "height": 731,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Pixel 2 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 731,
          "height": 411,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Pixel 2 XL",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 411,
          "height": 823,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Pixel 2 XL landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 823,
          "height": 411,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      }
    ];
    for (const device of module2.exports)
      module2.exports[device.name] = device;
  }
});

// node_modules/puppeteer/lib/Puppeteer.js
var require_Puppeteer = __commonJS({
  "node_modules/puppeteer/lib/Puppeteer.js"(exports, module2) {
    var Launcher = require_Launcher();
    var BrowserFetcher = require_BrowserFetcher();
    var Errors = require_Errors();
    var DeviceDescriptors = require_DeviceDescriptors();
    module2.exports = class {
      constructor(projectRoot, preferredRevision, isPuppeteerCore) {
        this._projectRoot = projectRoot;
        this._launcher = new Launcher(projectRoot, preferredRevision, isPuppeteerCore);
      }
      launch(options) {
        return this._launcher.launch(options);
      }
      connect(options) {
        return this._launcher.connect(options);
      }
      executablePath() {
        return this._launcher.executablePath();
      }
      get devices() {
        return DeviceDescriptors;
      }
      get errors() {
        return Errors;
      }
      defaultArgs(options) {
        return this._launcher.defaultArgs(options);
      }
      createBrowserFetcher(options) {
        return new BrowserFetcher(this._projectRoot, options);
      }
    };
  }
});

// node_modules/puppeteer/lib/api.js
var require_api = __commonJS({
  "node_modules/puppeteer/lib/api.js"(exports, module2) {
    module2.exports = {
      Accessibility: require_Accessibility().Accessibility,
      Browser: require_Browser().Browser,
      BrowserContext: require_Browser().BrowserContext,
      BrowserFetcher: require_BrowserFetcher(),
      CDPSession: require_Connection().CDPSession,
      ConsoleMessage: require_Page().ConsoleMessage,
      Coverage: require_Coverage().Coverage,
      Dialog: require_Dialog().Dialog,
      ElementHandle: require_JSHandle().ElementHandle,
      ExecutionContext: require_ExecutionContext().ExecutionContext,
      Frame: require_FrameManager().Frame,
      JSHandle: require_JSHandle().JSHandle,
      Keyboard: require_Input().Keyboard,
      Mouse: require_Input().Mouse,
      Page: require_Page().Page,
      Puppeteer: require_Puppeteer(),
      Request: require_NetworkManager().Request,
      Response: require_NetworkManager().Response,
      SecurityDetails: require_NetworkManager().SecurityDetails,
      Target: require_Target().Target,
      TimeoutError: require_Errors().TimeoutError,
      Touchscreen: require_Input().Touchscreen,
      Tracing: require_Tracing(),
      Worker: require_Worker().Worker
    };
  }
});

// node_modules/puppeteer/node6/lib/Errors.js
var require_Errors2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Errors.js"(exports, module2) {
    var CustomError = class extends Error {
      constructor(message) {
        super(message);
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
      }
    };
    var TimeoutError = class extends CustomError {
    };
    module2.exports = {
      TimeoutError
    };
  }
});

// node_modules/puppeteer/node6/lib/helper.js
var require_helper2 = __commonJS({
  "node_modules/puppeteer/node6/lib/helper.js"(exports, module2) {
    var { TimeoutError } = require_Errors2();
    var debugError = require_src()(`puppeteer:error`);
    var Helper = class {
      static evaluationString(fun, ...args) {
        if (Helper.isString(fun)) {
          assert(args.length === 0, "Cannot evaluate a string with arguments");
          return fun;
        }
        return `(${fun})(${args.map(serializeArgument).join(",")})`;
        function serializeArgument(arg) {
          if (Object.is(arg, void 0))
            return "undefined";
          return JSON.stringify(arg);
        }
      }
      static getExceptionMessage(exceptionDetails) {
        if (exceptionDetails.exception)
          return exceptionDetails.exception.description || exceptionDetails.exception.value;
        let message = exceptionDetails.text;
        if (exceptionDetails.stackTrace) {
          for (const callframe of exceptionDetails.stackTrace.callFrames) {
            const location = callframe.url + ":" + callframe.lineNumber + ":" + callframe.columnNumber;
            const functionName = callframe.functionName || "<anonymous>";
            message += `
    at ${functionName} (${location})`;
          }
        }
        return message;
      }
      static valueFromRemoteObject(remoteObject) {
        assert(!remoteObject.objectId, "Cannot extract value when objectId is given");
        if (remoteObject.unserializableValue) {
          if (remoteObject.type === "bigint" && typeof BigInt !== "undefined")
            return BigInt(remoteObject.unserializableValue.replace("n", ""));
          switch (remoteObject.unserializableValue) {
            case "-0":
              return -0;
            case "NaN":
              return NaN;
            case "Infinity":
              return Infinity;
            case "-Infinity":
              return -Infinity;
            default:
              throw new Error("Unsupported unserializable value: " + remoteObject.unserializableValue);
          }
        }
        return remoteObject.value;
      }
      static releaseObject(client, remoteObject) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (!remoteObject.objectId)
            return;
          yield client.send("Runtime.releaseObject", { objectId: remoteObject.objectId }).catch((error) => {
            debugError(error);
          });
        });
      }
      static installAsyncStackHooks(classType) {
        for (const methodName of Reflect.ownKeys(classType.prototype)) {
          const method = Reflect.get(classType.prototype, methodName);
          if (methodName === "constructor" || typeof methodName !== "string" || methodName.startsWith("_") || typeof method !== "function" || method.constructor.name !== "AsyncFunction")
            continue;
          Reflect.set(classType.prototype, methodName, function(...args) {
            const syncStack = new Error();
            return method.call(this, ...args).catch((e) => {
              const stack = syncStack.stack.substring(syncStack.stack.indexOf("\n") + 1);
              const clientStack = stack.substring(stack.indexOf("\n"));
              if (e instanceof Error && e.stack && !e.stack.includes(clientStack))
                e.stack += "\n  -- ASYNC --\n" + stack;
              throw e;
            });
          });
        }
      }
      static addEventListener(emitter, eventName, handler2) {
        emitter.on(eventName, handler2);
        return { emitter, eventName, handler: handler2 };
      }
      static removeEventListeners(listeners) {
        for (const listener of listeners)
          listener.emitter.removeListener(listener.eventName, listener.handler);
        listeners.splice(0, listeners.length);
      }
      static isString(obj) {
        return typeof obj === "string" || obj instanceof String;
      }
      static isNumber(obj) {
        return typeof obj === "number" || obj instanceof Number;
      }
      static promisify(nodeFunction) {
        function promisified(...args) {
          return new Promise((resolve, reject) => {
            function callback(err, ...result) {
              if (err)
                return reject(err);
              if (result.length === 1)
                return resolve(result[0]);
              return resolve(result);
            }
            nodeFunction.call(null, ...args, callback);
          });
        }
        return promisified;
      }
      static waitForEvent(emitter, eventName, predicate, timeout) {
        let eventTimeout, resolveCallback, rejectCallback;
        const promise = new Promise((resolve, reject) => {
          resolveCallback = resolve;
          rejectCallback = reject;
        });
        const listener = Helper.addEventListener(emitter, eventName, (event) => {
          if (!predicate(event))
            return;
          cleanup();
          resolveCallback(event);
        });
        if (timeout) {
          eventTimeout = setTimeout(() => {
            cleanup();
            rejectCallback(new TimeoutError("Timeout exceeded while waiting for event"));
          }, timeout);
        }
        function cleanup() {
          Helper.removeEventListeners([listener]);
          clearTimeout(eventTimeout);
        }
        return promise;
      }
      static waitWithTimeout(promise, taskName, timeout) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          let reject;
          const timeoutError = new TimeoutError(`waiting for ${taskName} failed: timeout ${timeout}ms exceeded`);
          const timeoutPromise = new Promise((resolve, x) => reject = x);
          const timeoutTimer = setTimeout(() => reject(timeoutError), timeout);
          try {
            return yield Promise.race([promise, timeoutPromise]);
          } finally {
            clearTimeout(timeoutTimer);
          }
        });
      }
    };
    function assert(value, message) {
      if (!value)
        throw new Error(message);
    }
    module2.exports = {
      helper: Helper,
      assert,
      debugError
    };
  }
});

// node_modules/puppeteer/node6/lib/BrowserFetcher.js
var require_BrowserFetcher2 = __commonJS({
  "node_modules/puppeteer/node6/lib/BrowserFetcher.js"(exports, module2) {
    var os = require("os");
    var fs = require("fs");
    var path = require("path");
    var extract = require_extract_zip();
    var util = require("util");
    var URL = require("url");
    var { helper, assert } = require_helper2();
    var removeRecursive = require_rimraf();
    var ProxyAgent = require_https_proxy_agent();
    var getProxyForUrl = require_proxy_from_env().getProxyForUrl;
    var DEFAULT_DOWNLOAD_HOST = "https://storage.googleapis.com";
    var supportedPlatforms = ["mac", "linux", "win32", "win64"];
    var downloadURLs = {
      linux: "%s/chromium-browser-snapshots/Linux_x64/%d/%s.zip",
      mac: "%s/chromium-browser-snapshots/Mac/%d/%s.zip",
      win32: "%s/chromium-browser-snapshots/Win/%d/%s.zip",
      win64: "%s/chromium-browser-snapshots/Win_x64/%d/%s.zip"
    };
    function archiveName(platform, revision) {
      if (platform === "linux")
        return "chrome-linux";
      if (platform === "mac")
        return "chrome-mac";
      if (platform === "win32" || platform === "win64") {
        return parseInt(revision, 10) > 591479 ? "chrome-win" : "chrome-win32";
      }
      return null;
    }
    function downloadURL(platform, host, revision) {
      return util.format(downloadURLs[platform], host, revision, archiveName(platform, revision));
    }
    var readdirAsync = helper.promisify(fs.readdir.bind(fs));
    var mkdirAsync = helper.promisify(fs.mkdir.bind(fs));
    var unlinkAsync = helper.promisify(fs.unlink.bind(fs));
    var chmodAsync = helper.promisify(fs.chmod.bind(fs));
    function existsAsync(filePath) {
      let fulfill = null;
      const promise = new Promise((x) => fulfill = x);
      fs.access(filePath, (err) => fulfill(!err));
      return promise;
    }
    var BrowserFetcher = class {
      constructor(projectRoot, options = {}) {
        this._downloadsFolder = options.path || path.join(projectRoot, ".local-chromium");
        this._downloadHost = options.host || DEFAULT_DOWNLOAD_HOST;
        this._platform = options.platform || "";
        if (!this._platform) {
          const platform = os.platform();
          if (platform === "darwin")
            this._platform = "mac";
          else if (platform === "linux")
            this._platform = "linux";
          else if (platform === "win32")
            this._platform = os.arch() === "x64" ? "win64" : "win32";
          assert(this._platform, "Unsupported platform: " + os.platform());
        }
        assert(supportedPlatforms.includes(this._platform), "Unsupported platform: " + this._platform);
      }
      platform() {
        return this._platform;
      }
      canDownload(revision) {
        const url = downloadURL(this._platform, this._downloadHost, revision);
        let resolve;
        const promise = new Promise((x) => resolve = x);
        const request = httpRequest(url, "HEAD", (response) => {
          resolve(response.statusCode === 200);
        });
        request.on("error", (error) => {
          console.error(error);
          resolve(false);
        });
        return promise;
      }
      download(revision, progressCallback) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const url = downloadURL(this._platform, this._downloadHost, revision);
          const zipPath = path.join(this._downloadsFolder, `download-${this._platform}-${revision}.zip`);
          const folderPath = this._getFolderPath(revision);
          if (yield existsAsync(folderPath))
            return this.revisionInfo(revision);
          if (!(yield existsAsync(this._downloadsFolder)))
            yield mkdirAsync(this._downloadsFolder);
          try {
            yield downloadFile(url, zipPath, progressCallback);
            yield extractZip(zipPath, folderPath);
          } finally {
            if (yield existsAsync(zipPath))
              yield unlinkAsync(zipPath);
          }
          const revisionInfo = this.revisionInfo(revision);
          if (revisionInfo)
            yield chmodAsync(revisionInfo.executablePath, 493);
          return revisionInfo;
        });
      }
      localRevisions() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (!(yield existsAsync(this._downloadsFolder)))
            return [];
          const fileNames = yield readdirAsync(this._downloadsFolder);
          return fileNames.map((fileName) => parseFolderPath(fileName)).filter((entry) => entry && entry.platform === this._platform).map((entry) => entry.revision);
        });
      }
      remove(revision) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const folderPath = this._getFolderPath(revision);
          assert(yield existsAsync(folderPath), `Failed to remove: revision ${revision} is not downloaded`);
          yield new Promise((fulfill) => removeRecursive(folderPath, fulfill));
        });
      }
      revisionInfo(revision) {
        const folderPath = this._getFolderPath(revision);
        let executablePath = "";
        if (this._platform === "mac")
          executablePath = path.join(folderPath, archiveName(this._platform, revision), "Chromium.app", "Contents", "MacOS", "Chromium");
        else if (this._platform === "linux")
          executablePath = path.join(folderPath, archiveName(this._platform, revision), "chrome");
        else if (this._platform === "win32" || this._platform === "win64")
          executablePath = path.join(folderPath, archiveName(this._platform, revision), "chrome.exe");
        else
          throw new Error("Unsupported platform: " + this._platform);
        const url = downloadURL(this._platform, this._downloadHost, revision);
        const local = fs.existsSync(folderPath);
        return { revision, executablePath, folderPath, local, url };
      }
      _getFolderPath(revision) {
        return path.join(this._downloadsFolder, this._platform + "-" + revision);
      }
    };
    module2.exports = BrowserFetcher;
    function parseFolderPath(folderPath) {
      const name = path.basename(folderPath);
      const splits = name.split("-");
      if (splits.length !== 2)
        return null;
      const [platform, revision] = splits;
      if (!supportedPlatforms.includes(platform))
        return null;
      return { platform, revision };
    }
    function downloadFile(url, destinationPath, progressCallback) {
      let fulfill, reject;
      let downloadedBytes = 0;
      let totalBytes = 0;
      const promise = new Promise((x, y) => {
        fulfill = x;
        reject = y;
      });
      const request = httpRequest(url, "GET", (response) => {
        if (response.statusCode !== 200) {
          const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);
          response.resume();
          reject(error);
          return;
        }
        const file = fs.createWriteStream(destinationPath);
        file.on("finish", () => fulfill());
        file.on("error", (error) => reject(error));
        response.pipe(file);
        totalBytes = parseInt(response.headers["content-length"], 10);
        if (progressCallback)
          response.on("data", onData);
      });
      request.on("error", (error) => reject(error));
      return promise;
      function onData(chunk) {
        downloadedBytes += chunk.length;
        progressCallback(downloadedBytes, totalBytes);
      }
    }
    function extractZip(zipPath, folderPath) {
      return new Promise((fulfill, reject) => extract(zipPath, { dir: folderPath }, (err) => {
        if (err)
          reject(err);
        else
          fulfill();
      }));
    }
    function httpRequest(url, method, response) {
      const options = URL.parse(url);
      options.method = method;
      const proxyURL = getProxyForUrl(url);
      if (proxyURL) {
        const parsedProxyURL = URL.parse(proxyURL);
        parsedProxyURL.secureProxy = parsedProxyURL.protocol === "https:";
        options.agent = new ProxyAgent(parsedProxyURL);
        options.rejectUnauthorized = false;
      }
      const requestCallback = (res) => {
        if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location)
          httpRequest(res.headers.location, method, response);
        else
          response(res);
      };
      const request = options.protocol === "https:" ? require("https").request(options, requestCallback) : require("http").request(options, requestCallback);
      request.end();
      return request;
    }
  }
});

// node_modules/puppeteer/node6/lib/Events.js
var require_Events2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Events.js"(exports, module2) {
    var Events = {
      Page: {
        Close: "close",
        Console: "console",
        Dialog: "dialog",
        DOMContentLoaded: "domcontentloaded",
        Error: "error",
        PageError: "pageerror",
        Request: "request",
        Response: "response",
        RequestFailed: "requestfailed",
        RequestFinished: "requestfinished",
        FrameAttached: "frameattached",
        FrameDetached: "framedetached",
        FrameNavigated: "framenavigated",
        Load: "load",
        Metrics: "metrics",
        Popup: "popup",
        WorkerCreated: "workercreated",
        WorkerDestroyed: "workerdestroyed"
      },
      Browser: {
        TargetCreated: "targetcreated",
        TargetDestroyed: "targetdestroyed",
        TargetChanged: "targetchanged",
        Disconnected: "disconnected"
      },
      BrowserContext: {
        TargetCreated: "targetcreated",
        TargetDestroyed: "targetdestroyed",
        TargetChanged: "targetchanged"
      },
      NetworkManager: {
        Request: Symbol("Events.NetworkManager.Request"),
        Response: Symbol("Events.NetworkManager.Response"),
        RequestFailed: Symbol("Events.NetworkManager.RequestFailed"),
        RequestFinished: Symbol("Events.NetworkManager.RequestFinished")
      },
      FrameManager: {
        FrameAttached: Symbol("Events.FrameManager.FrameAttached"),
        FrameNavigated: Symbol("Events.FrameManager.FrameNavigated"),
        FrameDetached: Symbol("Events.FrameManager.FrameDetached"),
        LifecycleEvent: Symbol("Events.FrameManager.LifecycleEvent"),
        FrameNavigatedWithinDocument: Symbol("Events.FrameManager.FrameNavigatedWithinDocument"),
        ExecutionContextCreated: Symbol("Events.FrameManager.ExecutionContextCreated"),
        ExecutionContextDestroyed: Symbol("Events.FrameManager.ExecutionContextDestroyed")
      },
      Connection: {
        Disconnected: Symbol("Events.Connection.Disconnected")
      },
      CDPSession: {
        Disconnected: Symbol("Events.CDPSession.Disconnected")
      }
    };
    module2.exports = { Events };
  }
});

// node_modules/puppeteer/node6/lib/Connection.js
var require_Connection2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Connection.js"(exports, module2) {
    var { assert } = require_helper2();
    var { Events } = require_Events2();
    var debugProtocol = require_src()("puppeteer:protocol");
    var EventEmitter = require("events");
    var Connection = class extends EventEmitter {
      constructor(url, transport, delay = 0) {
        super();
        this._url = url;
        this._lastId = 0;
        this._callbacks = new Map();
        this._delay = delay;
        this._transport = transport;
        this._transport.onmessage = this._onMessage.bind(this);
        this._transport.onclose = this._onClose.bind(this);
        this._sessions = new Map();
        this._closed = false;
      }
      static fromSession(session) {
        return session._connection;
      }
      session(sessionId) {
        return this._sessions.get(sessionId) || null;
      }
      url() {
        return this._url;
      }
      send(method, params = {}) {
        const id = this._rawSend({ method, params });
        return new Promise((resolve, reject) => {
          this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
      }
      _rawSend(message) {
        const id = ++this._lastId;
        message = JSON.stringify(Object.assign({}, message, { id }));
        debugProtocol("SEND \u25BA " + message);
        this._transport.send(message);
        return id;
      }
      _onMessage(message) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._delay)
            yield new Promise((f) => setTimeout(f, this._delay));
          debugProtocol("\u25C0 RECV " + message);
          const object = JSON.parse(message);
          if (object.method === "Target.attachedToTarget") {
            const sessionId = object.params.sessionId;
            const session = new CDPSession(this, object.params.targetInfo.type, sessionId);
            this._sessions.set(sessionId, session);
          } else if (object.method === "Target.detachedFromTarget") {
            const session = this._sessions.get(object.params.sessionId);
            if (session) {
              session._onClosed();
              this._sessions.delete(object.params.sessionId);
            }
          }
          if (object.sessionId) {
            const session = this._sessions.get(object.sessionId);
            if (session)
              session._onMessage(object);
          } else if (object.id) {
            const callback = this._callbacks.get(object.id);
            if (callback) {
              this._callbacks.delete(object.id);
              if (object.error)
                callback.reject(createProtocolError(callback.error, callback.method, object));
              else
                callback.resolve(object.result);
            }
          } else {
            this.emit(object.method, object.params);
          }
        });
      }
      _onClose() {
        if (this._closed)
          return;
        this._closed = true;
        this._transport.onmessage = null;
        this._transport.onclose = null;
        for (const callback of this._callbacks.values())
          callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        for (const session of this._sessions.values())
          session._onClosed();
        this._sessions.clear();
        this.emit(Events.Connection.Disconnected);
      }
      dispose() {
        this._onClose();
        this._transport.close();
      }
      createSession(targetInfo) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { sessionId } = yield this.send("Target.attachToTarget", { targetId: targetInfo.targetId, flatten: true });
          return this._sessions.get(sessionId);
        });
      }
    };
    var CDPSession = class extends EventEmitter {
      constructor(connection, targetType, sessionId) {
        super();
        this._callbacks = new Map();
        this._connection = connection;
        this._targetType = targetType;
        this._sessionId = sessionId;
      }
      send(method, params = {}) {
        if (!this._connection)
          return Promise.reject(new Error(`Protocol error (${method}): Session closed. Most likely the ${this._targetType} has been closed.`));
        const id = this._connection._rawSend({ sessionId: this._sessionId, method, params });
        return new Promise((resolve, reject) => {
          this._callbacks.set(id, { resolve, reject, error: new Error(), method });
        });
      }
      _onMessage(object) {
        if (object.id && this._callbacks.has(object.id)) {
          const callback = this._callbacks.get(object.id);
          this._callbacks.delete(object.id);
          if (object.error)
            callback.reject(createProtocolError(callback.error, callback.method, object));
          else
            callback.resolve(object.result);
        } else {
          assert(!object.id);
          this.emit(object.method, object.params);
        }
      }
      detach() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (!this._connection)
            throw new Error(`Session already detached. Most likely the ${this._targetType} has been closed.`);
          yield this._connection.send("Target.detachFromTarget", { sessionId: this._sessionId });
        });
      }
      _onClosed() {
        for (const callback of this._callbacks.values())
          callback.reject(rewriteError(callback.error, `Protocol error (${callback.method}): Target closed.`));
        this._callbacks.clear();
        this._connection = null;
        this.emit(Events.CDPSession.Disconnected);
      }
    };
    function createProtocolError(error, method, object) {
      let message = `Protocol error (${method}): ${object.error.message}`;
      if ("data" in object.error)
        message += ` ${object.error.data}`;
      return rewriteError(error, message);
    }
    function rewriteError(error, message) {
      error.message = message;
      return error;
    }
    module2.exports = { Connection, CDPSession };
  }
});

// node_modules/puppeteer/node6/lib/Dialog.js
var require_Dialog2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Dialog.js"(exports, module2) {
    var { assert } = require_helper2();
    var Dialog = class {
      constructor(client, type, message, defaultValue = "") {
        this._client = client;
        this._type = type;
        this._message = message;
        this._handled = false;
        this._defaultValue = defaultValue;
      }
      type() {
        return this._type;
      }
      message() {
        return this._message;
      }
      defaultValue() {
        return this._defaultValue;
      }
      accept(promptText) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(!this._handled, "Cannot accept dialog which is already handled!");
          this._handled = true;
          yield this._client.send("Page.handleJavaScriptDialog", {
            accept: true,
            promptText
          });
        });
      }
      dismiss() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(!this._handled, "Cannot dismiss dialog which is already handled!");
          this._handled = true;
          yield this._client.send("Page.handleJavaScriptDialog", {
            accept: false
          });
        });
      }
    };
    Dialog.Type = {
      Alert: "alert",
      BeforeUnload: "beforeunload",
      Confirm: "confirm",
      Prompt: "prompt"
    };
    module2.exports = { Dialog };
  }
});

// node_modules/puppeteer/node6/lib/EmulationManager.js
var require_EmulationManager2 = __commonJS({
  "node_modules/puppeteer/node6/lib/EmulationManager.js"(exports, module2) {
    var EmulationManager = class {
      constructor(client) {
        this._client = client;
        this._emulatingMobile = false;
        this._hasTouch = false;
      }
      emulateViewport(viewport) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const mobile = viewport.isMobile || false;
          const width = viewport.width;
          const height = viewport.height;
          const deviceScaleFactor = viewport.deviceScaleFactor || 1;
          const screenOrientation = viewport.isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
          const hasTouch = viewport.hasTouch || false;
          yield Promise.all([
            this._client.send("Emulation.setDeviceMetricsOverride", { mobile, width, height, deviceScaleFactor, screenOrientation }),
            this._client.send("Emulation.setTouchEmulationEnabled", {
              enabled: hasTouch
            })
          ]);
          const reloadNeeded = this._emulatingMobile !== mobile || this._hasTouch !== hasTouch;
          this._emulatingMobile = mobile;
          this._hasTouch = hasTouch;
          return reloadNeeded;
        });
      }
    };
    module2.exports = { EmulationManager };
  }
});

// node_modules/puppeteer/node6/lib/JSHandle.js
var require_JSHandle2 = __commonJS({
  "node_modules/puppeteer/node6/lib/JSHandle.js"(exports, module2) {
    var { helper, assert, debugError } = require_helper2();
    var path = require("path");
    function createJSHandle(context, remoteObject) {
      const frame = context.frame();
      if (remoteObject.subtype === "node" && frame) {
        const frameManager = frame._frameManager;
        return new ElementHandle(context, context._client, remoteObject, frameManager.page(), frameManager);
      }
      return new JSHandle(context, context._client, remoteObject);
    }
    var JSHandle = class {
      constructor(context, client, remoteObject) {
        this._context = context;
        this._client = client;
        this._remoteObject = remoteObject;
        this._disposed = false;
      }
      executionContext() {
        return this._context;
      }
      getProperty(propertyName) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const objectHandle = yield this._context.evaluateHandle((object, propertyName2) => {
            const result2 = { __proto__: null };
            result2[propertyName2] = object[propertyName2];
            return result2;
          }, this, propertyName);
          const properties = yield objectHandle.getProperties();
          const result = properties.get(propertyName) || null;
          yield objectHandle.dispose();
          return result;
        });
      }
      getProperties() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const response = yield this._client.send("Runtime.getProperties", {
            objectId: this._remoteObject.objectId,
            ownProperties: true
          });
          const result = new Map();
          for (const property of response.result) {
            if (!property.enumerable)
              continue;
            result.set(property.name, createJSHandle(this._context, property.value));
          }
          return result;
        });
      }
      jsonValue() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._remoteObject.objectId) {
            const response = yield this._client.send("Runtime.callFunctionOn", {
              functionDeclaration: "function() { return this; }",
              objectId: this._remoteObject.objectId,
              returnByValue: true,
              awaitPromise: true
            });
            return helper.valueFromRemoteObject(response.result);
          }
          return helper.valueFromRemoteObject(this._remoteObject);
        });
      }
      asElement() {
        return null;
      }
      dispose() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._disposed)
            return;
          this._disposed = true;
          yield helper.releaseObject(this._client, this._remoteObject);
        });
      }
      toString() {
        if (this._remoteObject.objectId) {
          const type = this._remoteObject.subtype || this._remoteObject.type;
          return "JSHandle@" + type;
        }
        return "JSHandle:" + helper.valueFromRemoteObject(this._remoteObject);
      }
    };
    var ElementHandle = class extends JSHandle {
      constructor(context, client, remoteObject, page, frameManager) {
        super(context, client, remoteObject);
        this._client = client;
        this._remoteObject = remoteObject;
        this._page = page;
        this._frameManager = frameManager;
        this._disposed = false;
      }
      asElement() {
        return this;
      }
      contentFrame() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: this._remoteObject.objectId
          });
          if (typeof nodeInfo.node.frameId !== "string")
            return null;
          return this._frameManager.frame(nodeInfo.node.frameId);
        });
      }
      _scrollIntoViewIfNeeded() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const error = yield this.executionContext().evaluate((element, pageJavascriptEnabled) => {
            return ((fn) => {
              const gen = fn.call(this);
              return new Promise((resolve, reject) => {
                function step(key, arg) {
                  let info, value;
                  try {
                    info = gen[key](arg);
                    value = info.value;
                  } catch (error2) {
                    reject(error2);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then((value2) => {
                      step("next", value2);
                    }, (err) => {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            })(function* () {
              if (!element.isConnected)
                return "Node is detached from document";
              if (element.nodeType !== Node.ELEMENT_NODE)
                return "Node is not of type HTMLElement";
              if (!pageJavascriptEnabled) {
                element.scrollIntoView({ block: "center", inline: "center", behavior: "instant" });
                return false;
              }
              const visibleRatio = yield new Promise((resolve) => {
                const observer = new IntersectionObserver((entries) => {
                  resolve(entries[0].intersectionRatio);
                  observer.disconnect();
                });
                observer.observe(element);
              });
              if (visibleRatio !== 1)
                element.scrollIntoView({ block: "center", inline: "center", behavior: "instant" });
              return false;
            });
          }, this, this._page._javascriptEnabled);
          if (error)
            throw new Error(error);
        });
      }
      _clickablePoint() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const [result, layoutMetrics] = yield Promise.all([
            this._client.send("DOM.getContentQuads", {
              objectId: this._remoteObject.objectId
            }).catch(debugError),
            this._client.send("Page.getLayoutMetrics")
          ]);
          if (!result || !result.quads.length)
            throw new Error("Node is either not visible or not an HTMLElement");
          const { clientWidth, clientHeight } = layoutMetrics.layoutViewport;
          const quads = result.quads.map((quad2) => this._fromProtocolQuad(quad2)).map((quad2) => this._intersectQuadWithViewport(quad2, clientWidth, clientHeight)).filter((quad2) => computeQuadArea(quad2) > 1);
          if (!quads.length)
            throw new Error("Node is either not visible or not an HTMLElement");
          const quad = quads[0];
          let x = 0;
          let y = 0;
          for (const point of quad) {
            x += point.x;
            y += point.y;
          }
          return {
            x: x / 4,
            y: y / 4
          };
        });
      }
      _getBoxModel() {
        return this._client.send("DOM.getBoxModel", {
          objectId: this._remoteObject.objectId
        }).catch((error) => debugError(error));
      }
      _fromProtocolQuad(quad) {
        return [
          { x: quad[0], y: quad[1] },
          { x: quad[2], y: quad[3] },
          { x: quad[4], y: quad[5] },
          { x: quad[6], y: quad[7] }
        ];
      }
      _intersectQuadWithViewport(quad, width, height) {
        return quad.map((point) => ({
          x: Math.min(Math.max(point.x, 0), width),
          y: Math.min(Math.max(point.y, 0), height)
        }));
      }
      hover() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._scrollIntoViewIfNeeded();
          const { x, y } = yield this._clickablePoint();
          yield this._page.mouse.move(x, y);
        });
      }
      click(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._scrollIntoViewIfNeeded();
          const { x, y } = yield this._clickablePoint();
          yield this._page.mouse.click(x, y, options);
        });
      }
      uploadFile(...filePaths) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const files = filePaths.map((filePath) => path.resolve(filePath));
          const objectId = this._remoteObject.objectId;
          yield this._client.send("DOM.setFileInputFiles", { objectId, files });
        });
      }
      tap() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._scrollIntoViewIfNeeded();
          const { x, y } = yield this._clickablePoint();
          yield this._page.touchscreen.tap(x, y);
        });
      }
      focus() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this.executionContext().evaluate((element) => element.focus(), this);
        });
      }
      type(text, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this.focus();
          yield this._page.keyboard.type(text, options);
        });
      }
      press(key, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key2, arg) {
              let info, value;
              try {
                info = gen[key2](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this.focus();
          yield this._page.keyboard.press(key, options);
        });
      }
      boundingBox() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const result = yield this._getBoxModel();
          if (!result)
            return null;
          const quad = result.model.border;
          const x = Math.min(quad[0], quad[2], quad[4], quad[6]);
          const y = Math.min(quad[1], quad[3], quad[5], quad[7]);
          const width = Math.max(quad[0], quad[2], quad[4], quad[6]) - x;
          const height = Math.max(quad[1], quad[3], quad[5], quad[7]) - y;
          return { x, y, width, height };
        });
      }
      boxModel() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const result = yield this._getBoxModel();
          if (!result)
            return null;
          const { content, padding, border, margin, width, height } = result.model;
          return {
            content: this._fromProtocolQuad(content),
            padding: this._fromProtocolQuad(padding),
            border: this._fromProtocolQuad(border),
            margin: this._fromProtocolQuad(margin),
            width,
            height
          };
        });
      }
      screenshot(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          let needsViewportReset = false;
          let boundingBox = yield this.boundingBox();
          assert(boundingBox, "Node is either not visible or not an HTMLElement");
          const viewport = this._page.viewport();
          if (viewport && (boundingBox.width > viewport.width || boundingBox.height > viewport.height)) {
            const newViewport = {
              width: Math.max(viewport.width, Math.ceil(boundingBox.width)),
              height: Math.max(viewport.height, Math.ceil(boundingBox.height))
            };
            yield this._page.setViewport(Object.assign({}, viewport, newViewport));
            needsViewportReset = true;
          }
          yield this._scrollIntoViewIfNeeded();
          boundingBox = yield this.boundingBox();
          assert(boundingBox, "Node is either not visible or not an HTMLElement");
          assert(boundingBox.width !== 0, "Node has 0 width.");
          assert(boundingBox.height !== 0, "Node has 0 height.");
          const { layoutViewport: { pageX, pageY } } = yield this._client.send("Page.getLayoutMetrics");
          const clip = Object.assign({}, boundingBox);
          clip.x += pageX;
          clip.y += pageY;
          const imageData = yield this._page.screenshot(Object.assign({}, {
            clip
          }, options));
          if (needsViewportReset)
            yield this._page.setViewport(viewport);
          return imageData;
        });
      }
      $(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this.executionContext().evaluateHandle((element2, selector2) => element2.querySelector(selector2), this, selector);
          const element = handle.asElement();
          if (element)
            return element;
          yield handle.dispose();
          return null;
        });
      }
      $$(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const arrayHandle = yield this.executionContext().evaluateHandle((element, selector2) => element.querySelectorAll(selector2), this, selector);
          const properties = yield arrayHandle.getProperties();
          yield arrayHandle.dispose();
          const result = [];
          for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
              result.push(elementHandle);
          }
          return result;
        });
      }
      $eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const elementHandle = yield this.$(selector);
          if (!elementHandle)
            throw new Error(`Error: failed to find element matching selector "${selector}"`);
          const result = yield this.executionContext().evaluate(pageFunction, elementHandle, ...args);
          yield elementHandle.dispose();
          return result;
        });
      }
      $$eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const arrayHandle = yield this.executionContext().evaluateHandle((element, selector2) => Array.from(element.querySelectorAll(selector2)), this, selector);
          const result = yield this.executionContext().evaluate(pageFunction, arrayHandle, ...args);
          yield arrayHandle.dispose();
          return result;
        });
      }
      $x(expression) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const arrayHandle = yield this.executionContext().evaluateHandle((element, expression2) => {
            const document2 = element.ownerDocument || element;
            const iterator = document2.evaluate(expression2, element, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE);
            const array = [];
            let item;
            while (item = iterator.iterateNext())
              array.push(item);
            return array;
          }, this, expression);
          const properties = yield arrayHandle.getProperties();
          yield arrayHandle.dispose();
          const result = [];
          for (const property of properties.values()) {
            const elementHandle = property.asElement();
            if (elementHandle)
              result.push(elementHandle);
          }
          return result;
        });
      }
      isIntersectingViewport() {
        return this.executionContext().evaluate((element) => {
          return ((fn) => {
            const gen = fn.call(this);
            return new Promise((resolve, reject) => {
              function step(key, arg) {
                let info, value;
                try {
                  info = gen[key](arg);
                  value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  return Promise.resolve(value).then((value2) => {
                    step("next", value2);
                  }, (err) => {
                    step("throw", err);
                  });
                }
              }
              return step("next");
            });
          })(function* () {
            const visibleRatio = yield new Promise((resolve) => {
              const observer = new IntersectionObserver((entries) => {
                resolve(entries[0].intersectionRatio);
                observer.disconnect();
              });
              observer.observe(element);
            });
            return visibleRatio > 0;
          });
        }, this);
      }
    };
    function computeQuadArea(quad) {
      let area = 0;
      for (let i = 0; i < quad.length; ++i) {
        const p1 = quad[i];
        const p2 = quad[(i + 1) % quad.length];
        area += (p1.x * p2.y - p2.x * p1.y) / 2;
      }
      return Math.abs(area);
    }
    module2.exports = { createJSHandle, JSHandle, ElementHandle };
  }
});

// node_modules/puppeteer/node6/lib/ExecutionContext.js
var require_ExecutionContext2 = __commonJS({
  "node_modules/puppeteer/node6/lib/ExecutionContext.js"(exports, module2) {
    var { helper, assert } = require_helper2();
    var { createJSHandle, JSHandle } = require_JSHandle2();
    var EVALUATION_SCRIPT_URL = "__puppeteer_evaluation_script__";
    var SOURCE_URL_REGEX = /^[\040\t]*\/\/[@#] sourceURL=\s*(\S*?)\s*$/m;
    var ExecutionContext = class {
      constructor(client, contextPayload, world) {
        this._client = client;
        this._world = world;
        this._contextId = contextPayload.id;
      }
      frame() {
        return this._world ? this._world.frame() : null;
      }
      evaluate(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this.evaluateHandle(pageFunction, ...args);
          const result = yield handle.jsonValue().catch((error) => {
            if (error.message.includes("Object reference chain is too long"))
              return;
            if (error.message.includes("Object couldn't be returned by value"))
              return;
            throw error;
          });
          yield handle.dispose();
          return result;
        });
      }
      evaluateHandle(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const suffix = `//# sourceURL=${EVALUATION_SCRIPT_URL}`;
          if (helper.isString(pageFunction)) {
            const contextId = this._contextId;
            const expression = pageFunction;
            const expressionWithSourceUrl = SOURCE_URL_REGEX.test(expression) ? expression : expression + "\n" + suffix;
            const { exceptionDetails: exceptionDetails2, result: remoteObject2 } = yield this._client.send("Runtime.evaluate", {
              expression: expressionWithSourceUrl,
              contextId,
              returnByValue: false,
              awaitPromise: true,
              userGesture: true
            }).catch(rewriteError);
            if (exceptionDetails2)
              throw new Error("Evaluation failed: " + helper.getExceptionMessage(exceptionDetails2));
            return createJSHandle(this, remoteObject2);
          }
          if (typeof pageFunction !== "function")
            throw new Error(`Expected to get |string| or |function| as the first argument, but got "${pageFunction}" instead.`);
          let functionText = pageFunction.toString();
          try {
            new Function("(" + functionText + ")");
          } catch (e1) {
            if (functionText.startsWith("async "))
              functionText = "async function " + functionText.substring("async ".length);
            else
              functionText = "function " + functionText;
            try {
              new Function("(" + functionText + ")");
            } catch (e2) {
              throw new Error("Passed function is not well-serializable!");
            }
          }
          let callFunctionOnPromise;
          try {
            callFunctionOnPromise = this._client.send("Runtime.callFunctionOn", {
              functionDeclaration: functionText + "\n" + suffix + "\n",
              executionContextId: this._contextId,
              arguments: args.map(convertArgument.bind(this)),
              returnByValue: false,
              awaitPromise: true,
              userGesture: true
            });
          } catch (err) {
            if (err instanceof TypeError && err.message === "Converting circular structure to JSON")
              err.message += " Are you passing a nested JSHandle?";
            throw err;
          }
          const { exceptionDetails, result: remoteObject } = yield callFunctionOnPromise.catch(rewriteError);
          if (exceptionDetails)
            throw new Error("Evaluation failed: " + helper.getExceptionMessage(exceptionDetails));
          return createJSHandle(this, remoteObject);
          function convertArgument(arg) {
            if (typeof arg === "bigint")
              return { unserializableValue: `${arg.toString()}n` };
            if (Object.is(arg, -0))
              return { unserializableValue: "-0" };
            if (Object.is(arg, Infinity))
              return { unserializableValue: "Infinity" };
            if (Object.is(arg, -Infinity))
              return { unserializableValue: "-Infinity" };
            if (Object.is(arg, NaN))
              return { unserializableValue: "NaN" };
            const objectHandle = arg && arg instanceof JSHandle ? arg : null;
            if (objectHandle) {
              if (objectHandle._context !== this)
                throw new Error("JSHandles can be evaluated only in the context they were created!");
              if (objectHandle._disposed)
                throw new Error("JSHandle is disposed!");
              if (objectHandle._remoteObject.unserializableValue)
                return { unserializableValue: objectHandle._remoteObject.unserializableValue };
              if (!objectHandle._remoteObject.objectId)
                return { value: objectHandle._remoteObject.value };
              return { objectId: objectHandle._remoteObject.objectId };
            }
            return { value: arg };
          }
          function rewriteError(error) {
            if (error.message.endsWith("Cannot find context with specified id"))
              throw new Error("Execution context was destroyed, most likely because of a navigation.");
            throw error;
          }
        });
      }
      queryObjects(prototypeHandle) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(!prototypeHandle._disposed, "Prototype JSHandle is disposed!");
          assert(prototypeHandle._remoteObject.objectId, "Prototype JSHandle must not be referencing primitive value");
          const response = yield this._client.send("Runtime.queryObjects", {
            prototypeObjectId: prototypeHandle._remoteObject.objectId
          });
          return createJSHandle(this, response.objects);
        });
      }
      _adoptElementHandle(elementHandle) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(elementHandle.executionContext() !== this, "Cannot adopt handle that already belongs to this execution context");
          assert(this._world, "Cannot adopt handle without DOMWorld");
          const nodeInfo = yield this._client.send("DOM.describeNode", {
            objectId: elementHandle._remoteObject.objectId
          });
          const { object } = yield this._client.send("DOM.resolveNode", {
            backendNodeId: nodeInfo.node.backendNodeId,
            executionContextId: this._contextId
          });
          return createJSHandle(this, object);
        });
      }
    };
    module2.exports = { ExecutionContext, EVALUATION_SCRIPT_URL };
  }
});

// node_modules/puppeteer/node6/lib/LifecycleWatcher.js
var require_LifecycleWatcher2 = __commonJS({
  "node_modules/puppeteer/node6/lib/LifecycleWatcher.js"(exports, module2) {
    var { helper, assert } = require_helper2();
    var { Events } = require_Events2();
    var { TimeoutError } = require_Errors2();
    var LifecycleWatcher = class {
      constructor(frameManager, frame, waitUntil, timeout) {
        if (Array.isArray(waitUntil))
          waitUntil = waitUntil.slice();
        else if (typeof waitUntil === "string")
          waitUntil = [waitUntil];
        this._expectedLifecycle = waitUntil.map((value) => {
          const protocolEvent = puppeteerToProtocolLifecycle[value];
          assert(protocolEvent, "Unknown value for options.waitUntil: " + value);
          return protocolEvent;
        });
        this._frameManager = frameManager;
        this._frame = frame;
        this._initialLoaderId = frame._loaderId;
        this._timeout = timeout;
        this._navigationRequest = null;
        this._eventListeners = [
          helper.addEventListener(frameManager._client, Events.CDPSession.Disconnected, () => this._terminate(new Error("Navigation failed because browser has disconnected!"))),
          helper.addEventListener(this._frameManager, Events.FrameManager.LifecycleEvent, this._checkLifecycleComplete.bind(this)),
          helper.addEventListener(this._frameManager, Events.FrameManager.FrameNavigatedWithinDocument, this._navigatedWithinDocument.bind(this)),
          helper.addEventListener(this._frameManager, Events.FrameManager.FrameDetached, this._onFrameDetached.bind(this)),
          helper.addEventListener(this._frameManager.networkManager(), Events.NetworkManager.Request, this._onRequest.bind(this))
        ];
        this._sameDocumentNavigationPromise = new Promise((fulfill) => {
          this._sameDocumentNavigationCompleteCallback = fulfill;
        });
        this._lifecyclePromise = new Promise((fulfill) => {
          this._lifecycleCallback = fulfill;
        });
        this._newDocumentNavigationPromise = new Promise((fulfill) => {
          this._newDocumentNavigationCompleteCallback = fulfill;
        });
        this._timeoutPromise = this._createTimeoutPromise();
        this._terminationPromise = new Promise((fulfill) => {
          this._terminationCallback = fulfill;
        });
        this._checkLifecycleComplete();
      }
      _onRequest(request) {
        if (request.frame() !== this._frame || !request.isNavigationRequest())
          return;
        this._navigationRequest = request;
      }
      _onFrameDetached(frame) {
        if (this._frame === frame) {
          this._terminationCallback.call(null, new Error("Navigating frame was detached"));
          return;
        }
        this._checkLifecycleComplete();
      }
      navigationResponse() {
        return this._navigationRequest ? this._navigationRequest.response() : null;
      }
      _terminate(error) {
        this._terminationCallback.call(null, error);
      }
      sameDocumentNavigationPromise() {
        return this._sameDocumentNavigationPromise;
      }
      newDocumentNavigationPromise() {
        return this._newDocumentNavigationPromise;
      }
      lifecyclePromise() {
        return this._lifecyclePromise;
      }
      timeoutOrTerminationPromise() {
        return Promise.race([this._timeoutPromise, this._terminationPromise]);
      }
      _createTimeoutPromise() {
        if (!this._timeout)
          return new Promise(() => {
          });
        const errorMessage = "Navigation Timeout Exceeded: " + this._timeout + "ms exceeded";
        return new Promise((fulfill) => this._maximumTimer = setTimeout(fulfill, this._timeout)).then(() => new TimeoutError(errorMessage));
      }
      _navigatedWithinDocument(frame) {
        if (frame !== this._frame)
          return;
        this._hasSameDocumentNavigation = true;
        this._checkLifecycleComplete();
      }
      _checkLifecycleComplete() {
        if (!checkLifecycle(this._frame, this._expectedLifecycle))
          return;
        this._lifecycleCallback();
        if (this._frame._loaderId === this._initialLoaderId && !this._hasSameDocumentNavigation)
          return;
        if (this._hasSameDocumentNavigation)
          this._sameDocumentNavigationCompleteCallback();
        if (this._frame._loaderId !== this._initialLoaderId)
          this._newDocumentNavigationCompleteCallback();
        function checkLifecycle(frame, expectedLifecycle) {
          for (const event of expectedLifecycle) {
            if (!frame._lifecycleEvents.has(event))
              return false;
          }
          for (const child of frame.childFrames()) {
            if (!checkLifecycle(child, expectedLifecycle))
              return false;
          }
          return true;
        }
      }
      dispose() {
        helper.removeEventListeners(this._eventListeners);
        clearTimeout(this._maximumTimer);
      }
    };
    var puppeteerToProtocolLifecycle = {
      "load": "load",
      "domcontentloaded": "DOMContentLoaded",
      "networkidle0": "networkIdle",
      "networkidle2": "networkAlmostIdle"
    };
    module2.exports = { LifecycleWatcher };
  }
});

// node_modules/puppeteer/node6/lib/DOMWorld.js
var require_DOMWorld2 = __commonJS({
  "node_modules/puppeteer/node6/lib/DOMWorld.js"(exports, module2) {
    var fs = require("fs");
    var { helper, assert } = require_helper2();
    var { LifecycleWatcher } = require_LifecycleWatcher2();
    var { TimeoutError } = require_Errors2();
    var readFileAsync = helper.promisify(fs.readFile);
    var DOMWorld = class {
      constructor(frameManager, frame, timeoutSettings) {
        this._frameManager = frameManager;
        this._frame = frame;
        this._timeoutSettings = timeoutSettings;
        this._documentPromise = null;
        this._contextPromise;
        this._contextResolveCallback = null;
        this._setContext(null);
        this._waitTasks = new Set();
        this._detached = false;
      }
      frame() {
        return this._frame;
      }
      _setContext(context) {
        if (context) {
          this._contextResolveCallback.call(null, context);
          this._contextResolveCallback = null;
          for (const waitTask of this._waitTasks)
            waitTask.rerun();
        } else {
          this._documentPromise = null;
          this._contextPromise = new Promise((fulfill) => {
            this._contextResolveCallback = fulfill;
          });
        }
      }
      _hasContext() {
        return !this._contextResolveCallback;
      }
      _detach() {
        this._detached = true;
        for (const waitTask of this._waitTasks)
          waitTask.terminate(new Error("waitForFunction failed: frame got detached."));
      }
      executionContext() {
        if (this._detached)
          throw new Error(`Execution Context is not available in detached frame "${this._frame.url()}" (are you trying to evaluate?)`);
        return this._contextPromise;
      }
      evaluateHandle(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const context = yield this.executionContext();
          return context.evaluateHandle(pageFunction, ...args);
        });
      }
      evaluate(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const context = yield this.executionContext();
          return context.evaluate(pageFunction, ...args);
        });
      }
      $(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const document2 = yield this._document();
          const value = yield document2.$(selector);
          return value;
        });
      }
      _document() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._documentPromise)
            return this._documentPromise;
          this._documentPromise = this.executionContext().then((context) => {
            return ((fn) => {
              const gen = fn.call(this);
              return new Promise((resolve, reject) => {
                function step(key, arg) {
                  let info, value;
                  try {
                    info = gen[key](arg);
                    value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then((value2) => {
                      step("next", value2);
                    }, (err) => {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            })(function* () {
              const document2 = yield context.evaluateHandle("document");
              return document2.asElement();
            });
          });
          return this._documentPromise;
        });
      }
      $x(expression) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const document2 = yield this._document();
          const value = yield document2.$x(expression);
          return value;
        });
      }
      $eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const document2 = yield this._document();
          return document2.$eval(selector, pageFunction, ...args);
        });
      }
      $$eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const document2 = yield this._document();
          const value = yield document2.$$eval(selector, pageFunction, ...args);
          return value;
        });
      }
      $$(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const document2 = yield this._document();
          const value = yield document2.$$(selector);
          return value;
        });
      }
      content() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this.evaluate(() => {
            let retVal = "";
            if (document.doctype)
              retVal = new XMLSerializer().serializeToString(document.doctype);
            if (document.documentElement)
              retVal += document.documentElement.outerHTML;
            return retVal;
          });
        });
      }
      setContent(html, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            waitUntil = ["load"],
            timeout = this._timeoutSettings.navigationTimeout()
          } = options;
          yield this.evaluate((html2) => {
            document.open();
            document.write(html2);
            document.close();
          }, html);
          const watcher = new LifecycleWatcher(this._frameManager, this._frame, waitUntil, timeout);
          const error = yield Promise.race([
            watcher.timeoutOrTerminationPromise(),
            watcher.lifecyclePromise()
          ]);
          watcher.dispose();
          if (error)
            throw error;
        });
      }
      addScriptTag(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            url = null,
            path = null,
            content = null,
            type = ""
          } = options;
          if (url !== null) {
            try {
              const context = yield this.executionContext();
              return (yield context.evaluateHandle(addScriptUrl, url, type)).asElement();
            } catch (error) {
              throw new Error(`Loading script from ${url} failed`);
            }
          }
          if (path !== null) {
            let contents = yield readFileAsync(path, "utf8");
            contents += "//# sourceURL=" + path.replace(/\n/g, "");
            const context = yield this.executionContext();
            return (yield context.evaluateHandle(addScriptContent, contents, type)).asElement();
          }
          if (content !== null) {
            const context = yield this.executionContext();
            return (yield context.evaluateHandle(addScriptContent, content, type)).asElement();
          }
          throw new Error("Provide an object with a `url`, `path` or `content` property");
          function addScriptUrl(url2, type2) {
            return ((fn) => {
              const gen = fn.call(this);
              return new Promise((resolve, reject) => {
                function step(key, arg) {
                  let info, value;
                  try {
                    info = gen[key](arg);
                    value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then((value2) => {
                      step("next", value2);
                    }, (err) => {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            })(function* () {
              const script = document.createElement("script");
              script.src = url2;
              if (type2)
                script.type = type2;
              const promise = new Promise((res, rej) => {
                script.onload = res;
                script.onerror = rej;
              });
              document.head.appendChild(script);
              yield promise;
              return script;
            });
          }
          function addScriptContent(content2, type2 = "text/javascript") {
            const script = document.createElement("script");
            script.type = type2;
            script.text = content2;
            let error = null;
            script.onerror = (e) => error = e;
            document.head.appendChild(script);
            if (error)
              throw error;
            return script;
          }
        });
      }
      addStyleTag(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            url = null,
            path = null,
            content = null
          } = options;
          if (url !== null) {
            try {
              const context = yield this.executionContext();
              return (yield context.evaluateHandle(addStyleUrl, url)).asElement();
            } catch (error) {
              throw new Error(`Loading style from ${url} failed`);
            }
          }
          if (path !== null) {
            let contents = yield readFileAsync(path, "utf8");
            contents += "/*# sourceURL=" + path.replace(/\n/g, "") + "*/";
            const context = yield this.executionContext();
            return (yield context.evaluateHandle(addStyleContent, contents)).asElement();
          }
          if (content !== null) {
            const context = yield this.executionContext();
            return (yield context.evaluateHandle(addStyleContent, content)).asElement();
          }
          throw new Error("Provide an object with a `url`, `path` or `content` property");
          function addStyleUrl(url2) {
            return ((fn) => {
              const gen = fn.call(this);
              return new Promise((resolve, reject) => {
                function step(key, arg) {
                  let info, value;
                  try {
                    info = gen[key](arg);
                    value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then((value2) => {
                      step("next", value2);
                    }, (err) => {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            })(function* () {
              const link = document.createElement("link");
              link.rel = "stylesheet";
              link.href = url2;
              const promise = new Promise((res, rej) => {
                link.onload = res;
                link.onerror = rej;
              });
              document.head.appendChild(link);
              yield promise;
              return link;
            });
          }
          function addStyleContent(content2) {
            return ((fn) => {
              const gen = fn.call(this);
              return new Promise((resolve, reject) => {
                function step(key, arg) {
                  let info, value;
                  try {
                    info = gen[key](arg);
                    value = info.value;
                  } catch (error) {
                    reject(error);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then((value2) => {
                      step("next", value2);
                    }, (err) => {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            })(function* () {
              const style = document.createElement("style");
              style.type = "text/css";
              style.appendChild(document.createTextNode(content2));
              const promise = new Promise((res, rej) => {
                style.onload = res;
                style.onerror = rej;
              });
              document.head.appendChild(style);
              yield promise;
              return style;
            });
          }
        });
      }
      click(selector, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this.$(selector);
          assert(handle, "No node found for selector: " + selector);
          yield handle.click(options);
          yield handle.dispose();
        });
      }
      focus(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this.$(selector);
          assert(handle, "No node found for selector: " + selector);
          yield handle.focus();
          yield handle.dispose();
        });
      }
      hover(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this.$(selector);
          assert(handle, "No node found for selector: " + selector);
          yield handle.hover();
          yield handle.dispose();
        });
      }
      select(selector, ...values) {
        for (const value of values)
          assert(helper.isString(value), 'Values must be strings. Found value "' + value + '" of type "' + typeof value + '"');
        return this.$eval(selector, (element, values2) => {
          if (element.nodeName.toLowerCase() !== "select")
            throw new Error("Element is not a <select> element.");
          const options = Array.from(element.options);
          element.value = void 0;
          for (const option of options) {
            option.selected = values2.includes(option.value);
            if (option.selected && !element.multiple)
              break;
          }
          element.dispatchEvent(new Event("input", { "bubbles": true }));
          element.dispatchEvent(new Event("change", { "bubbles": true }));
          return options.filter((option) => option.selected).map((option) => option.value);
        }, values);
      }
      tap(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this.$(selector);
          assert(handle, "No node found for selector: " + selector);
          yield handle.tap();
          yield handle.dispose();
        });
      }
      type(selector, text, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this.$(selector);
          assert(handle, "No node found for selector: " + selector);
          yield handle.type(text, options);
          yield handle.dispose();
        });
      }
      waitForSelector(selector, options) {
        return this._waitForSelectorOrXPath(selector, false, options);
      }
      waitForXPath(xpath, options) {
        return this._waitForSelectorOrXPath(xpath, true, options);
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        const {
          polling = "raf",
          timeout = this._timeoutSettings.timeout()
        } = options;
        return new WaitTask(this, pageFunction, "function", polling, timeout, ...args).promise;
      }
      title() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.evaluate(() => document.title);
        });
      }
      _waitForSelectorOrXPath(selectorOrXPath, isXPath, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            visible: waitForVisible = false,
            hidden: waitForHidden = false,
            timeout = this._timeoutSettings.timeout()
          } = options;
          const polling = waitForVisible || waitForHidden ? "raf" : "mutation";
          const title = `${isXPath ? "XPath" : "selector"} "${selectorOrXPath}"${waitForHidden ? " to be hidden" : ""}`;
          const waitTask = new WaitTask(this, predicate, title, polling, timeout, selectorOrXPath, isXPath, waitForVisible, waitForHidden);
          const handle = yield waitTask.promise;
          if (!handle.asElement()) {
            yield handle.dispose();
            return null;
          }
          return handle.asElement();
          function predicate(selectorOrXPath2, isXPath2, waitForVisible2, waitForHidden2) {
            const node = isXPath2 ? document.evaluate(selectorOrXPath2, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue : document.querySelector(selectorOrXPath2);
            if (!node)
              return waitForHidden2;
            if (!waitForVisible2 && !waitForHidden2)
              return node;
            const element = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
            const style = window.getComputedStyle(element);
            const isVisible = style && style.visibility !== "hidden" && hasVisibleBoundingBox();
            const success = waitForVisible2 === isVisible || waitForHidden2 === !isVisible;
            return success ? node : null;
            function hasVisibleBoundingBox() {
              const rect = element.getBoundingClientRect();
              return !!(rect.top || rect.bottom || rect.width || rect.height);
            }
          }
        });
      }
    };
    var WaitTask = class {
      constructor(domWorld, predicateBody, title, polling, timeout, ...args) {
        if (helper.isString(polling))
          assert(polling === "raf" || polling === "mutation", "Unknown polling option: " + polling);
        else if (helper.isNumber(polling))
          assert(polling > 0, "Cannot poll with non-positive interval: " + polling);
        else
          throw new Error("Unknown polling options: " + polling);
        this._domWorld = domWorld;
        this._polling = polling;
        this._timeout = timeout;
        this._predicateBody = helper.isString(predicateBody) ? "return (" + predicateBody + ")" : "return (" + predicateBody + ")(...args)";
        this._args = args;
        this._runCount = 0;
        domWorld._waitTasks.add(this);
        this.promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
        if (timeout) {
          const timeoutError = new TimeoutError(`waiting for ${title} failed: timeout ${timeout}ms exceeded`);
          this._timeoutTimer = setTimeout(() => this.terminate(timeoutError), timeout);
        }
        this.rerun();
      }
      terminate(error) {
        this._terminated = true;
        this._reject(error);
        this._cleanup();
      }
      rerun() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const runCount = ++this._runCount;
          let success = null;
          let error = null;
          try {
            success = yield (yield this._domWorld.executionContext()).evaluateHandle(waitForPredicatePageFunction, this._predicateBody, this._polling, this._timeout, ...this._args);
          } catch (e) {
            error = e;
          }
          if (this._terminated || runCount !== this._runCount) {
            if (success)
              yield success.dispose();
            return;
          }
          if (!error && (yield this._domWorld.evaluate((s) => !s, success).catch((e) => true))) {
            yield success.dispose();
            return;
          }
          if (error && error.message.includes("Execution context was destroyed"))
            return;
          if (error && error.message.includes("Cannot find context with specified id"))
            return;
          if (error)
            this._reject(error);
          else
            this._resolve(success);
          this._cleanup();
        });
      }
      _cleanup() {
        clearTimeout(this._timeoutTimer);
        this._domWorld._waitTasks.delete(this);
        this._runningTask = null;
      }
    };
    function waitForPredicatePageFunction(predicateBody, polling, timeout, ...args) {
      return ((fn) => {
        const gen = fn.call(this);
        return new Promise((resolve, reject) => {
          function step(key, arg) {
            let info, value;
            try {
              info = gen[key](arg);
              value = info.value;
            } catch (error) {
              reject(error);
              return;
            }
            if (info.done) {
              resolve(value);
            } else {
              return Promise.resolve(value).then((value2) => {
                step("next", value2);
              }, (err) => {
                step("throw", err);
              });
            }
          }
          return step("next");
        });
      })(function* () {
        const predicate = new Function("...args", predicateBody);
        let timedOut = false;
        if (timeout)
          setTimeout(() => timedOut = true, timeout);
        if (polling === "raf")
          return yield pollRaf();
        if (polling === "mutation")
          return yield pollMutation();
        if (typeof polling === "number")
          return yield pollInterval(polling);
        function pollMutation() {
          const success = predicate.apply(null, args);
          if (success)
            return Promise.resolve(success);
          let fulfill;
          const result = new Promise((x) => fulfill = x);
          const observer = new MutationObserver((mutations) => {
            if (timedOut) {
              observer.disconnect();
              fulfill();
            }
            const success2 = predicate.apply(null, args);
            if (success2) {
              observer.disconnect();
              fulfill(success2);
            }
          });
          observer.observe(document, {
            childList: true,
            subtree: true,
            attributes: true
          });
          return result;
        }
        function pollRaf() {
          let fulfill;
          const result = new Promise((x) => fulfill = x);
          onRaf();
          return result;
          function onRaf() {
            if (timedOut) {
              fulfill();
              return;
            }
            const success = predicate.apply(null, args);
            if (success)
              fulfill(success);
            else
              requestAnimationFrame(onRaf);
          }
        }
        function pollInterval(pollInterval2) {
          let fulfill;
          const result = new Promise((x) => fulfill = x);
          onTimeout();
          return result;
          function onTimeout() {
            if (timedOut) {
              fulfill();
              return;
            }
            const success = predicate.apply(null, args);
            if (success)
              fulfill(success);
            else
              setTimeout(onTimeout, pollInterval2);
          }
        }
      });
    }
    module2.exports = { DOMWorld };
  }
});

// node_modules/puppeteer/node6/lib/NetworkManager.js
var require_NetworkManager2 = __commonJS({
  "node_modules/puppeteer/node6/lib/NetworkManager.js"(exports, module2) {
    var EventEmitter = require("events");
    var { helper, assert, debugError } = require_helper2();
    var { Events } = require_Events2();
    var NetworkManager = class extends EventEmitter {
      constructor(client, ignoreHTTPSErrors) {
        super();
        this._client = client;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._frameManager = null;
        this._requestIdToRequest = new Map();
        this._requestIdToRequestWillBeSentEvent = new Map();
        this._extraHTTPHeaders = {};
        this._offline = false;
        this._credentials = null;
        this._attemptedAuthentications = new Set();
        this._userRequestInterceptionEnabled = false;
        this._protocolRequestInterceptionEnabled = false;
        this._userCacheDisabled = false;
        this._requestIdToInterceptionId = new Map();
        this._client.on("Fetch.requestPaused", this._onRequestPaused.bind(this));
        this._client.on("Fetch.authRequired", this._onAuthRequired.bind(this));
        this._client.on("Network.requestWillBeSent", this._onRequestWillBeSent.bind(this));
        this._client.on("Network.requestServedFromCache", this._onRequestServedFromCache.bind(this));
        this._client.on("Network.responseReceived", this._onResponseReceived.bind(this));
        this._client.on("Network.loadingFinished", this._onLoadingFinished.bind(this));
        this._client.on("Network.loadingFailed", this._onLoadingFailed.bind(this));
      }
      initialize() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Network.enable");
          if (this._ignoreHTTPSErrors)
            yield this._client.send("Security.setIgnoreCertificateErrors", { ignore: true });
        });
      }
      setFrameManager(frameManager) {
        this._frameManager = frameManager;
      }
      authenticate(credentials) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          this._credentials = credentials;
          yield this._updateProtocolRequestInterception();
        });
      }
      setExtraHTTPHeaders(extraHTTPHeaders) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          this._extraHTTPHeaders = {};
          for (const key of Object.keys(extraHTTPHeaders)) {
            const value = extraHTTPHeaders[key];
            assert(helper.isString(value), `Expected value of header "${key}" to be String, but "${typeof value}" is found.`);
            this._extraHTTPHeaders[key.toLowerCase()] = value;
          }
          yield this._client.send("Network.setExtraHTTPHeaders", { headers: this._extraHTTPHeaders });
        });
      }
      extraHTTPHeaders() {
        return Object.assign({}, this._extraHTTPHeaders);
      }
      setOfflineMode(value) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value2;
              try {
                info = gen[key](arg);
                value2 = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value2);
              } else {
                return Promise.resolve(value2).then((value3) => {
                  step("next", value3);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._offline === value)
            return;
          this._offline = value;
          yield this._client.send("Network.emulateNetworkConditions", {
            offline: this._offline,
            latency: 0,
            downloadThroughput: -1,
            uploadThroughput: -1
          });
        });
      }
      setUserAgent(userAgent) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Network.setUserAgentOverride", { userAgent });
        });
      }
      setCacheEnabled(enabled) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          this._userCacheDisabled = !enabled;
          yield this._updateProtocolCacheDisabled();
        });
      }
      setRequestInterception(value) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value2;
              try {
                info = gen[key](arg);
                value2 = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value2);
              } else {
                return Promise.resolve(value2).then((value3) => {
                  step("next", value3);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          this._userRequestInterceptionEnabled = value;
          yield this._updateProtocolRequestInterception();
        });
      }
      _updateProtocolRequestInterception() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const enabled = this._userRequestInterceptionEnabled || !!this._credentials;
          if (enabled === this._protocolRequestInterceptionEnabled)
            return;
          this._protocolRequestInterceptionEnabled = enabled;
          if (enabled) {
            yield Promise.all([
              this._updateProtocolCacheDisabled(),
              this._client.send("Fetch.enable", {
                handleAuthRequests: true,
                patterns: [{ urlPattern: "*" }]
              })
            ]);
          } else {
            yield Promise.all([
              this._updateProtocolCacheDisabled(),
              this._client.send("Fetch.disable")
            ]);
          }
        });
      }
      _updateProtocolCacheDisabled() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Network.setCacheDisabled", {
            cacheDisabled: this._userCacheDisabled || this._protocolRequestInterceptionEnabled
          });
        });
      }
      _onRequestWillBeSent(event) {
        if (this._protocolRequestInterceptionEnabled && !event.request.url.startsWith("data:")) {
          const requestId = event.requestId;
          const interceptionId = this._requestIdToInterceptionId.get(requestId);
          if (interceptionId) {
            this._onRequest(event, interceptionId);
            this._requestIdToInterceptionId.delete(requestId);
          } else {
            this._requestIdToRequestWillBeSentEvent.set(event.requestId, event);
          }
          return;
        }
        this._onRequest(event, null);
      }
      _onAuthRequired(event) {
        let response = "Default";
        if (this._attemptedAuthentications.has(event.requestId)) {
          response = "CancelAuth";
        } else if (this._credentials) {
          response = "ProvideCredentials";
          this._attemptedAuthentications.add(event.requestId);
        }
        const { username, password } = this._credentials || { username: void 0, password: void 0 };
        this._client.send("Fetch.continueWithAuth", {
          requestId: event.requestId,
          authChallengeResponse: { response, username, password }
        }).catch(debugError);
      }
      _onRequestPaused(event) {
        if (!this._userRequestInterceptionEnabled && this._protocolRequestInterceptionEnabled) {
          this._client.send("Fetch.continueRequest", {
            requestId: event.requestId
          }).catch(debugError);
        }
        const requestId = event.networkId;
        const interceptionId = event.requestId;
        if (requestId && this._requestIdToRequestWillBeSentEvent.has(requestId)) {
          const requestWillBeSentEvent = this._requestIdToRequestWillBeSentEvent.get(requestId);
          this._onRequest(requestWillBeSentEvent, interceptionId);
          this._requestIdToRequestWillBeSentEvent.delete(requestId);
        } else {
          this._requestIdToInterceptionId.set(requestId, interceptionId);
        }
      }
      _onRequest(event, interceptionId) {
        let redirectChain = [];
        if (event.redirectResponse) {
          const request2 = this._requestIdToRequest.get(event.requestId);
          if (request2) {
            this._handleRequestRedirect(request2, event.redirectResponse);
            redirectChain = request2._redirectChain;
          }
        }
        const frame = event.frameId && this._frameManager ? this._frameManager.frame(event.frameId) : null;
        const request = new Request(this._client, frame, interceptionId, this._userRequestInterceptionEnabled, event, redirectChain);
        this._requestIdToRequest.set(event.requestId, request);
        this.emit(Events.NetworkManager.Request, request);
      }
      _onRequestServedFromCache(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (request)
          request._fromMemoryCache = true;
      }
      _handleRequestRedirect(request, responsePayload) {
        const response = new Response(this._client, request, responsePayload);
        request._response = response;
        request._redirectChain.push(request);
        response._bodyLoadedPromiseFulfill.call(null, new Error("Response body is unavailable for redirect responses"));
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(Events.NetworkManager.Response, response);
        this.emit(Events.NetworkManager.RequestFinished, request);
      }
      _onResponseReceived(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        const response = new Response(this._client, request, event.response);
        request._response = response;
        this.emit(Events.NetworkManager.Response, response);
      }
      _onLoadingFinished(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        if (request.response())
          request.response()._bodyLoadedPromiseFulfill.call(null);
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(Events.NetworkManager.RequestFinished, request);
      }
      _onLoadingFailed(event) {
        const request = this._requestIdToRequest.get(event.requestId);
        if (!request)
          return;
        request._failureText = event.errorText;
        const response = request.response();
        if (response)
          response._bodyLoadedPromiseFulfill.call(null);
        this._requestIdToRequest.delete(request._requestId);
        this._attemptedAuthentications.delete(request._interceptionId);
        this.emit(Events.NetworkManager.RequestFailed, request);
      }
    };
    var Request = class {
      constructor(client, frame, interceptionId, allowInterception, event, redirectChain) {
        this._client = client;
        this._requestId = event.requestId;
        this._isNavigationRequest = event.requestId === event.loaderId && event.type === "Document";
        this._interceptionId = interceptionId;
        this._allowInterception = allowInterception;
        this._interceptionHandled = false;
        this._response = null;
        this._failureText = null;
        this._url = event.request.url;
        this._resourceType = event.type.toLowerCase();
        this._method = event.request.method;
        this._postData = event.request.postData;
        this._headers = {};
        this._frame = frame;
        this._redirectChain = redirectChain;
        for (const key of Object.keys(event.request.headers))
          this._headers[key.toLowerCase()] = event.request.headers[key];
        this._fromMemoryCache = false;
      }
      url() {
        return this._url;
      }
      resourceType() {
        return this._resourceType;
      }
      method() {
        return this._method;
      }
      postData() {
        return this._postData;
      }
      headers() {
        return this._headers;
      }
      response() {
        return this._response;
      }
      frame() {
        return this._frame;
      }
      isNavigationRequest() {
        return this._isNavigationRequest;
      }
      redirectChain() {
        return this._redirectChain.slice();
      }
      failure() {
        if (!this._failureText)
          return null;
        return {
          errorText: this._failureText
        };
      }
      continue(overrides = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._url.startsWith("data:"))
            return;
          assert(this._allowInterception, "Request Interception is not enabled!");
          assert(!this._interceptionHandled, "Request is already handled!");
          const {
            url,
            method,
            postData,
            headers
          } = overrides;
          this._interceptionHandled = true;
          yield this._client.send("Fetch.continueRequest", {
            requestId: this._interceptionId,
            url,
            method,
            postData,
            headers: headers ? headersArray(headers) : void 0
          }).catch((error) => {
            debugError(error);
          });
        });
      }
      respond(response) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._url.startsWith("data:"))
            return;
          assert(this._allowInterception, "Request Interception is not enabled!");
          assert(!this._interceptionHandled, "Request is already handled!");
          this._interceptionHandled = true;
          const responseBody = response.body && helper.isString(response.body) ? Buffer.from(response.body) : response.body || null;
          const responseHeaders = {};
          if (response.headers) {
            for (const header of Object.keys(response.headers))
              responseHeaders[header.toLowerCase()] = response.headers[header];
          }
          if (response.contentType)
            responseHeaders["content-type"] = response.contentType;
          if (responseBody && !("content-length" in responseHeaders))
            responseHeaders["content-length"] = String(Buffer.byteLength(responseBody));
          yield this._client.send("Fetch.fulfillRequest", {
            requestId: this._interceptionId,
            responseCode: response.status || 200,
            responseHeaders: headersArray(responseHeaders),
            body: responseBody ? responseBody.toString("base64") : void 0
          }).catch((error) => {
            debugError(error);
          });
        });
      }
      abort(errorCode = "failed") {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._url.startsWith("data:"))
            return;
          const errorReason = errorReasons[errorCode];
          assert(errorReason, "Unknown error code: " + errorCode);
          assert(this._allowInterception, "Request Interception is not enabled!");
          assert(!this._interceptionHandled, "Request is already handled!");
          this._interceptionHandled = true;
          yield this._client.send("Fetch.failRequest", {
            requestId: this._interceptionId,
            errorReason
          }).catch((error) => {
            debugError(error);
          });
        });
      }
    };
    var errorReasons = {
      "aborted": "Aborted",
      "accessdenied": "AccessDenied",
      "addressunreachable": "AddressUnreachable",
      "blockedbyclient": "BlockedByClient",
      "blockedbyresponse": "BlockedByResponse",
      "connectionaborted": "ConnectionAborted",
      "connectionclosed": "ConnectionClosed",
      "connectionfailed": "ConnectionFailed",
      "connectionrefused": "ConnectionRefused",
      "connectionreset": "ConnectionReset",
      "internetdisconnected": "InternetDisconnected",
      "namenotresolved": "NameNotResolved",
      "timedout": "TimedOut",
      "failed": "Failed"
    };
    var Response = class {
      constructor(client, request, responsePayload) {
        this._client = client;
        this._request = request;
        this._contentPromise = null;
        this._bodyLoadedPromise = new Promise((fulfill) => {
          this._bodyLoadedPromiseFulfill = fulfill;
        });
        this._remoteAddress = {
          ip: responsePayload.remoteIPAddress,
          port: responsePayload.remotePort
        };
        this._status = responsePayload.status;
        this._statusText = responsePayload.statusText;
        this._url = request.url();
        this._fromDiskCache = !!responsePayload.fromDiskCache;
        this._fromServiceWorker = !!responsePayload.fromServiceWorker;
        this._headers = {};
        for (const key of Object.keys(responsePayload.headers))
          this._headers[key.toLowerCase()] = responsePayload.headers[key];
        this._securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;
      }
      remoteAddress() {
        return this._remoteAddress;
      }
      url() {
        return this._url;
      }
      ok() {
        return this._status === 0 || this._status >= 200 && this._status <= 299;
      }
      status() {
        return this._status;
      }
      statusText() {
        return this._statusText;
      }
      headers() {
        return this._headers;
      }
      securityDetails() {
        return this._securityDetails;
      }
      buffer() {
        if (!this._contentPromise) {
          this._contentPromise = this._bodyLoadedPromise.then((error) => {
            return ((fn) => {
              const gen = fn.call(this);
              return new Promise((resolve, reject) => {
                function step(key, arg) {
                  let info, value;
                  try {
                    info = gen[key](arg);
                    value = info.value;
                  } catch (error2) {
                    reject(error2);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then((value2) => {
                      step("next", value2);
                    }, (err) => {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            })(function* () {
              if (error)
                throw error;
              const response = yield this._client.send("Network.getResponseBody", {
                requestId: this._request._requestId
              });
              return Buffer.from(response.body, response.base64Encoded ? "base64" : "utf8");
            });
          });
        }
        return this._contentPromise;
      }
      text() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const content = yield this.buffer();
          return content.toString("utf8");
        });
      }
      json() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const content = yield this.text();
          return JSON.parse(content);
        });
      }
      request() {
        return this._request;
      }
      fromCache() {
        return this._fromDiskCache || this._request._fromMemoryCache;
      }
      fromServiceWorker() {
        return this._fromServiceWorker;
      }
      frame() {
        return this._request.frame();
      }
    };
    var SecurityDetails = class {
      constructor(securityPayload) {
        this._subjectName = securityPayload["subjectName"];
        this._issuer = securityPayload["issuer"];
        this._validFrom = securityPayload["validFrom"];
        this._validTo = securityPayload["validTo"];
        this._protocol = securityPayload["protocol"];
      }
      subjectName() {
        return this._subjectName;
      }
      issuer() {
        return this._issuer;
      }
      validFrom() {
        return this._validFrom;
      }
      validTo() {
        return this._validTo;
      }
      protocol() {
        return this._protocol;
      }
    };
    function headersArray(headers) {
      const result = [];
      for (const name in headers)
        result.push({ name, value: headers[name] + "" });
      return result;
    }
    module2.exports = { Request, Response, NetworkManager, SecurityDetails };
  }
});

// node_modules/puppeteer/node6/lib/FrameManager.js
var require_FrameManager2 = __commonJS({
  "node_modules/puppeteer/node6/lib/FrameManager.js"(exports, module2) {
    var EventEmitter = require("events");
    var { helper, assert } = require_helper2();
    var { Events } = require_Events2();
    var { ExecutionContext, EVALUATION_SCRIPT_URL } = require_ExecutionContext2();
    var { LifecycleWatcher } = require_LifecycleWatcher2();
    var { DOMWorld } = require_DOMWorld2();
    var { NetworkManager } = require_NetworkManager2();
    var UTILITY_WORLD_NAME = "__puppeteer_utility_world__";
    var FrameManager = class extends EventEmitter {
      constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {
        super();
        this._client = client;
        this._page = page;
        this._networkManager = new NetworkManager(client, ignoreHTTPSErrors);
        this._networkManager.setFrameManager(this);
        this._timeoutSettings = timeoutSettings;
        this._frames = new Map();
        this._contextIdToContext = new Map();
        this._isolatedWorlds = new Set();
        this._client.on("Page.frameAttached", (event) => this._onFrameAttached(event.frameId, event.parentFrameId));
        this._client.on("Page.frameNavigated", (event) => this._onFrameNavigated(event.frame));
        this._client.on("Page.navigatedWithinDocument", (event) => this._onFrameNavigatedWithinDocument(event.frameId, event.url));
        this._client.on("Page.frameDetached", (event) => this._onFrameDetached(event.frameId));
        this._client.on("Page.frameStoppedLoading", (event) => this._onFrameStoppedLoading(event.frameId));
        this._client.on("Runtime.executionContextCreated", (event) => this._onExecutionContextCreated(event.context));
        this._client.on("Runtime.executionContextDestroyed", (event) => this._onExecutionContextDestroyed(event.executionContextId));
        this._client.on("Runtime.executionContextsCleared", (event) => this._onExecutionContextsCleared());
        this._client.on("Page.lifecycleEvent", (event) => this._onLifecycleEvent(event));
      }
      initialize() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const [, { frameTree }] = yield Promise.all([
            this._client.send("Page.enable"),
            this._client.send("Page.getFrameTree")
          ]);
          this._handleFrameTree(frameTree);
          yield Promise.all([
            this._client.send("Page.setLifecycleEventsEnabled", { enabled: true }),
            this._client.send("Runtime.enable", {}).then(() => this._ensureIsolatedWorld(UTILITY_WORLD_NAME)),
            this._networkManager.initialize()
          ]);
        });
      }
      networkManager() {
        return this._networkManager;
      }
      navigateFrame(frame, url, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assertNoLegacyNavigationOptions(options);
          const {
            referer = this._networkManager.extraHTTPHeaders()["referer"],
            waitUntil = ["load"],
            timeout = this._timeoutSettings.navigationTimeout()
          } = options;
          const watcher = new LifecycleWatcher(this, frame, waitUntil, timeout);
          let ensureNewDocumentNavigation = false;
          let error = yield Promise.race([
            navigate(this._client, url, referer, frame._id),
            watcher.timeoutOrTerminationPromise()
          ]);
          if (!error) {
            error = yield Promise.race([
              watcher.timeoutOrTerminationPromise(),
              ensureNewDocumentNavigation ? watcher.newDocumentNavigationPromise() : watcher.sameDocumentNavigationPromise()
            ]);
          }
          watcher.dispose();
          if (error)
            throw error;
          return watcher.navigationResponse();
          function navigate(client, url2, referrer, frameId) {
            return ((fn) => {
              const gen = fn.call(this);
              return new Promise((resolve, reject) => {
                function step(key, arg) {
                  let info, value;
                  try {
                    info = gen[key](arg);
                    value = info.value;
                  } catch (error2) {
                    reject(error2);
                    return;
                  }
                  if (info.done) {
                    resolve(value);
                  } else {
                    return Promise.resolve(value).then((value2) => {
                      step("next", value2);
                    }, (err) => {
                      step("throw", err);
                    });
                  }
                }
                return step("next");
              });
            })(function* () {
              try {
                const response = yield client.send("Page.navigate", { url: url2, referrer, frameId });
                ensureNewDocumentNavigation = !!response.loaderId;
                return response.errorText ? new Error(`${response.errorText} at ${url2}`) : null;
              } catch (error2) {
                return error2;
              }
            });
          }
        });
      }
      waitForFrameNavigation(frame, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assertNoLegacyNavigationOptions(options);
          const {
            waitUntil = ["load"],
            timeout = this._timeoutSettings.navigationTimeout()
          } = options;
          const watcher = new LifecycleWatcher(this, frame, waitUntil, timeout);
          const error = yield Promise.race([
            watcher.timeoutOrTerminationPromise(),
            watcher.sameDocumentNavigationPromise(),
            watcher.newDocumentNavigationPromise()
          ]);
          watcher.dispose();
          if (error)
            throw error;
          return watcher.navigationResponse();
        });
      }
      _onLifecycleEvent(event) {
        const frame = this._frames.get(event.frameId);
        if (!frame)
          return;
        frame._onLifecycleEvent(event.loaderId, event.name);
        this.emit(Events.FrameManager.LifecycleEvent, frame);
      }
      _onFrameStoppedLoading(frameId) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._onLoadingStopped();
        this.emit(Events.FrameManager.LifecycleEvent, frame);
      }
      _handleFrameTree(frameTree) {
        if (frameTree.frame.parentId)
          this._onFrameAttached(frameTree.frame.id, frameTree.frame.parentId);
        this._onFrameNavigated(frameTree.frame);
        if (!frameTree.childFrames)
          return;
        for (const child of frameTree.childFrames)
          this._handleFrameTree(child);
      }
      page() {
        return this._page;
      }
      mainFrame() {
        return this._mainFrame;
      }
      frames() {
        return Array.from(this._frames.values());
      }
      frame(frameId) {
        return this._frames.get(frameId) || null;
      }
      _onFrameAttached(frameId, parentFrameId) {
        if (this._frames.has(frameId))
          return;
        assert(parentFrameId);
        const parentFrame = this._frames.get(parentFrameId);
        const frame = new Frame(this, this._client, parentFrame, frameId);
        this._frames.set(frame._id, frame);
        this.emit(Events.FrameManager.FrameAttached, frame);
      }
      _onFrameNavigated(framePayload) {
        const isMainFrame = !framePayload.parentId;
        let frame = isMainFrame ? this._mainFrame : this._frames.get(framePayload.id);
        assert(isMainFrame || frame, "We either navigate top level or have old version of the navigated frame");
        if (frame) {
          for (const child of frame.childFrames())
            this._removeFramesRecursively(child);
        }
        if (isMainFrame) {
          if (frame) {
            this._frames.delete(frame._id);
            frame._id = framePayload.id;
          } else {
            frame = new Frame(this, this._client, null, framePayload.id);
          }
          this._frames.set(framePayload.id, frame);
          this._mainFrame = frame;
        }
        frame._navigated(framePayload);
        this.emit(Events.FrameManager.FrameNavigated, frame);
      }
      _ensureIsolatedWorld(name) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._isolatedWorlds.has(name))
            return;
          this._isolatedWorlds.add(name);
          yield this._client.send("Page.addScriptToEvaluateOnNewDocument", {
            source: `//# sourceURL=${EVALUATION_SCRIPT_URL}`,
            worldName: name
          }), yield Promise.all(this.frames().map((frame) => this._client.send("Page.createIsolatedWorld", {
            frameId: frame._id,
            grantUniveralAccess: true,
            worldName: name
          })));
        });
      }
      _onFrameNavigatedWithinDocument(frameId, url) {
        const frame = this._frames.get(frameId);
        if (!frame)
          return;
        frame._navigatedWithinDocument(url);
        this.emit(Events.FrameManager.FrameNavigatedWithinDocument, frame);
        this.emit(Events.FrameManager.FrameNavigated, frame);
      }
      _onFrameDetached(frameId) {
        const frame = this._frames.get(frameId);
        if (frame)
          this._removeFramesRecursively(frame);
      }
      _onExecutionContextCreated(contextPayload) {
        const frameId = contextPayload.auxData ? contextPayload.auxData.frameId : null;
        const frame = this._frames.get(frameId) || null;
        let world = null;
        if (frame) {
          if (contextPayload.auxData && !!contextPayload.auxData["isDefault"]) {
            world = frame._mainWorld;
          } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame._secondaryWorld._hasContext()) {
            world = frame._secondaryWorld;
          }
        }
        if (contextPayload.auxData && contextPayload.auxData["type"] === "isolated")
          this._isolatedWorlds.add(contextPayload.name);
        const context = new ExecutionContext(this._client, contextPayload, world);
        if (world)
          world._setContext(context);
        this._contextIdToContext.set(contextPayload.id, context);
      }
      _onExecutionContextDestroyed(executionContextId) {
        const context = this._contextIdToContext.get(executionContextId);
        if (!context)
          return;
        this._contextIdToContext.delete(executionContextId);
        if (context._world)
          context._world._setContext(null);
      }
      _onExecutionContextsCleared() {
        for (const context of this._contextIdToContext.values()) {
          if (context._world)
            context._world._setContext(null);
        }
        this._contextIdToContext.clear();
      }
      executionContextById(contextId) {
        const context = this._contextIdToContext.get(contextId);
        assert(context, "INTERNAL ERROR: missing context with id = " + contextId);
        return context;
      }
      _removeFramesRecursively(frame) {
        for (const child of frame.childFrames())
          this._removeFramesRecursively(child);
        frame._detach();
        this._frames.delete(frame._id);
        this.emit(Events.FrameManager.FrameDetached, frame);
      }
    };
    var Frame = class {
      constructor(frameManager, client, parentFrame, frameId) {
        this._frameManager = frameManager;
        this._client = client;
        this._parentFrame = parentFrame;
        this._url = "";
        this._id = frameId;
        this._detached = false;
        this._loaderId = "";
        this._lifecycleEvents = new Set();
        this._mainWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._secondaryWorld = new DOMWorld(frameManager, this, frameManager._timeoutSettings);
        this._childFrames = new Set();
        if (this._parentFrame)
          this._parentFrame._childFrames.add(this);
      }
      goto(url, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._frameManager.navigateFrame(this, url, options);
        });
      }
      waitForNavigation(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._frameManager.waitForFrameNavigation(this, options);
        });
      }
      executionContext() {
        return this._mainWorld.executionContext();
      }
      evaluateHandle(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.evaluateHandle(pageFunction, ...args);
        });
      }
      evaluate(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.evaluate(pageFunction, ...args);
        });
      }
      $(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.$(selector);
        });
      }
      $x(expression) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.$x(expression);
        });
      }
      $eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.$eval(selector, pageFunction, ...args);
        });
      }
      $$eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.$$eval(selector, pageFunction, ...args);
        });
      }
      $$(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.$$(selector);
        });
      }
      content() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._secondaryWorld.content();
        });
      }
      setContent(html, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._secondaryWorld.setContent(html, options);
        });
      }
      name() {
        return this._name || "";
      }
      url() {
        return this._url;
      }
      parentFrame() {
        return this._parentFrame;
      }
      childFrames() {
        return Array.from(this._childFrames);
      }
      isDetached() {
        return this._detached;
      }
      addScriptTag(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.addScriptTag(options);
        });
      }
      addStyleTag(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.addStyleTag(options);
        });
      }
      click(selector, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._secondaryWorld.click(selector, options);
        });
      }
      focus(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._secondaryWorld.focus(selector);
        });
      }
      hover(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._secondaryWorld.hover(selector);
        });
      }
      select(selector, ...values) {
        return this._secondaryWorld.select(selector, ...values);
      }
      tap(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._secondaryWorld.tap(selector);
        });
      }
      type(selector, text, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._mainWorld.type(selector, text, options);
        });
      }
      waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        const xPathPattern = "//";
        if (helper.isString(selectorOrFunctionOrTimeout)) {
          const string = selectorOrFunctionOrTimeout;
          if (string.startsWith(xPathPattern))
            return this.waitForXPath(string, options);
          return this.waitForSelector(string, options);
        }
        if (helper.isNumber(selectorOrFunctionOrTimeout))
          return new Promise((fulfill) => setTimeout(fulfill, selectorOrFunctionOrTimeout));
        if (typeof selectorOrFunctionOrTimeout === "function")
          return this.waitForFunction(selectorOrFunctionOrTimeout, options, ...args);
        return Promise.reject(new Error("Unsupported target type: " + typeof selectorOrFunctionOrTimeout));
      }
      waitForSelector(selector, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this._secondaryWorld.waitForSelector(selector, options);
          if (!handle)
            return null;
          const mainExecutionContext = yield this._mainWorld.executionContext();
          const result = yield mainExecutionContext._adoptElementHandle(handle);
          yield handle.dispose();
          return result;
        });
      }
      waitForXPath(xpath, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const handle = yield this._secondaryWorld.waitForXPath(xpath, options);
          if (!handle)
            return null;
          const mainExecutionContext = yield this._mainWorld.executionContext();
          const result = yield mainExecutionContext._adoptElementHandle(handle);
          yield handle.dispose();
          return result;
        });
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        return this._mainWorld.waitForFunction(pageFunction, options, ...args);
      }
      title() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._secondaryWorld.title();
        });
      }
      _navigated(framePayload) {
        this._name = framePayload.name;
        this._navigationURL = framePayload.url;
        this._url = framePayload.url;
      }
      _navigatedWithinDocument(url) {
        this._url = url;
      }
      _onLifecycleEvent(loaderId, name) {
        if (name === "init") {
          this._loaderId = loaderId;
          this._lifecycleEvents.clear();
        }
        this._lifecycleEvents.add(name);
      }
      _onLoadingStopped() {
        this._lifecycleEvents.add("DOMContentLoaded");
        this._lifecycleEvents.add("load");
      }
      _detach() {
        this._detached = true;
        this._mainWorld._detach();
        this._secondaryWorld._detach();
        if (this._parentFrame)
          this._parentFrame._childFrames.delete(this);
        this._parentFrame = null;
      }
    };
    function assertNoLegacyNavigationOptions(options) {
      assert(options["networkIdleTimeout"] === void 0, "ERROR: networkIdleTimeout option is no longer supported.");
      assert(options["networkIdleInflight"] === void 0, "ERROR: networkIdleInflight option is no longer supported.");
      assert(options.waitUntil !== "networkidle", 'ERROR: "networkidle" option is no longer supported. Use "networkidle2" instead');
    }
    module2.exports = { FrameManager, Frame };
  }
});

// node_modules/puppeteer/node6/lib/USKeyboardLayout.js
var require_USKeyboardLayout2 = __commonJS({
  "node_modules/puppeteer/node6/lib/USKeyboardLayout.js"(exports, module2) {
    module2.exports = {
      "0": { "keyCode": 48, "key": "0", "code": "Digit0" },
      "1": { "keyCode": 49, "key": "1", "code": "Digit1" },
      "2": { "keyCode": 50, "key": "2", "code": "Digit2" },
      "3": { "keyCode": 51, "key": "3", "code": "Digit3" },
      "4": { "keyCode": 52, "key": "4", "code": "Digit4" },
      "5": { "keyCode": 53, "key": "5", "code": "Digit5" },
      "6": { "keyCode": 54, "key": "6", "code": "Digit6" },
      "7": { "keyCode": 55, "key": "7", "code": "Digit7" },
      "8": { "keyCode": 56, "key": "8", "code": "Digit8" },
      "9": { "keyCode": 57, "key": "9", "code": "Digit9" },
      "Power": { "key": "Power", "code": "Power" },
      "Eject": { "key": "Eject", "code": "Eject" },
      "Abort": { "keyCode": 3, "code": "Abort", "key": "Cancel" },
      "Help": { "keyCode": 6, "code": "Help", "key": "Help" },
      "Backspace": { "keyCode": 8, "code": "Backspace", "key": "Backspace" },
      "Tab": { "keyCode": 9, "code": "Tab", "key": "Tab" },
      "Numpad5": { "keyCode": 12, "shiftKeyCode": 101, "key": "Clear", "code": "Numpad5", "shiftKey": "5", "location": 3 },
      "NumpadEnter": { "keyCode": 13, "code": "NumpadEnter", "key": "Enter", "text": "\r", "location": 3 },
      "Enter": { "keyCode": 13, "code": "Enter", "key": "Enter", "text": "\r" },
      "\r": { "keyCode": 13, "code": "Enter", "key": "Enter", "text": "\r" },
      "\n": { "keyCode": 13, "code": "Enter", "key": "Enter", "text": "\r" },
      "ShiftLeft": { "keyCode": 16, "code": "ShiftLeft", "key": "Shift", "location": 1 },
      "ShiftRight": { "keyCode": 16, "code": "ShiftRight", "key": "Shift", "location": 2 },
      "ControlLeft": { "keyCode": 17, "code": "ControlLeft", "key": "Control", "location": 1 },
      "ControlRight": { "keyCode": 17, "code": "ControlRight", "key": "Control", "location": 2 },
      "AltLeft": { "keyCode": 18, "code": "AltLeft", "key": "Alt", "location": 1 },
      "AltRight": { "keyCode": 18, "code": "AltRight", "key": "Alt", "location": 2 },
      "Pause": { "keyCode": 19, "code": "Pause", "key": "Pause" },
      "CapsLock": { "keyCode": 20, "code": "CapsLock", "key": "CapsLock" },
      "Escape": { "keyCode": 27, "code": "Escape", "key": "Escape" },
      "Convert": { "keyCode": 28, "code": "Convert", "key": "Convert" },
      "NonConvert": { "keyCode": 29, "code": "NonConvert", "key": "NonConvert" },
      "Space": { "keyCode": 32, "code": "Space", "key": " " },
      "Numpad9": { "keyCode": 33, "shiftKeyCode": 105, "key": "PageUp", "code": "Numpad9", "shiftKey": "9", "location": 3 },
      "PageUp": { "keyCode": 33, "code": "PageUp", "key": "PageUp" },
      "Numpad3": { "keyCode": 34, "shiftKeyCode": 99, "key": "PageDown", "code": "Numpad3", "shiftKey": "3", "location": 3 },
      "PageDown": { "keyCode": 34, "code": "PageDown", "key": "PageDown" },
      "End": { "keyCode": 35, "code": "End", "key": "End" },
      "Numpad1": { "keyCode": 35, "shiftKeyCode": 97, "key": "End", "code": "Numpad1", "shiftKey": "1", "location": 3 },
      "Home": { "keyCode": 36, "code": "Home", "key": "Home" },
      "Numpad7": { "keyCode": 36, "shiftKeyCode": 103, "key": "Home", "code": "Numpad7", "shiftKey": "7", "location": 3 },
      "ArrowLeft": { "keyCode": 37, "code": "ArrowLeft", "key": "ArrowLeft" },
      "Numpad4": { "keyCode": 37, "shiftKeyCode": 100, "key": "ArrowLeft", "code": "Numpad4", "shiftKey": "4", "location": 3 },
      "Numpad8": { "keyCode": 38, "shiftKeyCode": 104, "key": "ArrowUp", "code": "Numpad8", "shiftKey": "8", "location": 3 },
      "ArrowUp": { "keyCode": 38, "code": "ArrowUp", "key": "ArrowUp" },
      "ArrowRight": { "keyCode": 39, "code": "ArrowRight", "key": "ArrowRight" },
      "Numpad6": { "keyCode": 39, "shiftKeyCode": 102, "key": "ArrowRight", "code": "Numpad6", "shiftKey": "6", "location": 3 },
      "Numpad2": { "keyCode": 40, "shiftKeyCode": 98, "key": "ArrowDown", "code": "Numpad2", "shiftKey": "2", "location": 3 },
      "ArrowDown": { "keyCode": 40, "code": "ArrowDown", "key": "ArrowDown" },
      "Select": { "keyCode": 41, "code": "Select", "key": "Select" },
      "Open": { "keyCode": 43, "code": "Open", "key": "Execute" },
      "PrintScreen": { "keyCode": 44, "code": "PrintScreen", "key": "PrintScreen" },
      "Insert": { "keyCode": 45, "code": "Insert", "key": "Insert" },
      "Numpad0": { "keyCode": 45, "shiftKeyCode": 96, "key": "Insert", "code": "Numpad0", "shiftKey": "0", "location": 3 },
      "Delete": { "keyCode": 46, "code": "Delete", "key": "Delete" },
      "NumpadDecimal": { "keyCode": 46, "shiftKeyCode": 110, "code": "NumpadDecimal", "key": "\0", "shiftKey": ".", "location": 3 },
      "Digit0": { "keyCode": 48, "code": "Digit0", "shiftKey": ")", "key": "0" },
      "Digit1": { "keyCode": 49, "code": "Digit1", "shiftKey": "!", "key": "1" },
      "Digit2": { "keyCode": 50, "code": "Digit2", "shiftKey": "@", "key": "2" },
      "Digit3": { "keyCode": 51, "code": "Digit3", "shiftKey": "#", "key": "3" },
      "Digit4": { "keyCode": 52, "code": "Digit4", "shiftKey": "$", "key": "4" },
      "Digit5": { "keyCode": 53, "code": "Digit5", "shiftKey": "%", "key": "5" },
      "Digit6": { "keyCode": 54, "code": "Digit6", "shiftKey": "^", "key": "6" },
      "Digit7": { "keyCode": 55, "code": "Digit7", "shiftKey": "&", "key": "7" },
      "Digit8": { "keyCode": 56, "code": "Digit8", "shiftKey": "*", "key": "8" },
      "Digit9": { "keyCode": 57, "code": "Digit9", "shiftKey": "(", "key": "9" },
      "KeyA": { "keyCode": 65, "code": "KeyA", "shiftKey": "A", "key": "a" },
      "KeyB": { "keyCode": 66, "code": "KeyB", "shiftKey": "B", "key": "b" },
      "KeyC": { "keyCode": 67, "code": "KeyC", "shiftKey": "C", "key": "c" },
      "KeyD": { "keyCode": 68, "code": "KeyD", "shiftKey": "D", "key": "d" },
      "KeyE": { "keyCode": 69, "code": "KeyE", "shiftKey": "E", "key": "e" },
      "KeyF": { "keyCode": 70, "code": "KeyF", "shiftKey": "F", "key": "f" },
      "KeyG": { "keyCode": 71, "code": "KeyG", "shiftKey": "G", "key": "g" },
      "KeyH": { "keyCode": 72, "code": "KeyH", "shiftKey": "H", "key": "h" },
      "KeyI": { "keyCode": 73, "code": "KeyI", "shiftKey": "I", "key": "i" },
      "KeyJ": { "keyCode": 74, "code": "KeyJ", "shiftKey": "J", "key": "j" },
      "KeyK": { "keyCode": 75, "code": "KeyK", "shiftKey": "K", "key": "k" },
      "KeyL": { "keyCode": 76, "code": "KeyL", "shiftKey": "L", "key": "l" },
      "KeyM": { "keyCode": 77, "code": "KeyM", "shiftKey": "M", "key": "m" },
      "KeyN": { "keyCode": 78, "code": "KeyN", "shiftKey": "N", "key": "n" },
      "KeyO": { "keyCode": 79, "code": "KeyO", "shiftKey": "O", "key": "o" },
      "KeyP": { "keyCode": 80, "code": "KeyP", "shiftKey": "P", "key": "p" },
      "KeyQ": { "keyCode": 81, "code": "KeyQ", "shiftKey": "Q", "key": "q" },
      "KeyR": { "keyCode": 82, "code": "KeyR", "shiftKey": "R", "key": "r" },
      "KeyS": { "keyCode": 83, "code": "KeyS", "shiftKey": "S", "key": "s" },
      "KeyT": { "keyCode": 84, "code": "KeyT", "shiftKey": "T", "key": "t" },
      "KeyU": { "keyCode": 85, "code": "KeyU", "shiftKey": "U", "key": "u" },
      "KeyV": { "keyCode": 86, "code": "KeyV", "shiftKey": "V", "key": "v" },
      "KeyW": { "keyCode": 87, "code": "KeyW", "shiftKey": "W", "key": "w" },
      "KeyX": { "keyCode": 88, "code": "KeyX", "shiftKey": "X", "key": "x" },
      "KeyY": { "keyCode": 89, "code": "KeyY", "shiftKey": "Y", "key": "y" },
      "KeyZ": { "keyCode": 90, "code": "KeyZ", "shiftKey": "Z", "key": "z" },
      "MetaLeft": { "keyCode": 91, "code": "MetaLeft", "key": "Meta", "location": 1 },
      "MetaRight": { "keyCode": 92, "code": "MetaRight", "key": "Meta", "location": 2 },
      "ContextMenu": { "keyCode": 93, "code": "ContextMenu", "key": "ContextMenu" },
      "NumpadMultiply": { "keyCode": 106, "code": "NumpadMultiply", "key": "*", "location": 3 },
      "NumpadAdd": { "keyCode": 107, "code": "NumpadAdd", "key": "+", "location": 3 },
      "NumpadSubtract": { "keyCode": 109, "code": "NumpadSubtract", "key": "-", "location": 3 },
      "NumpadDivide": { "keyCode": 111, "code": "NumpadDivide", "key": "/", "location": 3 },
      "F1": { "keyCode": 112, "code": "F1", "key": "F1" },
      "F2": { "keyCode": 113, "code": "F2", "key": "F2" },
      "F3": { "keyCode": 114, "code": "F3", "key": "F3" },
      "F4": { "keyCode": 115, "code": "F4", "key": "F4" },
      "F5": { "keyCode": 116, "code": "F5", "key": "F5" },
      "F6": { "keyCode": 117, "code": "F6", "key": "F6" },
      "F7": { "keyCode": 118, "code": "F7", "key": "F7" },
      "F8": { "keyCode": 119, "code": "F8", "key": "F8" },
      "F9": { "keyCode": 120, "code": "F9", "key": "F9" },
      "F10": { "keyCode": 121, "code": "F10", "key": "F10" },
      "F11": { "keyCode": 122, "code": "F11", "key": "F11" },
      "F12": { "keyCode": 123, "code": "F12", "key": "F12" },
      "F13": { "keyCode": 124, "code": "F13", "key": "F13" },
      "F14": { "keyCode": 125, "code": "F14", "key": "F14" },
      "F15": { "keyCode": 126, "code": "F15", "key": "F15" },
      "F16": { "keyCode": 127, "code": "F16", "key": "F16" },
      "F17": { "keyCode": 128, "code": "F17", "key": "F17" },
      "F18": { "keyCode": 129, "code": "F18", "key": "F18" },
      "F19": { "keyCode": 130, "code": "F19", "key": "F19" },
      "F20": { "keyCode": 131, "code": "F20", "key": "F20" },
      "F21": { "keyCode": 132, "code": "F21", "key": "F21" },
      "F22": { "keyCode": 133, "code": "F22", "key": "F22" },
      "F23": { "keyCode": 134, "code": "F23", "key": "F23" },
      "F24": { "keyCode": 135, "code": "F24", "key": "F24" },
      "NumLock": { "keyCode": 144, "code": "NumLock", "key": "NumLock" },
      "ScrollLock": { "keyCode": 145, "code": "ScrollLock", "key": "ScrollLock" },
      "AudioVolumeMute": { "keyCode": 173, "code": "AudioVolumeMute", "key": "AudioVolumeMute" },
      "AudioVolumeDown": { "keyCode": 174, "code": "AudioVolumeDown", "key": "AudioVolumeDown" },
      "AudioVolumeUp": { "keyCode": 175, "code": "AudioVolumeUp", "key": "AudioVolumeUp" },
      "MediaTrackNext": { "keyCode": 176, "code": "MediaTrackNext", "key": "MediaTrackNext" },
      "MediaTrackPrevious": { "keyCode": 177, "code": "MediaTrackPrevious", "key": "MediaTrackPrevious" },
      "MediaStop": { "keyCode": 178, "code": "MediaStop", "key": "MediaStop" },
      "MediaPlayPause": { "keyCode": 179, "code": "MediaPlayPause", "key": "MediaPlayPause" },
      "Semicolon": { "keyCode": 186, "code": "Semicolon", "shiftKey": ":", "key": ";" },
      "Equal": { "keyCode": 187, "code": "Equal", "shiftKey": "+", "key": "=" },
      "NumpadEqual": { "keyCode": 187, "code": "NumpadEqual", "key": "=", "location": 3 },
      "Comma": { "keyCode": 188, "code": "Comma", "shiftKey": "<", "key": "," },
      "Minus": { "keyCode": 189, "code": "Minus", "shiftKey": "_", "key": "-" },
      "Period": { "keyCode": 190, "code": "Period", "shiftKey": ">", "key": "." },
      "Slash": { "keyCode": 191, "code": "Slash", "shiftKey": "?", "key": "/" },
      "Backquote": { "keyCode": 192, "code": "Backquote", "shiftKey": "~", "key": "`" },
      "BracketLeft": { "keyCode": 219, "code": "BracketLeft", "shiftKey": "{", "key": "[" },
      "Backslash": { "keyCode": 220, "code": "Backslash", "shiftKey": "|", "key": "\\" },
      "BracketRight": { "keyCode": 221, "code": "BracketRight", "shiftKey": "}", "key": "]" },
      "Quote": { "keyCode": 222, "code": "Quote", "shiftKey": '"', "key": "'" },
      "AltGraph": { "keyCode": 225, "code": "AltGraph", "key": "AltGraph" },
      "Props": { "keyCode": 247, "code": "Props", "key": "CrSel" },
      "Cancel": { "keyCode": 3, "key": "Cancel", "code": "Abort" },
      "Clear": { "keyCode": 12, "key": "Clear", "code": "Numpad5", "location": 3 },
      "Shift": { "keyCode": 16, "key": "Shift", "code": "ShiftLeft", "location": 1 },
      "Control": { "keyCode": 17, "key": "Control", "code": "ControlLeft", "location": 1 },
      "Alt": { "keyCode": 18, "key": "Alt", "code": "AltLeft", "location": 1 },
      "Accept": { "keyCode": 30, "key": "Accept" },
      "ModeChange": { "keyCode": 31, "key": "ModeChange" },
      " ": { "keyCode": 32, "key": " ", "code": "Space" },
      "Print": { "keyCode": 42, "key": "Print" },
      "Execute": { "keyCode": 43, "key": "Execute", "code": "Open" },
      "\0": { "keyCode": 46, "key": "\0", "code": "NumpadDecimal", "location": 3 },
      "a": { "keyCode": 65, "key": "a", "code": "KeyA" },
      "b": { "keyCode": 66, "key": "b", "code": "KeyB" },
      "c": { "keyCode": 67, "key": "c", "code": "KeyC" },
      "d": { "keyCode": 68, "key": "d", "code": "KeyD" },
      "e": { "keyCode": 69, "key": "e", "code": "KeyE" },
      "f": { "keyCode": 70, "key": "f", "code": "KeyF" },
      "g": { "keyCode": 71, "key": "g", "code": "KeyG" },
      "h": { "keyCode": 72, "key": "h", "code": "KeyH" },
      "i": { "keyCode": 73, "key": "i", "code": "KeyI" },
      "j": { "keyCode": 74, "key": "j", "code": "KeyJ" },
      "k": { "keyCode": 75, "key": "k", "code": "KeyK" },
      "l": { "keyCode": 76, "key": "l", "code": "KeyL" },
      "m": { "keyCode": 77, "key": "m", "code": "KeyM" },
      "n": { "keyCode": 78, "key": "n", "code": "KeyN" },
      "o": { "keyCode": 79, "key": "o", "code": "KeyO" },
      "p": { "keyCode": 80, "key": "p", "code": "KeyP" },
      "q": { "keyCode": 81, "key": "q", "code": "KeyQ" },
      "r": { "keyCode": 82, "key": "r", "code": "KeyR" },
      "s": { "keyCode": 83, "key": "s", "code": "KeyS" },
      "t": { "keyCode": 84, "key": "t", "code": "KeyT" },
      "u": { "keyCode": 85, "key": "u", "code": "KeyU" },
      "v": { "keyCode": 86, "key": "v", "code": "KeyV" },
      "w": { "keyCode": 87, "key": "w", "code": "KeyW" },
      "x": { "keyCode": 88, "key": "x", "code": "KeyX" },
      "y": { "keyCode": 89, "key": "y", "code": "KeyY" },
      "z": { "keyCode": 90, "key": "z", "code": "KeyZ" },
      "Meta": { "keyCode": 91, "key": "Meta", "code": "MetaLeft", "location": 1 },
      "*": { "keyCode": 106, "key": "*", "code": "NumpadMultiply", "location": 3 },
      "+": { "keyCode": 107, "key": "+", "code": "NumpadAdd", "location": 3 },
      "-": { "keyCode": 109, "key": "-", "code": "NumpadSubtract", "location": 3 },
      "/": { "keyCode": 111, "key": "/", "code": "NumpadDivide", "location": 3 },
      ";": { "keyCode": 186, "key": ";", "code": "Semicolon" },
      "=": { "keyCode": 187, "key": "=", "code": "Equal" },
      ",": { "keyCode": 188, "key": ",", "code": "Comma" },
      ".": { "keyCode": 190, "key": ".", "code": "Period" },
      "`": { "keyCode": 192, "key": "`", "code": "Backquote" },
      "[": { "keyCode": 219, "key": "[", "code": "BracketLeft" },
      "\\": { "keyCode": 220, "key": "\\", "code": "Backslash" },
      "]": { "keyCode": 221, "key": "]", "code": "BracketRight" },
      "'": { "keyCode": 222, "key": "'", "code": "Quote" },
      "Attn": { "keyCode": 246, "key": "Attn" },
      "CrSel": { "keyCode": 247, "key": "CrSel", "code": "Props" },
      "ExSel": { "keyCode": 248, "key": "ExSel" },
      "EraseEof": { "keyCode": 249, "key": "EraseEof" },
      "Play": { "keyCode": 250, "key": "Play" },
      "ZoomOut": { "keyCode": 251, "key": "ZoomOut" },
      ")": { "keyCode": 48, "key": ")", "code": "Digit0" },
      "!": { "keyCode": 49, "key": "!", "code": "Digit1" },
      "@": { "keyCode": 50, "key": "@", "code": "Digit2" },
      "#": { "keyCode": 51, "key": "#", "code": "Digit3" },
      "$": { "keyCode": 52, "key": "$", "code": "Digit4" },
      "%": { "keyCode": 53, "key": "%", "code": "Digit5" },
      "^": { "keyCode": 54, "key": "^", "code": "Digit6" },
      "&": { "keyCode": 55, "key": "&", "code": "Digit7" },
      "(": { "keyCode": 57, "key": "(", "code": "Digit9" },
      "A": { "keyCode": 65, "key": "A", "code": "KeyA" },
      "B": { "keyCode": 66, "key": "B", "code": "KeyB" },
      "C": { "keyCode": 67, "key": "C", "code": "KeyC" },
      "D": { "keyCode": 68, "key": "D", "code": "KeyD" },
      "E": { "keyCode": 69, "key": "E", "code": "KeyE" },
      "F": { "keyCode": 70, "key": "F", "code": "KeyF" },
      "G": { "keyCode": 71, "key": "G", "code": "KeyG" },
      "H": { "keyCode": 72, "key": "H", "code": "KeyH" },
      "I": { "keyCode": 73, "key": "I", "code": "KeyI" },
      "J": { "keyCode": 74, "key": "J", "code": "KeyJ" },
      "K": { "keyCode": 75, "key": "K", "code": "KeyK" },
      "L": { "keyCode": 76, "key": "L", "code": "KeyL" },
      "M": { "keyCode": 77, "key": "M", "code": "KeyM" },
      "N": { "keyCode": 78, "key": "N", "code": "KeyN" },
      "O": { "keyCode": 79, "key": "O", "code": "KeyO" },
      "P": { "keyCode": 80, "key": "P", "code": "KeyP" },
      "Q": { "keyCode": 81, "key": "Q", "code": "KeyQ" },
      "R": { "keyCode": 82, "key": "R", "code": "KeyR" },
      "S": { "keyCode": 83, "key": "S", "code": "KeyS" },
      "T": { "keyCode": 84, "key": "T", "code": "KeyT" },
      "U": { "keyCode": 85, "key": "U", "code": "KeyU" },
      "V": { "keyCode": 86, "key": "V", "code": "KeyV" },
      "W": { "keyCode": 87, "key": "W", "code": "KeyW" },
      "X": { "keyCode": 88, "key": "X", "code": "KeyX" },
      "Y": { "keyCode": 89, "key": "Y", "code": "KeyY" },
      "Z": { "keyCode": 90, "key": "Z", "code": "KeyZ" },
      ":": { "keyCode": 186, "key": ":", "code": "Semicolon" },
      "<": { "keyCode": 188, "key": "<", "code": "Comma" },
      "_": { "keyCode": 189, "key": "_", "code": "Minus" },
      ">": { "keyCode": 190, "key": ">", "code": "Period" },
      "?": { "keyCode": 191, "key": "?", "code": "Slash" },
      "~": { "keyCode": 192, "key": "~", "code": "Backquote" },
      "{": { "keyCode": 219, "key": "{", "code": "BracketLeft" },
      "|": { "keyCode": 220, "key": "|", "code": "Backslash" },
      "}": { "keyCode": 221, "key": "}", "code": "BracketRight" },
      '"': { "keyCode": 222, "key": '"', "code": "Quote" }
    };
  }
});

// node_modules/puppeteer/node6/lib/Input.js
var require_Input2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Input.js"(exports, module2) {
    var { assert } = require_helper2();
    var keyDefinitions = require_USKeyboardLayout2();
    var Keyboard = class {
      constructor(client) {
        this._client = client;
        this._modifiers = 0;
        this._pressedKeys = new Set();
      }
      down(key, options = { text: void 0 }) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key2, arg) {
              let info, value;
              try {
                info = gen[key2](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const description = this._keyDescriptionForString(key);
          const autoRepeat = this._pressedKeys.has(description.code);
          this._pressedKeys.add(description.code);
          this._modifiers |= this._modifierBit(description.key);
          const text = options.text === void 0 ? description.text : options.text;
          yield this._client.send("Input.dispatchKeyEvent", {
            type: text ? "keyDown" : "rawKeyDown",
            modifiers: this._modifiers,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            key: description.key,
            text,
            unmodifiedText: text,
            autoRepeat,
            location: description.location,
            isKeypad: description.location === 3
          });
        });
      }
      _modifierBit(key) {
        if (key === "Alt")
          return 1;
        if (key === "Control")
          return 2;
        if (key === "Meta")
          return 4;
        if (key === "Shift")
          return 8;
        return 0;
      }
      _keyDescriptionForString(keyString) {
        const shift = this._modifiers & 8;
        const description = {
          key: "",
          keyCode: 0,
          code: "",
          text: "",
          location: 0
        };
        const definition = keyDefinitions[keyString];
        assert(definition, `Unknown key: "${keyString}"`);
        if (definition.key)
          description.key = definition.key;
        if (shift && definition.shiftKey)
          description.key = definition.shiftKey;
        if (definition.keyCode)
          description.keyCode = definition.keyCode;
        if (shift && definition.shiftKeyCode)
          description.keyCode = definition.shiftKeyCode;
        if (definition.code)
          description.code = definition.code;
        if (definition.location)
          description.location = definition.location;
        if (description.key.length === 1)
          description.text = description.key;
        if (definition.text)
          description.text = definition.text;
        if (shift && definition.shiftText)
          description.text = definition.shiftText;
        if (this._modifiers & ~8)
          description.text = "";
        return description;
      }
      up(key) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key2, arg) {
              let info, value;
              try {
                info = gen[key2](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const description = this._keyDescriptionForString(key);
          this._modifiers &= ~this._modifierBit(description.key);
          this._pressedKeys.delete(description.code);
          yield this._client.send("Input.dispatchKeyEvent", {
            type: "keyUp",
            modifiers: this._modifiers,
            key: description.key,
            windowsVirtualKeyCode: description.keyCode,
            code: description.code,
            location: description.location
          });
        });
      }
      sendCharacter(char) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Input.insertText", { text: char });
        });
      }
      type(text, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          let delay = 0;
          if (options && options.delay)
            delay = options.delay;
          for (const char of text) {
            if (keyDefinitions[char])
              yield this.press(char, { delay });
            else
              yield this.sendCharacter(char);
            if (delay)
              yield new Promise((f) => setTimeout(f, delay));
          }
        });
      }
      press(key, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key2, arg) {
              let info, value;
              try {
                info = gen[key2](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { delay = null } = options;
          yield this.down(key, options);
          if (delay !== null)
            yield new Promise((f) => setTimeout(f, options.delay));
          yield this.up(key);
        });
      }
    };
    var Mouse = class {
      constructor(client, keyboard) {
        this._client = client;
        this._keyboard = keyboard;
        this._x = 0;
        this._y = 0;
        this._button = "none";
      }
      move(x, y, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { steps = 1 } = options;
          const fromX = this._x, fromY = this._y;
          this._x = x;
          this._y = y;
          for (let i = 1; i <= steps; i++) {
            yield this._client.send("Input.dispatchMouseEvent", {
              type: "mouseMoved",
              button: this._button,
              x: fromX + (this._x - fromX) * (i / steps),
              y: fromY + (this._y - fromY) * (i / steps),
              modifiers: this._keyboard._modifiers
            });
          }
        });
      }
      click(x, y, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { delay = null } = options;
          this.move(x, y);
          this.down(options);
          if (delay !== null)
            yield new Promise((f) => setTimeout(f, delay));
          yield this.up(options);
        });
      }
      down(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { button = "left", clickCount = 1 } = options;
          this._button = button;
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mousePressed",
            button,
            x: this._x,
            y: this._y,
            modifiers: this._keyboard._modifiers,
            clickCount
          });
        });
      }
      up(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { button = "left", clickCount = 1 } = options;
          this._button = "none";
          yield this._client.send("Input.dispatchMouseEvent", {
            type: "mouseReleased",
            button,
            x: this._x,
            y: this._y,
            modifiers: this._keyboard._modifiers,
            clickCount
          });
        });
      }
    };
    var Touchscreen = class {
      constructor(client, keyboard) {
        this._client = client;
        this._keyboard = keyboard;
      }
      tap(x, y) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Runtime.evaluate", {
            expression: "new Promise(x => requestAnimationFrame(() => requestAnimationFrame(x)))",
            awaitPromise: true
          });
          const touchPoints = [{ x: Math.round(x), y: Math.round(y) }];
          yield this._client.send("Input.dispatchTouchEvent", {
            type: "touchStart",
            touchPoints,
            modifiers: this._keyboard._modifiers
          });
          yield this._client.send("Input.dispatchTouchEvent", {
            type: "touchEnd",
            touchPoints: [],
            modifiers: this._keyboard._modifiers
          });
        });
      }
    };
    module2.exports = { Keyboard, Mouse, Touchscreen };
  }
});

// node_modules/puppeteer/node6/lib/Tracing.js
var require_Tracing2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Tracing.js"(exports, module2) {
    var { helper, assert } = require_helper2();
    var fs = require("fs");
    var openAsync = helper.promisify(fs.open);
    var writeAsync = helper.promisify(fs.write);
    var closeAsync = helper.promisify(fs.close);
    var Tracing = class {
      constructor(client) {
        this._client = client;
        this._recording = false;
        this._path = "";
      }
      start(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(!this._recording, "Cannot start recording trace while already recording trace.");
          const defaultCategories = [
            "-*",
            "devtools.timeline",
            "v8.execute",
            "disabled-by-default-devtools.timeline",
            "disabled-by-default-devtools.timeline.frame",
            "toplevel",
            "blink.console",
            "blink.user_timing",
            "latencyInfo",
            "disabled-by-default-devtools.timeline.stack",
            "disabled-by-default-v8.cpu_profiler",
            "disabled-by-default-v8.cpu_profiler.hires"
          ];
          const {
            path = null,
            screenshots = false,
            categories = defaultCategories
          } = options;
          if (screenshots)
            categories.push("disabled-by-default-devtools.screenshot");
          this._path = path;
          this._recording = true;
          yield this._client.send("Tracing.start", {
            transferMode: "ReturnAsStream",
            categories: categories.join(",")
          });
        });
      }
      stop() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          let fulfill;
          const contentPromise = new Promise((x) => fulfill = x);
          this._client.once("Tracing.tracingComplete", (event) => {
            this._readStream(event.stream, this._path).then(fulfill);
          });
          yield this._client.send("Tracing.end");
          this._recording = false;
          return contentPromise;
        });
      }
      _readStream(handle, path) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          let eof = false;
          let file;
          if (path)
            file = yield openAsync(path, "w");
          const bufs = [];
          while (!eof) {
            const response = yield this._client.send("IO.read", { handle });
            eof = response.eof;
            bufs.push(Buffer.from(response.data));
            if (path)
              yield writeAsync(file, response.data);
          }
          if (path)
            yield closeAsync(file);
          yield this._client.send("IO.close", { handle });
          let resultBuffer = null;
          try {
            resultBuffer = Buffer.concat(bufs);
          } finally {
            return resultBuffer;
          }
        });
      }
    };
    module2.exports = Tracing;
  }
});

// node_modules/puppeteer/node6/lib/Coverage.js
var require_Coverage2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Coverage.js"(exports, module2) {
    var { helper, debugError, assert } = require_helper2();
    var { EVALUATION_SCRIPT_URL } = require_ExecutionContext2();
    var Coverage = class {
      constructor(client) {
        this._jsCoverage = new JSCoverage(client);
        this._cssCoverage = new CSSCoverage(client);
      }
      startJSCoverage(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._jsCoverage.start(options);
        });
      }
      stopJSCoverage() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._jsCoverage.stop();
        });
      }
      startCSSCoverage(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._cssCoverage.start(options);
        });
      }
      stopCSSCoverage() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._cssCoverage.stop();
        });
      }
    };
    module2.exports = { Coverage };
    var JSCoverage = class {
      constructor(client) {
        this._client = client;
        this._enabled = false;
        this._scriptURLs = new Map();
        this._scriptSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(!this._enabled, "JSCoverage is already enabled");
          const {
            resetOnNavigation = true,
            reportAnonymousScripts = false
          } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._reportAnonymousScripts = reportAnonymousScripts;
          this._enabled = true;
          this._scriptURLs.clear();
          this._scriptSources.clear();
          this._eventListeners = [
            helper.addEventListener(this._client, "Debugger.scriptParsed", this._onScriptParsed.bind(this)),
            helper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))
          ];
          yield Promise.all([
            this._client.send("Profiler.enable"),
            this._client.send("Profiler.startPreciseCoverage", { callCount: false, detailed: true }),
            this._client.send("Debugger.enable"),
            this._client.send("Debugger.setSkipAllPauses", { skip: true })
          ]);
        });
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._scriptURLs.clear();
        this._scriptSources.clear();
      }
      _onScriptParsed(event) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (event.url === EVALUATION_SCRIPT_URL)
            return;
          if (!event.url && !this._reportAnonymousScripts)
            return;
          try {
            const response = yield this._client.send("Debugger.getScriptSource", { scriptId: event.scriptId });
            this._scriptURLs.set(event.scriptId, event.url);
            this._scriptSources.set(event.scriptId, response.scriptSource);
          } catch (e) {
            debugError(e);
          }
        });
      }
      stop() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(this._enabled, "JSCoverage is not enabled");
          this._enabled = false;
          const [profileResponse] = yield Promise.all([
            this._client.send("Profiler.takePreciseCoverage"),
            this._client.send("Profiler.stopPreciseCoverage"),
            this._client.send("Profiler.disable"),
            this._client.send("Debugger.disable")
          ]);
          helper.removeEventListeners(this._eventListeners);
          const coverage = [];
          for (const entry of profileResponse.result) {
            let url = this._scriptURLs.get(entry.scriptId);
            if (!url && this._reportAnonymousScripts)
              url = "debugger://VM" + entry.scriptId;
            const text = this._scriptSources.get(entry.scriptId);
            if (text === void 0 || url === void 0)
              continue;
            const flattenRanges = [];
            for (const func of entry.functions)
              flattenRanges.push(...func.ranges);
            const ranges = convertToDisjointRanges(flattenRanges);
            coverage.push({ url, ranges, text });
          }
          return coverage;
        });
      }
    };
    var CSSCoverage = class {
      constructor(client) {
        this._client = client;
        this._enabled = false;
        this._stylesheetURLs = new Map();
        this._stylesheetSources = new Map();
        this._eventListeners = [];
        this._resetOnNavigation = false;
      }
      start(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(!this._enabled, "CSSCoverage is already enabled");
          const { resetOnNavigation = true } = options;
          this._resetOnNavigation = resetOnNavigation;
          this._enabled = true;
          this._stylesheetURLs.clear();
          this._stylesheetSources.clear();
          this._eventListeners = [
            helper.addEventListener(this._client, "CSS.styleSheetAdded", this._onStyleSheet.bind(this)),
            helper.addEventListener(this._client, "Runtime.executionContextsCleared", this._onExecutionContextsCleared.bind(this))
          ];
          yield Promise.all([
            this._client.send("DOM.enable"),
            this._client.send("CSS.enable"),
            this._client.send("CSS.startRuleUsageTracking")
          ]);
        });
      }
      _onExecutionContextsCleared() {
        if (!this._resetOnNavigation)
          return;
        this._stylesheetURLs.clear();
        this._stylesheetSources.clear();
      }
      _onStyleSheet(event) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const header = event.header;
          if (!header.sourceURL)
            return;
          try {
            const response = yield this._client.send("CSS.getStyleSheetText", { styleSheetId: header.styleSheetId });
            this._stylesheetURLs.set(header.styleSheetId, header.sourceURL);
            this._stylesheetSources.set(header.styleSheetId, response.text);
          } catch (e) {
            debugError(e);
          }
        });
      }
      stop() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(this._enabled, "CSSCoverage is not enabled");
          this._enabled = false;
          const ruleTrackingResponse = yield this._client.send("CSS.stopRuleUsageTracking");
          yield Promise.all([
            this._client.send("CSS.disable"),
            this._client.send("DOM.disable")
          ]);
          helper.removeEventListeners(this._eventListeners);
          const styleSheetIdToCoverage = new Map();
          for (const entry of ruleTrackingResponse.ruleUsage) {
            let ranges = styleSheetIdToCoverage.get(entry.styleSheetId);
            if (!ranges) {
              ranges = [];
              styleSheetIdToCoverage.set(entry.styleSheetId, ranges);
            }
            ranges.push({
              startOffset: entry.startOffset,
              endOffset: entry.endOffset,
              count: entry.used ? 1 : 0
            });
          }
          const coverage = [];
          for (const styleSheetId of this._stylesheetURLs.keys()) {
            const url = this._stylesheetURLs.get(styleSheetId);
            const text = this._stylesheetSources.get(styleSheetId);
            const ranges = convertToDisjointRanges(styleSheetIdToCoverage.get(styleSheetId) || []);
            coverage.push({ url, ranges, text });
          }
          return coverage;
        });
      }
    };
    function convertToDisjointRanges(nestedRanges) {
      const points = [];
      for (const range of nestedRanges) {
        points.push({ offset: range.startOffset, type: 0, range });
        points.push({ offset: range.endOffset, type: 1, range });
      }
      points.sort((a, b) => {
        if (a.offset !== b.offset)
          return a.offset - b.offset;
        if (a.type !== b.type)
          return b.type - a.type;
        const aLength = a.range.endOffset - a.range.startOffset;
        const bLength = b.range.endOffset - b.range.startOffset;
        if (a.type === 0)
          return bLength - aLength;
        return aLength - bLength;
      });
      const hitCountStack = [];
      const results = [];
      let lastOffset = 0;
      for (const point of points) {
        if (hitCountStack.length && lastOffset < point.offset && hitCountStack[hitCountStack.length - 1] > 0) {
          const lastResult = results.length ? results[results.length - 1] : null;
          if (lastResult && lastResult.end === lastOffset)
            lastResult.end = point.offset;
          else
            results.push({ start: lastOffset, end: point.offset });
        }
        lastOffset = point.offset;
        if (point.type === 0)
          hitCountStack.push(point.range.count);
        else
          hitCountStack.pop();
      }
      return results.filter((range) => range.end - range.start > 1);
    }
  }
});

// node_modules/puppeteer/node6/lib/Worker.js
var require_Worker2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Worker.js"(exports, module2) {
    var EventEmitter = require("events");
    var { debugError } = require_helper2();
    var { ExecutionContext } = require_ExecutionContext2();
    var { JSHandle } = require_JSHandle2();
    var Worker = class extends EventEmitter {
      constructor(client, url, consoleAPICalled, exceptionThrown) {
        super();
        this._client = client;
        this._url = url;
        this._executionContextPromise = new Promise((x) => this._executionContextCallback = x);
        let jsHandleFactory;
        this._client.once("Runtime.executionContextCreated", (event) => {
          return ((fn) => {
            const gen = fn.call(this);
            return new Promise((resolve, reject) => {
              function step(key, arg) {
                let info, value;
                try {
                  info = gen[key](arg);
                  value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  return Promise.resolve(value).then((value2) => {
                    step("next", value2);
                  }, (err) => {
                    step("throw", err);
                  });
                }
              }
              return step("next");
            });
          })(function* () {
            jsHandleFactory = (remoteObject) => new JSHandle(executionContext, client, remoteObject);
            const executionContext = new ExecutionContext(client, event.context, null);
            this._executionContextCallback(executionContext);
          });
        });
        this._client.send("Runtime.enable", {}).catch(debugError);
        this._client.on("Runtime.consoleAPICalled", (event) => consoleAPICalled(event.type, event.args.map(jsHandleFactory), event.stackTrace));
        this._client.on("Runtime.exceptionThrown", (exception) => exceptionThrown(exception.exceptionDetails));
      }
      url() {
        return this._url;
      }
      executionContext() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._executionContextPromise;
        });
      }
      evaluate(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return (yield this._executionContextPromise).evaluate(pageFunction, ...args);
        });
      }
      evaluateHandle(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return (yield this._executionContextPromise).evaluateHandle(pageFunction, ...args);
        });
      }
    };
    module2.exports = { Worker };
  }
});

// node_modules/puppeteer/node6/lib/Accessibility.js
var require_Accessibility2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Accessibility.js"(exports, module2) {
    var Accessibility = class {
      constructor(client) {
        this._client = client;
      }
      snapshot(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            interestingOnly = true,
            root = null
          } = options;
          const { nodes } = yield this._client.send("Accessibility.getFullAXTree");
          let backendNodeId = null;
          if (root) {
            const { node } = yield this._client.send("DOM.describeNode", { objectId: root._remoteObject.objectId });
            backendNodeId = node.backendNodeId;
          }
          const defaultRoot = AXNode.createTree(nodes);
          let needle = defaultRoot;
          if (backendNodeId) {
            needle = defaultRoot.find((node) => node._payload.backendDOMNodeId === backendNodeId);
            if (!needle)
              return null;
          }
          if (!interestingOnly)
            return serializeTree(needle)[0];
          const interestingNodes = new Set();
          collectInterestingNodes(interestingNodes, defaultRoot, false);
          if (!interestingNodes.has(needle))
            return null;
          return serializeTree(needle, interestingNodes)[0];
        });
      }
    };
    function collectInterestingNodes(collection, node, insideControl) {
      if (node.isInteresting(insideControl))
        collection.add(node);
      if (node.isLeafNode())
        return;
      insideControl = insideControl || node.isControl();
      for (const child of node._children)
        collectInterestingNodes(collection, child, insideControl);
    }
    function serializeTree(node, whitelistedNodes) {
      const children = [];
      for (const child of node._children)
        children.push(...serializeTree(child, whitelistedNodes));
      if (whitelistedNodes && !whitelistedNodes.has(node))
        return children;
      const serializedNode = node.serialize();
      if (children.length)
        serializedNode.children = children;
      return [serializedNode];
    }
    var AXNode = class {
      constructor(payload) {
        this._payload = payload;
        this._children = [];
        this._richlyEditable = false;
        this._editable = false;
        this._focusable = false;
        this._expanded = false;
        this._name = this._payload.name ? this._payload.name.value : "";
        this._role = this._payload.role ? this._payload.role.value : "Unknown";
        this._cachedHasFocusableChild;
        for (const property of this._payload.properties || []) {
          if (property.name === "editable") {
            this._richlyEditable = property.value.value === "richtext";
            this._editable = true;
          }
          if (property.name === "focusable")
            this._focusable = property.value.value;
          if (property.name === "expanded")
            this._expanded = property.value.value;
        }
      }
      _isPlainTextField() {
        if (this._richlyEditable)
          return false;
        if (this._editable)
          return true;
        return this._role === "textbox" || this._role === "ComboBox" || this._role === "searchbox";
      }
      _isTextOnlyObject() {
        const role = this._role;
        return role === "LineBreak" || role === "text" || role === "InlineTextBox";
      }
      _hasFocusableChild() {
        if (this._cachedHasFocusableChild === void 0) {
          this._cachedHasFocusableChild = false;
          for (const child of this._children) {
            if (child._focusable || child._hasFocusableChild()) {
              this._cachedHasFocusableChild = true;
              break;
            }
          }
        }
        return this._cachedHasFocusableChild;
      }
      find(predicate) {
        if (predicate(this))
          return this;
        for (const child of this._children) {
          const result = child.find(predicate);
          if (result)
            return result;
        }
        return null;
      }
      isLeafNode() {
        if (!this._children.length)
          return true;
        if (this._isPlainTextField() || this._isTextOnlyObject())
          return true;
        switch (this._role) {
          case "doc-cover":
          case "graphics-symbol":
          case "img":
          case "Meter":
          case "scrollbar":
          case "slider":
          case "separator":
          case "progressbar":
            return true;
          default:
            break;
        }
        if (this._hasFocusableChild())
          return false;
        if (this._focusable && this._name)
          return true;
        if (this._role === "heading" && this._name)
          return true;
        return false;
      }
      isControl() {
        switch (this._role) {
          case "button":
          case "checkbox":
          case "ColorWell":
          case "combobox":
          case "DisclosureTriangle":
          case "listbox":
          case "menu":
          case "menubar":
          case "menuitem":
          case "menuitemcheckbox":
          case "menuitemradio":
          case "radio":
          case "scrollbar":
          case "searchbox":
          case "slider":
          case "spinbutton":
          case "switch":
          case "tab":
          case "textbox":
          case "tree":
            return true;
          default:
            return false;
        }
      }
      isInteresting(insideControl) {
        const role = this._role;
        if (role === "Ignored")
          return false;
        if (this._focusable || this._richlyEditable)
          return true;
        if (this.isControl())
          return true;
        if (insideControl)
          return false;
        return this.isLeafNode() && !!this._name;
      }
      serialize() {
        const properties = new Map();
        for (const property of this._payload.properties || [])
          properties.set(property.name.toLowerCase(), property.value.value);
        if (this._payload.name)
          properties.set("name", this._payload.name.value);
        if (this._payload.value)
          properties.set("value", this._payload.value.value);
        if (this._payload.description)
          properties.set("description", this._payload.description.value);
        const node = {
          role: this._role
        };
        const userStringProperties = [
          "name",
          "value",
          "description",
          "keyshortcuts",
          "roledescription",
          "valuetext"
        ];
        for (const userStringProperty of userStringProperties) {
          if (!properties.has(userStringProperty))
            continue;
          node[userStringProperty] = properties.get(userStringProperty);
        }
        const booleanProperties = [
          "disabled",
          "expanded",
          "focused",
          "modal",
          "multiline",
          "multiselectable",
          "readonly",
          "required",
          "selected"
        ];
        for (const booleanProperty of booleanProperties) {
          if (booleanProperty === "focused" && this._role === "WebArea")
            continue;
          const value = properties.get(booleanProperty);
          if (!value)
            continue;
          node[booleanProperty] = value;
        }
        const tristateProperties = [
          "checked",
          "pressed"
        ];
        for (const tristateProperty of tristateProperties) {
          if (!properties.has(tristateProperty))
            continue;
          const value = properties.get(tristateProperty);
          node[tristateProperty] = value === "mixed" ? "mixed" : value === "true" ? true : false;
        }
        const numericalProperties = [
          "level",
          "valuemax",
          "valuemin"
        ];
        for (const numericalProperty of numericalProperties) {
          if (!properties.has(numericalProperty))
            continue;
          node[numericalProperty] = properties.get(numericalProperty);
        }
        const tokenProperties = [
          "autocomplete",
          "haspopup",
          "invalid",
          "orientation"
        ];
        for (const tokenProperty of tokenProperties) {
          const value = properties.get(tokenProperty);
          if (!value || value === "false")
            continue;
          node[tokenProperty] = value;
        }
        return node;
      }
      static createTree(payloads) {
        const nodeById = new Map();
        for (const payload of payloads)
          nodeById.set(payload.nodeId, new AXNode(payload));
        for (const node of nodeById.values()) {
          for (const childId of node._payload.childIds || [])
            node._children.push(nodeById.get(childId));
        }
        return nodeById.values().next().value;
      }
    };
    module2.exports = { Accessibility };
  }
});

// node_modules/puppeteer/node6/lib/TimeoutSettings.js
var require_TimeoutSettings2 = __commonJS({
  "node_modules/puppeteer/node6/lib/TimeoutSettings.js"(exports, module2) {
    var DEFAULT_TIMEOUT = 3e4;
    var TimeoutSettings = class {
      constructor() {
        this._defaultTimeout = null;
        this._defaultNavigationTimeout = null;
      }
      setDefaultTimeout(timeout) {
        this._defaultTimeout = timeout;
      }
      setDefaultNavigationTimeout(timeout) {
        this._defaultNavigationTimeout = timeout;
      }
      navigationTimeout() {
        if (this._defaultNavigationTimeout !== null)
          return this._defaultNavigationTimeout;
        if (this._defaultTimeout !== null)
          return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
      }
      timeout() {
        if (this._defaultTimeout !== null)
          return this._defaultTimeout;
        return DEFAULT_TIMEOUT;
      }
    };
    module2.exports = { TimeoutSettings };
  }
});

// node_modules/puppeteer/node6/lib/Page.js
var require_Page2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Page.js"(exports, module2) {
    var fs = require("fs");
    var EventEmitter = require("events");
    var mime = require_mime();
    var { Events } = require_Events2();
    var { Connection } = require_Connection2();
    var { Dialog } = require_Dialog2();
    var { EmulationManager } = require_EmulationManager2();
    var { FrameManager } = require_FrameManager2();
    var { Keyboard, Mouse, Touchscreen } = require_Input2();
    var Tracing = require_Tracing2();
    var { helper, debugError, assert } = require_helper2();
    var { Coverage } = require_Coverage2();
    var { Worker } = require_Worker2();
    var { createJSHandle } = require_JSHandle2();
    var { Accessibility } = require_Accessibility2();
    var { TimeoutSettings } = require_TimeoutSettings2();
    var writeFileAsync = helper.promisify(fs.writeFile);
    var Page = class extends EventEmitter {
      static create(client, target, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const page = new Page(client, target, ignoreHTTPSErrors, screenshotTaskQueue);
          yield Promise.all([
            page._frameManager.initialize(),
            client.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: false, flatten: true }),
            client.send("Performance.enable", {}),
            client.send("Log.enable", {})
          ]);
          if (defaultViewport)
            yield page.setViewport(defaultViewport);
          return page;
        });
      }
      constructor(client, target, ignoreHTTPSErrors, screenshotTaskQueue) {
        super();
        this._closed = false;
        this._client = client;
        this._target = target;
        this._keyboard = new Keyboard(client);
        this._mouse = new Mouse(client, this._keyboard);
        this._timeoutSettings = new TimeoutSettings();
        this._touchscreen = new Touchscreen(client, this._keyboard);
        this._accessibility = new Accessibility(client);
        this._frameManager = new FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);
        this._emulationManager = new EmulationManager(client);
        this._tracing = new Tracing(client);
        this._pageBindings = new Map();
        this._coverage = new Coverage(client);
        this._javascriptEnabled = true;
        this._viewport = null;
        this._screenshotTaskQueue = screenshotTaskQueue;
        this._workers = new Map();
        client.on("Target.attachedToTarget", (event) => {
          if (event.targetInfo.type !== "worker") {
            client.send("Target.detachFromTarget", {
              sessionId: event.sessionId
            }).catch(debugError);
            return;
          }
          const session = Connection.fromSession(client).session(event.sessionId);
          const worker = new Worker(session, event.targetInfo.url, this._addConsoleMessage.bind(this), this._handleException.bind(this));
          this._workers.set(event.sessionId, worker);
          this.emit(Events.Page.WorkerCreated, worker);
        });
        client.on("Target.detachedFromTarget", (event) => {
          const worker = this._workers.get(event.sessionId);
          if (!worker)
            return;
          this.emit(Events.Page.WorkerDestroyed, worker);
          this._workers.delete(event.sessionId);
        });
        this._frameManager.on(Events.FrameManager.FrameAttached, (event) => this.emit(Events.Page.FrameAttached, event));
        this._frameManager.on(Events.FrameManager.FrameDetached, (event) => this.emit(Events.Page.FrameDetached, event));
        this._frameManager.on(Events.FrameManager.FrameNavigated, (event) => this.emit(Events.Page.FrameNavigated, event));
        const networkManager = this._frameManager.networkManager();
        networkManager.on(Events.NetworkManager.Request, (event) => this.emit(Events.Page.Request, event));
        networkManager.on(Events.NetworkManager.Response, (event) => this.emit(Events.Page.Response, event));
        networkManager.on(Events.NetworkManager.RequestFailed, (event) => this.emit(Events.Page.RequestFailed, event));
        networkManager.on(Events.NetworkManager.RequestFinished, (event) => this.emit(Events.Page.RequestFinished, event));
        client.on("Page.domContentEventFired", (event) => this.emit(Events.Page.DOMContentLoaded));
        client.on("Page.loadEventFired", (event) => this.emit(Events.Page.Load));
        client.on("Runtime.consoleAPICalled", (event) => this._onConsoleAPI(event));
        client.on("Runtime.bindingCalled", (event) => this._onBindingCalled(event));
        client.on("Page.javascriptDialogOpening", (event) => this._onDialog(event));
        client.on("Runtime.exceptionThrown", (exception) => this._handleException(exception.exceptionDetails));
        client.on("Inspector.targetCrashed", (event) => this._onTargetCrashed());
        client.on("Performance.metrics", (event) => this._emitMetrics(event));
        client.on("Log.entryAdded", (event) => this._onLogEntryAdded(event));
        this._target._isClosedPromise.then(() => {
          this.emit(Events.Page.Close);
          this._closed = true;
        });
      }
      setGeolocation(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { longitude, latitude, accuracy = 0 } = options;
          if (longitude < -180 || longitude > 180)
            throw new Error(`Invalid longitude "${longitude}": precondition -180 <= LONGITUDE <= 180 failed.`);
          if (latitude < -90 || latitude > 90)
            throw new Error(`Invalid latitude "${latitude}": precondition -90 <= LATITUDE <= 90 failed.`);
          if (accuracy < 0)
            throw new Error(`Invalid accuracy "${accuracy}": precondition 0 <= ACCURACY failed.`);
          yield this._client.send("Emulation.setGeolocationOverride", { longitude, latitude, accuracy });
        });
      }
      target() {
        return this._target;
      }
      browser() {
        return this._target.browser();
      }
      browserContext() {
        return this._target.browserContext();
      }
      _onTargetCrashed() {
        this.emit("error", new Error("Page crashed!"));
      }
      _onLogEntryAdded(event) {
        const { level, text, args, source, url, lineNumber } = event.entry;
        if (args)
          args.map((arg) => helper.releaseObject(this._client, arg));
        if (source !== "worker")
          this.emit(Events.Page.Console, new ConsoleMessage(level, text, [], { url, lineNumber }));
      }
      mainFrame() {
        return this._frameManager.mainFrame();
      }
      get keyboard() {
        return this._keyboard;
      }
      get touchscreen() {
        return this._touchscreen;
      }
      get coverage() {
        return this._coverage;
      }
      get tracing() {
        return this._tracing;
      }
      get accessibility() {
        return this._accessibility;
      }
      frames() {
        return this._frameManager.frames();
      }
      workers() {
        return Array.from(this._workers.values());
      }
      setRequestInterception(value) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value2;
              try {
                info = gen[key](arg);
                value2 = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value2);
              } else {
                return Promise.resolve(value2).then((value3) => {
                  step("next", value3);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._frameManager.networkManager().setRequestInterception(value);
        });
      }
      setOfflineMode(enabled) {
        return this._frameManager.networkManager().setOfflineMode(enabled);
      }
      setDefaultNavigationTimeout(timeout) {
        this._timeoutSettings.setDefaultNavigationTimeout(timeout);
      }
      setDefaultTimeout(timeout) {
        this._timeoutSettings.setDefaultTimeout(timeout);
      }
      $(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().$(selector);
        });
      }
      evaluateHandle(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const context = yield this.mainFrame().executionContext();
          return context.evaluateHandle(pageFunction, ...args);
        });
      }
      queryObjects(prototypeHandle) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const context = yield this.mainFrame().executionContext();
          return context.queryObjects(prototypeHandle);
        });
      }
      $eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().$eval(selector, pageFunction, ...args);
        });
      }
      $$eval(selector, pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().$$eval(selector, pageFunction, ...args);
        });
      }
      $$(selector) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().$$(selector);
        });
      }
      $x(expression) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().$x(expression);
        });
      }
      cookies(...urls) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return (yield this._client.send("Network.getCookies", {
            urls: urls.length ? urls : [this.url()]
          })).cookies;
        });
      }
      deleteCookie(...cookies) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const pageURL = this.url();
          for (const cookie of cookies) {
            const item = Object.assign({}, cookie);
            if (!cookie.url && pageURL.startsWith("http"))
              item.url = pageURL;
            yield this._client.send("Network.deleteCookies", item);
          }
        });
      }
      setCookie(...cookies) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const pageURL = this.url();
          const startsWithHTTP = pageURL.startsWith("http");
          const items = cookies.map((cookie) => {
            const item = Object.assign({}, cookie);
            if (!item.url && startsWithHTTP)
              item.url = pageURL;
            assert(item.url !== "about:blank", `Blank page can not have cookie "${item.name}"`);
            assert(!String.prototype.startsWith.call(item.url || "", "data:"), `Data URL page can not have cookie "${item.name}"`);
            return item;
          });
          yield this.deleteCookie(...items);
          if (items.length)
            yield this._client.send("Network.setCookies", { cookies: items });
        });
      }
      addScriptTag(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().addScriptTag(options);
        });
      }
      addStyleTag(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().addStyleTag(options);
        });
      }
      exposeFunction(name, puppeteerFunction) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._pageBindings.has(name))
            throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);
          this._pageBindings.set(name, puppeteerFunction);
          const expression = helper.evaluationString(addPageBinding, name);
          yield this._client.send("Runtime.addBinding", { name });
          yield this._client.send("Page.addScriptToEvaluateOnNewDocument", { source: expression });
          yield Promise.all(this.frames().map((frame) => frame.evaluate(expression).catch(debugError)));
          function addPageBinding(bindingName) {
            const binding = window[bindingName];
            window[bindingName] = (...args) => {
              const me = window[bindingName];
              let callbacks = me["callbacks"];
              if (!callbacks) {
                callbacks = new Map();
                me["callbacks"] = callbacks;
              }
              const seq = (me["lastSeq"] || 0) + 1;
              me["lastSeq"] = seq;
              const promise = new Promise((resolve, reject) => callbacks.set(seq, { resolve, reject }));
              binding(JSON.stringify({ name: bindingName, seq, args }));
              return promise;
            };
          }
        });
      }
      authenticate(credentials) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._frameManager.networkManager().authenticate(credentials);
        });
      }
      setExtraHTTPHeaders(headers) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._frameManager.networkManager().setExtraHTTPHeaders(headers);
        });
      }
      setUserAgent(userAgent) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._frameManager.networkManager().setUserAgent(userAgent);
        });
      }
      metrics() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const response = yield this._client.send("Performance.getMetrics");
          return this._buildMetricsObject(response.metrics);
        });
      }
      _emitMetrics(event) {
        this.emit(Events.Page.Metrics, {
          title: event.title,
          metrics: this._buildMetricsObject(event.metrics)
        });
      }
      _buildMetricsObject(metrics) {
        const result = {};
        for (const metric of metrics || []) {
          if (supportedMetrics.has(metric.name))
            result[metric.name] = metric.value;
        }
        return result;
      }
      _handleException(exceptionDetails) {
        const message = helper.getExceptionMessage(exceptionDetails);
        const err = new Error(message);
        err.stack = "";
        this.emit(Events.Page.PageError, err);
      }
      _onConsoleAPI(event) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (event.executionContextId === 0) {
            return;
          }
          const context = this._frameManager.executionContextById(event.executionContextId);
          const values = event.args.map((arg) => createJSHandle(context, arg));
          this._addConsoleMessage(event.type, values, event.stackTrace);
        });
      }
      _onBindingCalled(event) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { name, seq, args } = JSON.parse(event.payload);
          let expression = null;
          try {
            const result = yield this._pageBindings.get(name)(...args);
            expression = helper.evaluationString(deliverResult, name, seq, result);
          } catch (error) {
            if (error instanceof Error)
              expression = helper.evaluationString(deliverError, name, seq, error.message, error.stack);
            else
              expression = helper.evaluationString(deliverErrorValue, name, seq, error);
          }
          this._client.send("Runtime.evaluate", { expression, contextId: event.executionContextId }).catch(debugError);
          function deliverResult(name2, seq2, result) {
            window[name2]["callbacks"].get(seq2).resolve(result);
            window[name2]["callbacks"].delete(seq2);
          }
          function deliverError(name2, seq2, message, stack) {
            const error = new Error(message);
            error.stack = stack;
            window[name2]["callbacks"].get(seq2).reject(error);
            window[name2]["callbacks"].delete(seq2);
          }
          function deliverErrorValue(name2, seq2, value) {
            window[name2]["callbacks"].get(seq2).reject(value);
            window[name2]["callbacks"].delete(seq2);
          }
        });
      }
      _addConsoleMessage(type, args, stackTrace) {
        if (!this.listenerCount(Events.Page.Console)) {
          args.forEach((arg) => arg.dispose());
          return;
        }
        const textTokens = [];
        for (const arg of args) {
          const remoteObject = arg._remoteObject;
          if (remoteObject.objectId)
            textTokens.push(arg.toString());
          else
            textTokens.push(helper.valueFromRemoteObject(remoteObject));
        }
        const location = stackTrace && stackTrace.callFrames.length ? {
          url: stackTrace.callFrames[0].url,
          lineNumber: stackTrace.callFrames[0].lineNumber,
          columnNumber: stackTrace.callFrames[0].columnNumber
        } : {};
        const message = new ConsoleMessage(type, textTokens.join(" "), args, location);
        this.emit(Events.Page.Console, message);
      }
      _onDialog(event) {
        let dialogType = null;
        if (event.type === "alert")
          dialogType = Dialog.Type.Alert;
        else if (event.type === "confirm")
          dialogType = Dialog.Type.Confirm;
        else if (event.type === "prompt")
          dialogType = Dialog.Type.Prompt;
        else if (event.type === "beforeunload")
          dialogType = Dialog.Type.BeforeUnload;
        assert(dialogType, "Unknown javascript dialog type: " + event.type);
        const dialog = new Dialog(this._client, dialogType, event.message, event.defaultPrompt);
        this.emit(Events.Page.Dialog, dialog);
      }
      url() {
        return this.mainFrame().url();
      }
      content() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._frameManager.mainFrame().content();
        });
      }
      setContent(html, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._frameManager.mainFrame().setContent(html, options);
        });
      }
      goto(url, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._frameManager.mainFrame().goto(url, options);
        });
      }
      reload(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const [response] = yield Promise.all([
            this.waitForNavigation(options),
            this._client.send("Page.reload")
          ]);
          return response;
        });
      }
      waitForNavigation(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return yield this._frameManager.mainFrame().waitForNavigation(options);
        });
      }
      waitForRequest(urlOrPredicate, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            timeout = this._timeoutSettings.timeout()
          } = options;
          return helper.waitForEvent(this._frameManager.networkManager(), Events.NetworkManager.Request, (request) => {
            if (helper.isString(urlOrPredicate))
              return urlOrPredicate === request.url();
            if (typeof urlOrPredicate === "function")
              return !!urlOrPredicate(request);
            return false;
          }, timeout);
        });
      }
      waitForResponse(urlOrPredicate, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            timeout = this._timeoutSettings.timeout()
          } = options;
          return helper.waitForEvent(this._frameManager.networkManager(), Events.NetworkManager.Response, (response) => {
            if (helper.isString(urlOrPredicate))
              return urlOrPredicate === response.url();
            if (typeof urlOrPredicate === "function")
              return !!urlOrPredicate(response);
            return false;
          }, timeout);
        });
      }
      goBack(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._go(-1, options);
        });
      }
      goForward(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._go(1, options);
        });
      }
      _go(delta, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const history = yield this._client.send("Page.getNavigationHistory");
          const entry = history.entries[history.currentIndex + delta];
          if (!entry)
            return null;
          const [response] = yield Promise.all([
            this.waitForNavigation(options),
            this._client.send("Page.navigateToHistoryEntry", { entryId: entry.id })
          ]);
          return response;
        });
      }
      bringToFront() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Page.bringToFront");
        });
      }
      emulate(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield Promise.all([
            this.setViewport(options.viewport),
            this.setUserAgent(options.userAgent)
          ]);
        });
      }
      setJavaScriptEnabled(enabled) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._javascriptEnabled === enabled)
            return;
          this._javascriptEnabled = enabled;
          yield this._client.send("Emulation.setScriptExecutionDisabled", { value: !enabled });
        });
      }
      setBypassCSP(enabled) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Page.setBypassCSP", { enabled });
        });
      }
      emulateMedia(mediaType) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(mediaType === "screen" || mediaType === "print" || mediaType === null, "Unsupported media type: " + mediaType);
          yield this._client.send("Emulation.setEmulatedMedia", { media: mediaType || "" });
        });
      }
      setViewport(viewport) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const needsReload = yield this._emulationManager.emulateViewport(viewport);
          this._viewport = viewport;
          if (needsReload)
            yield this.reload();
        });
      }
      viewport() {
        return this._viewport;
      }
      evaluate(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._frameManager.mainFrame().evaluate(pageFunction, ...args);
        });
      }
      evaluateOnNewDocument(pageFunction, ...args) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const source = helper.evaluationString(pageFunction, ...args);
          yield this._client.send("Page.addScriptToEvaluateOnNewDocument", { source });
        });
      }
      setCacheEnabled(enabled = true) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._frameManager.networkManager().setCacheEnabled(enabled);
        });
      }
      screenshot(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          let screenshotType = null;
          if (options.type) {
            assert(options.type === "png" || options.type === "jpeg", "Unknown options.type value: " + options.type);
            screenshotType = options.type;
          } else if (options.path) {
            const mimeType = mime.getType(options.path);
            if (mimeType === "image/png")
              screenshotType = "png";
            else if (mimeType === "image/jpeg")
              screenshotType = "jpeg";
            assert(screenshotType, "Unsupported screenshot mime type: " + mimeType);
          }
          if (!screenshotType)
            screenshotType = "png";
          if (options.quality) {
            assert(screenshotType === "jpeg", "options.quality is unsupported for the " + screenshotType + " screenshots");
            assert(typeof options.quality === "number", "Expected options.quality to be a number but found " + typeof options.quality);
            assert(Number.isInteger(options.quality), "Expected options.quality to be an integer");
            assert(options.quality >= 0 && options.quality <= 100, "Expected options.quality to be between 0 and 100 (inclusive), got " + options.quality);
          }
          assert(!options.clip || !options.fullPage, "options.clip and options.fullPage are exclusive");
          if (options.clip) {
            assert(typeof options.clip.x === "number", "Expected options.clip.x to be a number but found " + typeof options.clip.x);
            assert(typeof options.clip.y === "number", "Expected options.clip.y to be a number but found " + typeof options.clip.y);
            assert(typeof options.clip.width === "number", "Expected options.clip.width to be a number but found " + typeof options.clip.width);
            assert(typeof options.clip.height === "number", "Expected options.clip.height to be a number but found " + typeof options.clip.height);
            assert(options.clip.width !== 0, "Expected options.clip.width not to be 0.");
            assert(options.clip.height !== 0, "Expected options.clip.width not to be 0.");
          }
          return this._screenshotTaskQueue.postTask(this._screenshotTask.bind(this, screenshotType, options));
        });
      }
      _screenshotTask(format, options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._client.send("Target.activateTarget", { targetId: this._target._targetId });
          let clip = options.clip ? processClip(options.clip) : void 0;
          if (options.fullPage) {
            const metrics = yield this._client.send("Page.getLayoutMetrics");
            const width = Math.ceil(metrics.contentSize.width);
            const height = Math.ceil(metrics.contentSize.height);
            clip = { x: 0, y: 0, width, height, scale: 1 };
            const {
              isMobile = false,
              deviceScaleFactor = 1,
              isLandscape = false
            } = this._viewport || {};
            const screenOrientation = isLandscape ? { angle: 90, type: "landscapePrimary" } : { angle: 0, type: "portraitPrimary" };
            yield this._client.send("Emulation.setDeviceMetricsOverride", { mobile: isMobile, width, height, deviceScaleFactor, screenOrientation });
          }
          const shouldSetDefaultBackground = options.omitBackground && format === "png";
          if (shouldSetDefaultBackground)
            yield this._client.send("Emulation.setDefaultBackgroundColorOverride", { color: { r: 0, g: 0, b: 0, a: 0 } });
          const result = yield this._client.send("Page.captureScreenshot", { format, quality: options.quality, clip });
          if (shouldSetDefaultBackground)
            yield this._client.send("Emulation.setDefaultBackgroundColorOverride");
          if (options.fullPage && this._viewport)
            yield this.setViewport(this._viewport);
          const buffer = options.encoding === "base64" ? result.data : Buffer.from(result.data, "base64");
          if (options.path)
            yield writeFileAsync(options.path, buffer);
          return buffer;
          function processClip(clip2) {
            const x = Math.round(clip2.x);
            const y = Math.round(clip2.y);
            const width = Math.round(clip2.width + clip2.x - x);
            const height = Math.round(clip2.height + clip2.y - y);
            return { x, y, width, height, scale: 1 };
          }
        });
      }
      pdf(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            scale = 1,
            displayHeaderFooter = false,
            headerTemplate = "",
            footerTemplate = "",
            printBackground = false,
            landscape = false,
            pageRanges = "",
            preferCSSPageSize = false,
            margin = {},
            path = null
          } = options;
          let paperWidth = 8.5;
          let paperHeight = 11;
          if (options.format) {
            const format = Page.PaperFormats[options.format.toLowerCase()];
            assert(format, "Unknown paper format: " + options.format);
            paperWidth = format.width;
            paperHeight = format.height;
          } else {
            paperWidth = convertPrintParameterToInches(options.width) || paperWidth;
            paperHeight = convertPrintParameterToInches(options.height) || paperHeight;
          }
          const marginTop = convertPrintParameterToInches(margin.top) || 0;
          const marginLeft = convertPrintParameterToInches(margin.left) || 0;
          const marginBottom = convertPrintParameterToInches(margin.bottom) || 0;
          const marginRight = convertPrintParameterToInches(margin.right) || 0;
          const result = yield this._client.send("Page.printToPDF", {
            landscape,
            displayHeaderFooter,
            headerTemplate,
            footerTemplate,
            printBackground,
            scale,
            paperWidth,
            paperHeight,
            marginTop,
            marginBottom,
            marginLeft,
            marginRight,
            pageRanges,
            preferCSSPageSize
          });
          const buffer = Buffer.from(result.data, "base64");
          if (path !== null)
            yield writeFileAsync(path, buffer);
          return buffer;
        });
      }
      title() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this.mainFrame().title();
        });
      }
      close(options = { runBeforeUnload: void 0 }) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(!!this._client._connection, "Protocol error: Connection closed. Most likely the page has been closed.");
          const runBeforeUnload = !!options.runBeforeUnload;
          if (runBeforeUnload) {
            yield this._client.send("Page.close");
          } else {
            yield this._client._connection.send("Target.closeTarget", { targetId: this._target._targetId });
            yield this._target._isClosedPromise;
          }
        });
      }
      isClosed() {
        return this._closed;
      }
      get mouse() {
        return this._mouse;
      }
      click(selector, options = {}) {
        return this.mainFrame().click(selector, options);
      }
      focus(selector) {
        return this.mainFrame().focus(selector);
      }
      hover(selector) {
        return this.mainFrame().hover(selector);
      }
      select(selector, ...values) {
        return this.mainFrame().select(selector, ...values);
      }
      tap(selector) {
        return this.mainFrame().tap(selector);
      }
      type(selector, text, options) {
        return this.mainFrame().type(selector, text, options);
      }
      waitFor(selectorOrFunctionOrTimeout, options = {}, ...args) {
        return this.mainFrame().waitFor(selectorOrFunctionOrTimeout, options, ...args);
      }
      waitForSelector(selector, options = {}) {
        return this.mainFrame().waitForSelector(selector, options);
      }
      waitForXPath(xpath, options = {}) {
        return this.mainFrame().waitForXPath(xpath, options);
      }
      waitForFunction(pageFunction, options = {}, ...args) {
        return this.mainFrame().waitForFunction(pageFunction, options, ...args);
      }
    };
    var supportedMetrics = new Set([
      "Timestamp",
      "Documents",
      "Frames",
      "JSEventListeners",
      "Nodes",
      "LayoutCount",
      "RecalcStyleCount",
      "LayoutDuration",
      "RecalcStyleDuration",
      "ScriptDuration",
      "TaskDuration",
      "JSHeapUsedSize",
      "JSHeapTotalSize"
    ]);
    Page.PaperFormats = {
      letter: { width: 8.5, height: 11 },
      legal: { width: 8.5, height: 14 },
      tabloid: { width: 11, height: 17 },
      ledger: { width: 17, height: 11 },
      a0: { width: 33.1, height: 46.8 },
      a1: { width: 23.4, height: 33.1 },
      a2: { width: 16.5, height: 23.4 },
      a3: { width: 11.7, height: 16.5 },
      a4: { width: 8.27, height: 11.7 },
      a5: { width: 5.83, height: 8.27 },
      a6: { width: 4.13, height: 5.83 }
    };
    var unitToPixels = {
      "px": 1,
      "in": 96,
      "cm": 37.8,
      "mm": 3.78
    };
    function convertPrintParameterToInches(parameter) {
      if (typeof parameter === "undefined")
        return void 0;
      let pixels;
      if (helper.isNumber(parameter)) {
        pixels = parameter;
      } else if (helper.isString(parameter)) {
        const text = parameter;
        let unit = text.substring(text.length - 2).toLowerCase();
        let valueText = "";
        if (unitToPixels.hasOwnProperty(unit)) {
          valueText = text.substring(0, text.length - 2);
        } else {
          unit = "px";
          valueText = text;
        }
        const value = Number(valueText);
        assert(!isNaN(value), "Failed to parse parameter value: " + text);
        pixels = value * unitToPixels[unit];
      } else {
        throw new Error("page.pdf() Cannot handle parameter type: " + typeof parameter);
      }
      return pixels / 96;
    }
    var ConsoleMessage = class {
      constructor(type, text, args, location = {}) {
        this._type = type;
        this._text = text;
        this._args = args;
        this._location = location;
      }
      type() {
        return this._type;
      }
      text() {
        return this._text;
      }
      args() {
        return this._args;
      }
      location() {
        return this._location;
      }
    };
    module2.exports = { Page, ConsoleMessage };
  }
});

// node_modules/puppeteer/node6/lib/Target.js
var require_Target2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Target.js"(exports, module2) {
    var { Events } = require_Events2();
    var { Page } = require_Page2();
    var { Worker } = require_Worker2();
    var { Connection } = require_Connection2();
    var Target = class {
      constructor(targetInfo, browserContext, sessionFactory, ignoreHTTPSErrors, defaultViewport, screenshotTaskQueue) {
        this._targetInfo = targetInfo;
        this._browserContext = browserContext;
        this._targetId = targetInfo.targetId;
        this._sessionFactory = sessionFactory;
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        this._screenshotTaskQueue = screenshotTaskQueue;
        this._pagePromise = null;
        this._workerPromise = null;
        this._initializedPromise = new Promise((fulfill) => this._initializedCallback = fulfill).then((success) => {
          return ((fn) => {
            const gen = fn.call(this);
            return new Promise((resolve, reject) => {
              function step(key, arg) {
                let info, value;
                try {
                  info = gen[key](arg);
                  value = info.value;
                } catch (error) {
                  reject(error);
                  return;
                }
                if (info.done) {
                  resolve(value);
                } else {
                  return Promise.resolve(value).then((value2) => {
                    step("next", value2);
                  }, (err) => {
                    step("throw", err);
                  });
                }
              }
              return step("next");
            });
          })(function* () {
            if (!success)
              return false;
            const opener = this.opener();
            if (!opener || !opener._pagePromise || this.type() !== "page")
              return true;
            const openerPage = yield opener._pagePromise;
            if (!openerPage.listenerCount(Events.Page.Popup))
              return true;
            const popupPage = yield this.page();
            openerPage.emit(Events.Page.Popup, popupPage);
            return true;
          });
        });
        this._isClosedPromise = new Promise((fulfill) => this._closedCallback = fulfill);
        this._isInitialized = this._targetInfo.type !== "page" || this._targetInfo.url !== "";
        if (this._isInitialized)
          this._initializedCallback(true);
      }
      createCDPSession() {
        return this._sessionFactory();
      }
      page() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if ((this._targetInfo.type === "page" || this._targetInfo.type === "background_page") && !this._pagePromise) {
            this._pagePromise = this._sessionFactory().then((client) => Page.create(client, this, this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue));
          }
          return this._pagePromise;
        });
      }
      worker() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          if (this._targetInfo.type !== "service_worker" && this._targetInfo.type !== "shared_worker")
            return null;
          if (!this._workerPromise) {
            this._workerPromise = this._sessionFactory().then((client) => {
              return ((fn) => {
                const gen = fn.call(this);
                return new Promise((resolve, reject) => {
                  function step(key, arg) {
                    let info, value;
                    try {
                      info = gen[key](arg);
                      value = info.value;
                    } catch (error) {
                      reject(error);
                      return;
                    }
                    if (info.done) {
                      resolve(value);
                    } else {
                      return Promise.resolve(value).then((value2) => {
                        step("next", value2);
                      }, (err) => {
                        step("throw", err);
                      });
                    }
                  }
                  return step("next");
                });
              })(function* () {
                const [targetAttached] = yield Promise.all([
                  new Promise((x) => client.once("Target.attachedToTarget", x)),
                  client.send("Target.setAutoAttach", { autoAttach: true, waitForDebuggerOnStart: false, flatten: true })
                ]);
                const session = Connection.fromSession(client).session(targetAttached.sessionId);
                return new Worker(session, this._targetInfo.url, () => {
                }, () => {
                });
              });
            });
          }
          return this._workerPromise;
        });
      }
      url() {
        return this._targetInfo.url;
      }
      type() {
        const type = this._targetInfo.type;
        if (type === "page" || type === "background_page" || type === "service_worker" || type === "shared_worker" || type === "browser")
          return type;
        return "other";
      }
      browser() {
        return this._browserContext.browser();
      }
      browserContext() {
        return this._browserContext;
      }
      opener() {
        const { openerId } = this._targetInfo;
        if (!openerId)
          return null;
        return this.browser()._targets.get(openerId);
      }
      _targetInfoChanged(targetInfo) {
        this._targetInfo = targetInfo;
        if (!this._isInitialized && (this._targetInfo.type !== "page" || this._targetInfo.url !== "")) {
          this._isInitialized = true;
          this._initializedCallback(true);
          return;
        }
      }
    };
    module2.exports = { Target };
  }
});

// node_modules/puppeteer/node6/lib/TaskQueue.js
var require_TaskQueue2 = __commonJS({
  "node_modules/puppeteer/node6/lib/TaskQueue.js"(exports, module2) {
    var TaskQueue = class {
      constructor() {
        this._chain = Promise.resolve();
      }
      postTask(task) {
        const result = this._chain.then(task);
        this._chain = result.catch(() => {
        });
        return result;
      }
    };
    module2.exports = { TaskQueue };
  }
});

// node_modules/puppeteer/node6/lib/Browser.js
var require_Browser2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Browser.js"(exports, module2) {
    var { helper, assert } = require_helper2();
    var { Target } = require_Target2();
    var EventEmitter = require("events");
    var { TaskQueue } = require_TaskQueue2();
    var { Events } = require_Events2();
    var Browser = class extends EventEmitter {
      static create(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const browser = new Browser(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback);
          yield connection.send("Target.setDiscoverTargets", { discover: true });
          return browser;
        });
      }
      constructor(connection, contextIds, ignoreHTTPSErrors, defaultViewport, process2, closeCallback) {
        super();
        this._ignoreHTTPSErrors = ignoreHTTPSErrors;
        this._defaultViewport = defaultViewport;
        this._process = process2;
        this._screenshotTaskQueue = new TaskQueue();
        this._connection = connection;
        this._closeCallback = closeCallback || new Function();
        this._defaultContext = new BrowserContext(this._connection, this, null);
        this._contexts = new Map();
        for (const contextId of contextIds)
          this._contexts.set(contextId, new BrowserContext(this._connection, this, contextId));
        this._targets = new Map();
        this._connection.on(Events.Connection.Disconnected, () => this.emit(Events.Browser.Disconnected));
        this._connection.on("Target.targetCreated", this._targetCreated.bind(this));
        this._connection.on("Target.targetDestroyed", this._targetDestroyed.bind(this));
        this._connection.on("Target.targetInfoChanged", this._targetInfoChanged.bind(this));
      }
      process() {
        return this._process;
      }
      createIncognitoBrowserContext() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { browserContextId } = yield this._connection.send("Target.createBrowserContext");
          const context = new BrowserContext(this._connection, this, browserContextId);
          this._contexts.set(browserContextId, context);
          return context;
        });
      }
      browserContexts() {
        return [this._defaultContext, ...Array.from(this._contexts.values())];
      }
      defaultBrowserContext() {
        return this._defaultContext;
      }
      _disposeContext(contextId) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._connection.send("Target.disposeBrowserContext", { browserContextId: contextId || void 0 });
          this._contexts.delete(contextId);
        });
      }
      _targetCreated(event) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const targetInfo = event.targetInfo;
          const { browserContextId } = targetInfo;
          const context = browserContextId && this._contexts.has(browserContextId) ? this._contexts.get(browserContextId) : this._defaultContext;
          const target = new Target(targetInfo, context, () => this._connection.createSession(targetInfo), this._ignoreHTTPSErrors, this._defaultViewport, this._screenshotTaskQueue);
          assert(!this._targets.has(event.targetInfo.targetId), "Target should not exist before targetCreated");
          this._targets.set(event.targetInfo.targetId, target);
          if (yield target._initializedPromise) {
            this.emit(Events.Browser.TargetCreated, target);
            context.emit(Events.BrowserContext.TargetCreated, target);
          }
        });
      }
      _targetDestroyed(event) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const target = this._targets.get(event.targetId);
          target._initializedCallback(false);
          this._targets.delete(event.targetId);
          target._closedCallback();
          if (yield target._initializedPromise) {
            this.emit(Events.Browser.TargetDestroyed, target);
            target.browserContext().emit(Events.BrowserContext.TargetDestroyed, target);
          }
        });
      }
      _targetInfoChanged(event) {
        const target = this._targets.get(event.targetInfo.targetId);
        assert(target, "target should exist before targetInfoChanged");
        const previousURL = target.url();
        const wasInitialized = target._isInitialized;
        target._targetInfoChanged(event.targetInfo);
        if (wasInitialized && previousURL !== target.url()) {
          this.emit(Events.Browser.TargetChanged, target);
          target.browserContext().emit(Events.BrowserContext.TargetChanged, target);
        }
      }
      wsEndpoint() {
        return this._connection.url();
      }
      newPage() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          return this._defaultContext.newPage();
        });
      }
      _createPageInContext(contextId) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const { targetId } = yield this._connection.send("Target.createTarget", { url: "about:blank", browserContextId: contextId || void 0 });
          const target = yield this._targets.get(targetId);
          assert(yield target._initializedPromise, "Failed to create target for page");
          const page = yield target.page();
          return page;
        });
      }
      targets() {
        return Array.from(this._targets.values()).filter((target) => target._isInitialized);
      }
      target() {
        return this.targets().find((target) => target.type() === "browser");
      }
      waitForTarget(predicate, options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            timeout = 3e4
          } = options;
          const existingTarget = this.targets().find(predicate);
          if (existingTarget)
            return existingTarget;
          let resolve;
          const targetPromise = new Promise((x) => resolve = x);
          this.on(Events.Browser.TargetCreated, check);
          this.on(Events.Browser.TargetChanged, check);
          try {
            if (!timeout)
              return yield targetPromise;
            return yield helper.waitWithTimeout(targetPromise, "target", timeout);
          } finally {
            this.removeListener(Events.Browser.TargetCreated, check);
            this.removeListener(Events.Browser.TargetChanged, check);
          }
          function check(target) {
            if (predicate(target))
              resolve(target);
          }
        });
      }
      pages() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const contextPages = yield Promise.all(this.browserContexts().map((context) => context.pages()));
          return contextPages.reduce((acc, x) => acc.concat(x), []);
        });
      }
      version() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const version = yield this._getVersion();
          return version.product;
        });
      }
      userAgent() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const version = yield this._getVersion();
          return version.userAgent;
        });
      }
      close() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._closeCallback.call(null);
          this.disconnect();
        });
      }
      disconnect() {
        this._connection.dispose();
      }
      isConnected() {
        return !this._connection._closed;
      }
      _getVersion() {
        return this._connection.send("Browser.getVersion");
      }
    };
    var BrowserContext = class extends EventEmitter {
      constructor(connection, browser, contextId) {
        super();
        this._connection = connection;
        this._browser = browser;
        this._id = contextId;
      }
      targets() {
        return this._browser.targets().filter((target) => target.browserContext() === this);
      }
      waitForTarget(predicate, options) {
        return this._browser.waitForTarget((target) => target.browserContext() === this && predicate(target), options);
      }
      pages() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const pages = yield Promise.all(this.targets().filter((target) => target.type() === "page").map((target) => target.page()));
          return pages.filter((page) => !!page);
        });
      }
      isIncognito() {
        return !!this._id;
      }
      overridePermissions(origin, permissions) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const webPermissionToProtocol = new Map([
            ["geolocation", "geolocation"],
            ["midi", "midi"],
            ["notifications", "notifications"],
            ["push", "push"],
            ["camera", "videoCapture"],
            ["microphone", "audioCapture"],
            ["background-sync", "backgroundSync"],
            ["ambient-light-sensor", "sensors"],
            ["accelerometer", "sensors"],
            ["gyroscope", "sensors"],
            ["magnetometer", "sensors"],
            ["accessibility-events", "accessibilityEvents"],
            ["clipboard-read", "clipboardRead"],
            ["clipboard-write", "clipboardWrite"],
            ["payment-handler", "paymentHandler"],
            ["midi-sysex", "midiSysex"]
          ]);
          permissions = permissions.map((permission) => {
            const protocolPermission = webPermissionToProtocol.get(permission);
            if (!protocolPermission)
              throw new Error("Unknown permission: " + permission);
            return protocolPermission;
          });
          yield this._connection.send("Browser.grantPermissions", { origin, browserContextId: this._id || void 0, permissions });
        });
      }
      clearPermissionOverrides() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          yield this._connection.send("Browser.resetPermissions", { browserContextId: this._id || void 0 });
        });
      }
      newPage() {
        return this._browser._createPageInContext(this._id);
      }
      browser() {
        return this._browser;
      }
      close() {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          assert(this._id, "Non-incognito profiles cannot be closed!");
          yield this._browser._disposeContext(this._id);
        });
      }
    };
    module2.exports = { Browser, BrowserContext };
  }
});

// node_modules/puppeteer/node6/lib/WebSocketTransport.js
var require_WebSocketTransport2 = __commonJS({
  "node_modules/puppeteer/node6/lib/WebSocketTransport.js"(exports, module2) {
    var WebSocket = require_ws();
    var WebSocketTransport = class {
      static create(url) {
        return new Promise((resolve, reject) => {
          const ws = new WebSocket(url, [], { perMessageDeflate: false });
          ws.addEventListener("open", () => resolve(new WebSocketTransport(ws)));
          ws.addEventListener("error", reject);
        });
      }
      constructor(ws) {
        this._ws = ws;
        this._ws.addEventListener("message", (event) => {
          if (this.onmessage)
            this.onmessage.call(null, event.data);
        });
        this._ws.addEventListener("close", (event) => {
          if (this.onclose)
            this.onclose.call(null);
        });
        this._ws.addEventListener("error", () => {
        });
        this.onmessage = null;
        this.onclose = null;
      }
      send(message) {
        this._ws.send(message);
      }
      close() {
        this._ws.close();
      }
    };
    module2.exports = WebSocketTransport;
  }
});

// node_modules/puppeteer/node6/lib/PipeTransport.js
var require_PipeTransport2 = __commonJS({
  "node_modules/puppeteer/node6/lib/PipeTransport.js"(exports, module2) {
    var { helper } = require_helper2();
    var PipeTransport = class {
      constructor(pipeWrite, pipeRead) {
        this._pipeWrite = pipeWrite;
        this._pendingMessage = "";
        this._eventListeners = [
          helper.addEventListener(pipeRead, "data", (buffer) => this._dispatch(buffer)),
          helper.addEventListener(pipeRead, "close", () => {
            if (this.onclose)
              this.onclose.call(null);
          })
        ];
        this.onmessage = null;
        this.onclose = null;
      }
      send(message) {
        this._pipeWrite.write(message);
        this._pipeWrite.write("\0");
      }
      _dispatch(buffer) {
        let end = buffer.indexOf("\0");
        if (end === -1) {
          this._pendingMessage += buffer.toString();
          return;
        }
        const message = this._pendingMessage + buffer.toString(void 0, 0, end);
        if (this.onmessage)
          this.onmessage.call(null, message);
        let start = end + 1;
        end = buffer.indexOf("\0", start);
        while (end !== -1) {
          if (this.onmessage)
            this.onmessage.call(null, buffer.toString(void 0, start, end));
          start = end + 1;
          end = buffer.indexOf("\0", start);
        }
        this._pendingMessage = buffer.toString(void 0, start);
      }
      close() {
        this._pipeWrite = null;
        helper.removeEventListeners(this._eventListeners);
      }
    };
    module2.exports = PipeTransport;
  }
});

// node_modules/puppeteer/node6/lib/Launcher.js
var require_Launcher2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Launcher.js"(exports, module2) {
    var os = require("os");
    var path = require("path");
    var http = require("http");
    var https = require("https");
    var URL = require("url");
    var removeFolder = require_rimraf();
    var childProcess = require("child_process");
    var BrowserFetcher = require_BrowserFetcher2();
    var { Connection } = require_Connection2();
    var { Browser } = require_Browser2();
    var readline = require("readline");
    var fs = require("fs");
    var { helper, assert, debugError } = require_helper2();
    var { TimeoutError } = require_Errors2();
    var WebSocketTransport = require_WebSocketTransport2();
    var PipeTransport = require_PipeTransport2();
    var mkdtempAsync = helper.promisify(fs.mkdtemp);
    var removeFolderAsync = helper.promisify(removeFolder);
    var CHROME_PROFILE_PATH = path.join(os.tmpdir(), "puppeteer_dev_profile-");
    var DEFAULT_ARGS = [
      "--disable-background-networking",
      "--enable-features=NetworkService,NetworkServiceInProcess",
      "--disable-background-timer-throttling",
      "--disable-backgrounding-occluded-windows",
      "--disable-breakpad",
      "--disable-client-side-phishing-detection",
      "--disable-default-apps",
      "--disable-dev-shm-usage",
      "--disable-extensions",
      "--disable-features=site-per-process,TranslateUI,BlinkGenPropertyTrees",
      "--disable-hang-monitor",
      "--disable-ipc-flooding-protection",
      "--disable-popup-blocking",
      "--disable-prompt-on-repost",
      "--disable-renderer-backgrounding",
      "--disable-sync",
      "--force-color-profile=srgb",
      "--metrics-recording-only",
      "--no-first-run",
      "--enable-automation",
      "--password-store=basic",
      "--use-mock-keychain"
    ];
    var Launcher = class {
      constructor(projectRoot, preferredRevision, isPuppeteerCore) {
        this._projectRoot = projectRoot;
        this._preferredRevision = preferredRevision;
        this._isPuppeteerCore = isPuppeteerCore;
      }
      launch(options = {}) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            ignoreDefaultArgs = false,
            args = [],
            dumpio = false,
            executablePath = null,
            pipe = false,
            env = process.env,
            handleSIGINT = true,
            handleSIGTERM = true,
            handleSIGHUP = true,
            ignoreHTTPSErrors = false,
            defaultViewport = { width: 800, height: 600 },
            slowMo = 0,
            timeout = 3e4
          } = options;
          const chromeArguments = [];
          if (!ignoreDefaultArgs)
            chromeArguments.push(...this.defaultArgs(options));
          else if (Array.isArray(ignoreDefaultArgs))
            chromeArguments.push(...this.defaultArgs(options).filter((arg) => ignoreDefaultArgs.indexOf(arg) === -1));
          else
            chromeArguments.push(...args);
          let temporaryUserDataDir = null;
          if (!chromeArguments.some((argument) => argument.startsWith("--remote-debugging-")))
            chromeArguments.push(pipe ? "--remote-debugging-pipe" : "--remote-debugging-port=0");
          if (!chromeArguments.some((arg) => arg.startsWith("--user-data-dir"))) {
            temporaryUserDataDir = yield mkdtempAsync(CHROME_PROFILE_PATH);
            chromeArguments.push(`--user-data-dir=${temporaryUserDataDir}`);
          }
          let chromeExecutable = executablePath;
          if (!executablePath) {
            const { missingText, executablePath: executablePath2 } = this._resolveExecutablePath();
            if (missingText)
              throw new Error(missingText);
            chromeExecutable = executablePath2;
          }
          const usePipe = chromeArguments.includes("--remote-debugging-pipe");
          const stdio = usePipe ? ["ignore", "ignore", "ignore", "pipe", "pipe"] : ["pipe", "pipe", "pipe"];
          const chromeProcess = childProcess.spawn(chromeExecutable, chromeArguments, {
            detached: process.platform !== "win32",
            env,
            stdio
          });
          if (dumpio) {
            chromeProcess.stderr.pipe(process.stderr);
            chromeProcess.stdout.pipe(process.stdout);
          }
          let chromeClosed = false;
          const waitForChromeToClose = new Promise((fulfill, reject) => {
            chromeProcess.once("exit", () => {
              chromeClosed = true;
              if (temporaryUserDataDir) {
                removeFolderAsync(temporaryUserDataDir).then(() => fulfill()).catch((err) => console.error(err));
              } else {
                fulfill();
              }
            });
          });
          const listeners = [helper.addEventListener(process, "exit", killChrome)];
          if (handleSIGINT)
            listeners.push(helper.addEventListener(process, "SIGINT", () => {
              killChrome();
              process.exit(130);
            }));
          if (handleSIGTERM)
            listeners.push(helper.addEventListener(process, "SIGTERM", gracefullyCloseChrome));
          if (handleSIGHUP)
            listeners.push(helper.addEventListener(process, "SIGHUP", gracefullyCloseChrome));
          let connection = null;
          try {
            if (!usePipe) {
              const browserWSEndpoint = yield waitForWSEndpoint(chromeProcess, timeout, this._preferredRevision);
              const transport = yield WebSocketTransport.create(browserWSEndpoint);
              connection = new Connection(browserWSEndpoint, transport, slowMo);
            } else {
              const transport = new PipeTransport(chromeProcess.stdio[3], chromeProcess.stdio[4]);
              connection = new Connection("", transport, slowMo);
            }
            const browser = yield Browser.create(connection, [], ignoreHTTPSErrors, defaultViewport, chromeProcess, gracefullyCloseChrome);
            yield browser.waitForTarget((t) => t.type() === "page");
            return browser;
          } catch (e) {
            killChrome();
            throw e;
          }
          function gracefullyCloseChrome() {
            helper.removeEventListeners(listeners);
            if (temporaryUserDataDir) {
              killChrome();
            } else if (connection) {
              connection.send("Browser.close").catch((error) => {
                debugError(error);
                killChrome();
              });
            }
            return waitForChromeToClose;
          }
          function killChrome() {
            helper.removeEventListeners(listeners);
            if (chromeProcess.pid && !chromeProcess.killed && !chromeClosed) {
              try {
                if (process.platform === "win32")
                  childProcess.execSync(`taskkill /pid ${chromeProcess.pid} /T /F`);
                else
                  process.kill(-chromeProcess.pid, "SIGKILL");
              } catch (e) {
              }
            }
            try {
              removeFolder.sync(temporaryUserDataDir);
            } catch (e) {
            }
          }
        });
      }
      defaultArgs(options = {}) {
        const {
          devtools = false,
          headless = !devtools,
          args = [],
          userDataDir = null
        } = options;
        const chromeArguments = [...DEFAULT_ARGS];
        if (userDataDir)
          chromeArguments.push(`--user-data-dir=${userDataDir}`);
        if (devtools)
          chromeArguments.push("--auto-open-devtools-for-tabs");
        if (headless) {
          chromeArguments.push("--headless", "--hide-scrollbars", "--mute-audio");
          if (os.platform() === "win32")
            chromeArguments.push("--disable-gpu");
        }
        if (args.every((arg) => arg.startsWith("-")))
          chromeArguments.push("about:blank");
        chromeArguments.push(...args);
        return chromeArguments;
      }
      executablePath() {
        return this._resolveExecutablePath().executablePath;
      }
      connect(options) {
        return ((fn) => {
          const gen = fn.call(this);
          return new Promise((resolve, reject) => {
            function step(key, arg) {
              let info, value;
              try {
                info = gen[key](arg);
                value = info.value;
              } catch (error) {
                reject(error);
                return;
              }
              if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then((value2) => {
                  step("next", value2);
                }, (err) => {
                  step("throw", err);
                });
              }
            }
            return step("next");
          });
        })(function* () {
          const {
            browserWSEndpoint,
            browserURL,
            ignoreHTTPSErrors = false,
            defaultViewport = { width: 800, height: 600 },
            transport,
            slowMo = 0
          } = options;
          assert(Number(!!browserWSEndpoint) + Number(!!browserURL) + Number(!!transport) === 1, "Exactly one of browserWSEndpoint, browserURL or transport must be passed to puppeteer.connect");
          let connection = null;
          if (transport) {
            connection = new Connection("", transport, slowMo);
          } else if (browserWSEndpoint) {
            const connectionTransport = yield WebSocketTransport.create(browserWSEndpoint);
            connection = new Connection(browserWSEndpoint, connectionTransport, slowMo);
          } else if (browserURL) {
            const connectionURL = yield getWSEndpoint(browserURL);
            const connectionTransport = yield WebSocketTransport.create(connectionURL);
            connection = new Connection(connectionURL, connectionTransport, slowMo);
          }
          const { browserContextIds } = yield connection.send("Target.getBrowserContexts");
          return Browser.create(connection, browserContextIds, ignoreHTTPSErrors, defaultViewport, null, () => connection.send("Browser.close").catch(debugError));
        });
      }
      _resolveExecutablePath() {
        const browserFetcher = new BrowserFetcher(this._projectRoot);
        if (!this._isPuppeteerCore) {
          const executablePath = process.env.PUPPETEER_EXECUTABLE_PATH || process.env.npm_config_puppeteer_executable_path || process.env.npm_package_config_puppeteer_executable_path;
          if (executablePath) {
            const missingText2 = !fs.existsSync(executablePath) ? "Tried to use PUPPETEER_EXECUTABLE_PATH env variable to launch browser but did not find any executable at: " + executablePath : null;
            return { executablePath, missingText: missingText2 };
          }
          const revision = process.env["PUPPETEER_CHROMIUM_REVISION"];
          if (revision) {
            const revisionInfo2 = browserFetcher.revisionInfo(revision);
            const missingText2 = !revisionInfo2.local ? "Tried to use PUPPETEER_CHROMIUM_REVISION env variable to launch browser but did not find executable at: " + revisionInfo2.executablePath : null;
            return { executablePath: revisionInfo2.executablePath, missingText: missingText2 };
          }
        }
        const revisionInfo = browserFetcher.revisionInfo(this._preferredRevision);
        const missingText = !revisionInfo.local ? `Chromium revision is not downloaded. Run "npm install" or "yarn install"` : null;
        return { executablePath: revisionInfo.executablePath, missingText };
      }
    };
    function waitForWSEndpoint(chromeProcess, timeout, preferredRevision) {
      return new Promise((resolve, reject) => {
        const rl = readline.createInterface({ input: chromeProcess.stderr });
        let stderr = "";
        const listeners = [
          helper.addEventListener(rl, "line", onLine),
          helper.addEventListener(rl, "close", () => onClose()),
          helper.addEventListener(chromeProcess, "exit", () => onClose()),
          helper.addEventListener(chromeProcess, "error", (error) => onClose(error))
        ];
        const timeoutId = timeout ? setTimeout(onTimeout, timeout) : 0;
        function onClose(error) {
          cleanup();
          reject(new Error([
            "Failed to launch chrome!" + (error ? " " + error.message : ""),
            stderr,
            "",
            "TROUBLESHOOTING: https://github.com/GoogleChrome/puppeteer/blob/master/docs/troubleshooting.md",
            ""
          ].join("\n")));
        }
        function onTimeout() {
          cleanup();
          reject(new TimeoutError(`Timed out after ${timeout} ms while trying to connect to Chrome! The only Chrome revision guaranteed to work is r${preferredRevision}`));
        }
        function onLine(line) {
          stderr += line + "\n";
          const match = line.match(/^DevTools listening on (ws:\/\/.*)$/);
          if (!match)
            return;
          cleanup();
          resolve(match[1]);
        }
        function cleanup() {
          if (timeoutId)
            clearTimeout(timeoutId);
          helper.removeEventListeners(listeners);
        }
      });
    }
    function getWSEndpoint(browserURL) {
      let resolve, reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      const endpointURL = URL.resolve(browserURL, "/json/version");
      const protocol = endpointURL.startsWith("https") ? https : http;
      const requestOptions = Object.assign(URL.parse(endpointURL), { method: "GET" });
      const request = protocol.request(requestOptions, (res) => {
        let data = "";
        if (res.statusCode !== 200) {
          res.resume();
          reject(new Error("HTTP " + res.statusCode));
          return;
        }
        res.setEncoding("utf8");
        res.on("data", (chunk) => data += chunk);
        res.on("end", () => resolve(JSON.parse(data).webSocketDebuggerUrl));
      });
      request.on("error", reject);
      request.end();
      return promise.catch((e) => {
        e.message = `Failed to fetch browser webSocket url from ${endpointURL}: ` + e.message;
        throw e;
      });
    }
    module2.exports = Launcher;
  }
});

// node_modules/puppeteer/node6/lib/DeviceDescriptors.js
var require_DeviceDescriptors2 = __commonJS({
  "node_modules/puppeteer/node6/lib/DeviceDescriptors.js"(exports, module2) {
    module2.exports = [
      {
        "name": "Blackberry PlayBook",
        "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        "viewport": {
          "width": 600,
          "height": 1024,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Blackberry PlayBook landscape",
        "userAgent": "Mozilla/5.0 (PlayBook; U; RIM Tablet OS 2.1.0; en-US) AppleWebKit/536.2+ (KHTML like Gecko) Version/7.2.1.0 Safari/536.2+",
        "viewport": {
          "width": 1024,
          "height": 600,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "BlackBerry Z30",
        "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "BlackBerry Z30 landscape",
        "userAgent": "Mozilla/5.0 (BB10; Touch) AppleWebKit/537.10+ (KHTML, like Gecko) Version/10.0.9.2372 Mobile Safari/537.10+",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy Note 3",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy Note 3 landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.3; en-us; SM-N900T Build/JSS15J) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy Note II",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy Note II landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.1; en-us; GT-N7100 Build/JRO03C) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy S III",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy S III landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.0; en-us; GT-I9300 Build/IMM76D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Galaxy S5",
        "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Galaxy S5 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPad",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 768,
          "height": 1024,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPad landscape",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 768,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPad Mini",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 768,
          "height": 1024,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPad Mini landscape",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 768,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPad Pro",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1024,
          "height": 1366,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPad Pro landscape",
        "userAgent": "Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1",
        "viewport": {
          "width": 1366,
          "height": 1024,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 4",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        "viewport": {
          "width": 320,
          "height": 480,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 4 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 7_1_2 like Mac OS X) AppleWebKit/537.51.2 (KHTML, like Gecko) Version/7.0 Mobile/11D257 Safari/9537.53",
        "viewport": {
          "width": 480,
          "height": 320,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 5",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 320,
          "height": 568,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 5 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 568,
          "height": 320,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 6",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 6 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 6 Plus",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 6 Plus landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 7",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 7 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 7 Plus",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 7 Plus landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 8",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 667,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 8 landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 667,
          "height": 375,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone 8 Plus",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 414,
          "height": 736,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone 8 Plus landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 736,
          "height": 414,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone SE",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 320,
          "height": 568,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone SE landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 10_3_1 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Version/10.0 Mobile/14E304 Safari/602.1",
        "viewport": {
          "width": 568,
          "height": 320,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "iPhone X",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 375,
          "height": 812,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "iPhone X landscape",
        "userAgent": "Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1",
        "viewport": {
          "width": 812,
          "height": 375,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "JioPhone 2",
        "userAgent": "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        "viewport": {
          "width": 240,
          "height": 320,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "JioPhone 2 landscape",
        "userAgent": "Mozilla/5.0 (Mobile; LYF/F300B/LYF-F300B-001-01-15-130718-i;Android; rv:48.0) Gecko/48.0 Firefox/48.0 KAIOS/2.5",
        "viewport": {
          "width": 320,
          "height": 240,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Kindle Fire HDX",
        "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        "viewport": {
          "width": 800,
          "height": 1280,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Kindle Fire HDX landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; en-us; KFAPWI Build/JDQ39) AppleWebKit/535.19 (KHTML, like Gecko) Silk/3.13 Safari/535.19 Silk-Accelerated=true",
        "viewport": {
          "width": 1280,
          "height": 800,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "LG Optimus L70",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 384,
          "height": 640,
          "deviceScaleFactor": 1.25,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "LG Optimus L70 landscape",
        "userAgent": "Mozilla/5.0 (Linux; U; Android 4.4.2; en-us; LGMS323 Build/KOT49I.MS32310c) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 384,
          "deviceScaleFactor": 1.25,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Microsoft Lumia 550",
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 550) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Microsoft Lumia 950",
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 4,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Microsoft Lumia 950 landscape",
        "userAgent": "Mozilla/5.0 (Windows Phone 10.0; Android 4.2.1; Microsoft; Lumia 950) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/46.0.2486.0 Mobile Safari/537.36 Edge/14.14263",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 4,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 10",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 800,
          "height": 1280,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 10 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 10 Build/MOB31T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 1280,
          "height": 800,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 4",
        "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 384,
          "height": 640,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 4 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 4.4.2; Nexus 4 Build/KOT49H) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 384,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 5",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 360,
          "height": 640,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 5 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 640,
          "height": 360,
          "deviceScaleFactor": 3,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 5X",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 5X landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 5X Build/OPR4.170623.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 6",
        "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 6 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 7.1.1; Nexus 6 Build/N6F26U) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 6P",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 412,
          "height": 732,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 6P landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Nexus 6P Build/OPP3.170518.006) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 732,
          "height": 412,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nexus 7",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 600,
          "height": 960,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nexus 7 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 6.0.1; Nexus 7 Build/MOB30X) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Safari/537.36",
        "viewport": {
          "width": 960,
          "height": 600,
          "deviceScaleFactor": 2,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nokia Lumia 520",
        "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        "viewport": {
          "width": 320,
          "height": 533,
          "deviceScaleFactor": 1.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nokia Lumia 520 landscape",
        "userAgent": "Mozilla/5.0 (compatible; MSIE 10.0; Windows Phone 8.0; Trident/6.0; IEMobile/10.0; ARM; Touch; NOKIA; Lumia 520)",
        "viewport": {
          "width": 533,
          "height": 320,
          "deviceScaleFactor": 1.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Nokia N9",
        "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        "viewport": {
          "width": 480,
          "height": 854,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Nokia N9 landscape",
        "userAgent": "Mozilla/5.0 (MeeGo; NokiaN9) AppleWebKit/534.13 (KHTML, like Gecko) NokiaBrowser/8.5.0 Mobile Safari/534.13",
        "viewport": {
          "width": 854,
          "height": 480,
          "deviceScaleFactor": 1,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Pixel 2",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 411,
          "height": 731,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Pixel 2 landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0; Pixel 2 Build/OPD3.170816.012) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 731,
          "height": 411,
          "deviceScaleFactor": 2.625,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      },
      {
        "name": "Pixel 2 XL",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 411,
          "height": 823,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": false
        }
      },
      {
        "name": "Pixel 2 XL landscape",
        "userAgent": "Mozilla/5.0 (Linux; Android 8.0.0; Pixel 2 XL Build/OPD1.170816.004) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3765.0 Mobile Safari/537.36",
        "viewport": {
          "width": 823,
          "height": 411,
          "deviceScaleFactor": 3.5,
          "isMobile": true,
          "hasTouch": true,
          "isLandscape": true
        }
      }
    ];
    for (const device of module2.exports)
      module2.exports[device.name] = device;
  }
});

// node_modules/puppeteer/node6/lib/Puppeteer.js
var require_Puppeteer2 = __commonJS({
  "node_modules/puppeteer/node6/lib/Puppeteer.js"(exports, module2) {
    var Launcher = require_Launcher2();
    var BrowserFetcher = require_BrowserFetcher2();
    var Errors = require_Errors2();
    var DeviceDescriptors = require_DeviceDescriptors2();
    module2.exports = class {
      constructor(projectRoot, preferredRevision, isPuppeteerCore) {
        this._projectRoot = projectRoot;
        this._launcher = new Launcher(projectRoot, preferredRevision, isPuppeteerCore);
      }
      launch(options) {
        return this._launcher.launch(options);
      }
      connect(options) {
        return this._launcher.connect(options);
      }
      executablePath() {
        return this._launcher.executablePath();
      }
      get devices() {
        return DeviceDescriptors;
      }
      get errors() {
        return Errors;
      }
      defaultArgs(options) {
        return this._launcher.defaultArgs(options);
      }
      createBrowserFetcher(options) {
        return new BrowserFetcher(this._projectRoot, options);
      }
    };
  }
});

// node_modules/puppeteer/package.json
var require_package = __commonJS({
  "node_modules/puppeteer/package.json"(exports, module2) {
    module2.exports = {
      name: "puppeteer",
      version: "1.17.0",
      description: "A high-level API to control headless Chrome over the DevTools Protocol",
      main: "index.js",
      repository: "github:GoogleChrome/puppeteer",
      engines: {
        node: ">=6.4.0"
      },
      puppeteer: {
        chromium_revision: "662092"
      },
      scripts: {
        unit: "node test/test.js",
        funit: "BROWSER=firefox node test/test.js",
        "debug-unit": "node --inspect-brk test/test.js",
        "test-doclint": "node utils/doclint/check_public_api/test/test.js && node utils/doclint/preprocessor/test.js",
        test: "npm run lint --silent && npm run coverage && npm run test-doclint && npm run test-node6-transformer && npm run test-types",
        install: "node install.js",
        lint: '([ "$CI" = true ] && eslint --quiet -f codeframe . || eslint .) && npm run tsc && npm run doc',
        doc: "node utils/doclint/cli.js",
        coverage: "cross-env COVERAGE=true npm run unit",
        "test-node6-transformer": "node utils/node6-transform/test/test.js",
        build: "node utils/node6-transform/index.js && node utils/doclint/generate_types",
        "unit-node6": "node node6/test/test.js",
        tsc: "tsc -p .",
        prepublishOnly: "npm run build",
        "apply-next-version": "node utils/apply_next_version.js",
        bundle: "npx browserify -r ./index.js:puppeteer -o utils/browser/puppeteer-web.js",
        "test-types": "node utils/doclint/generate_types && npx -p typescript@2.1 tsc -p utils/doclint/generate_types/test/",
        "unit-bundle": "node utils/browser/test.js"
      },
      author: "The Chromium Authors",
      license: "Apache-2.0",
      dependencies: {
        debug: "^4.1.0",
        "extract-zip": "^1.6.6",
        "https-proxy-agent": "^2.2.1",
        mime: "^2.0.3",
        progress: "^2.0.1",
        "proxy-from-env": "^1.0.0",
        rimraf: "^2.6.1",
        ws: "^6.1.0"
      },
      devDependencies: {
        "@types/debug": "0.0.31",
        "@types/extract-zip": "^1.6.2",
        "@types/mime": "^2.0.0",
        "@types/node": "^8.10.34",
        "@types/rimraf": "^2.0.2",
        "@types/ws": "^6.0.1",
        commonmark: "^0.28.1",
        "cross-env": "^5.0.5",
        eslint: "^5.15.1",
        esprima: "^4.0.0",
        "jpeg-js": "^0.3.4",
        minimist: "^1.2.0",
        ncp: "^2.0.0",
        pixelmatch: "^4.0.2",
        pngjs: "^3.3.3",
        "text-diff": "^1.0.1",
        typescript: "3.2.2"
      },
      browser: {
        "./lib/BrowserFetcher.js": false,
        "./node6/lib/Puppeteer": false,
        ws: "./utils/browser/WebSocket",
        fs: false,
        child_process: false,
        rimraf: false,
        readline: false
      }
    };
  }
});

// node_modules/puppeteer/index.js
var require_puppeteer = __commonJS({
  "node_modules/puppeteer/index.js"(exports, module2) {
    var asyncawait = true;
    try {
      new Function("async function test(){await 1}");
    } catch (error) {
      asyncawait = false;
    }
    if (asyncawait) {
      const { helper } = require_helper();
      const api = require_api();
      for (const className in api) {
        if (typeof api[className] === "function")
          helper.installAsyncStackHooks(api[className]);
      }
    }
    var Puppeteer = asyncawait ? require_Puppeteer() : require_Puppeteer2();
    var packageJson = require_package();
    var preferredRevision = packageJson.puppeteer.chromium_revision;
    var isPuppeteerCore = packageJson.name === "puppeteer-core";
    module2.exports = new Puppeteer(__dirname, preferredRevision, isPuppeteerCore);
  }
});

// node_modules/nested-error-stacks/index.js
var require_nested_error_stacks = __commonJS({
  "node_modules/nested-error-stacks/index.js"(exports, module2) {
    var inherits = require("util").inherits;
    var NestedError = function(message, nested) {
      this.nested = nested;
      if (message instanceof Error) {
        nested = message;
      } else if (typeof message !== "undefined") {
        Object.defineProperty(this, "message", {
          value: message,
          writable: true,
          enumerable: false,
          configurable: true
        });
      }
      Error.captureStackTrace(this, this.constructor);
      var oldStackDescriptor = Object.getOwnPropertyDescriptor(this, "stack");
      var stackDescriptor = buildStackDescriptor(oldStackDescriptor, nested);
      Object.defineProperty(this, "stack", stackDescriptor);
    };
    function buildStackDescriptor(oldStackDescriptor, nested) {
      if (oldStackDescriptor.get) {
        return {
          get: function() {
            var stack2 = oldStackDescriptor.get.call(this);
            return buildCombinedStacks(stack2, this.nested);
          }
        };
      } else {
        var stack = oldStackDescriptor.value;
        return {
          value: buildCombinedStacks(stack, nested)
        };
      }
    }
    function buildCombinedStacks(stack, nested) {
      if (nested) {
        stack += "\nCaused By: " + nested.stack;
      }
      return stack;
    }
    inherits(NestedError, Error);
    NestedError.prototype.name = "NestedError";
    module2.exports = NestedError;
  }
});

// node_modules/google-finance-data/index.js
var require_google_finance_data = __commonJS({
  "node_modules/google-finance-data/index.js"(exports) {
    "use strict";
    var puppeteer = require_puppeteer();
    var NestedError = require_nested_error_stacks();
    function getTextContent(element) {
      return element.getProperty("textContent").then((property) => property.jsonValue());
      ;
    }
    function parseNumber(value) {
      const number = value === "-" ? null : 1 * value;
      return number;
    }
    var getSymbol = async (symbol) => {
      const symbolPrefix = ["", "NYSE:", "NASDAQ:"];
      const browser = await puppeteer.launch({ args: ["--no-sandbox"] });
      const page = await browser.newPage();
      await page.setUserAgent("Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3205.0 Safari/537.36");
      symbol = symbol.toUpperCase();
      let fetchError = null;
      for (let prefix of symbolPrefix) {
        try {
          const rsp = await page.goto("https://www.google.com/search?q=" + prefix + symbol);
          if (rsp.status() !== 200) {
            continue;
          }
          const sectionSelector = "div#knowledge-finance-wholepage__entity-summary g-card-section g-card-section span";
          await page.waitForSelector(sectionSelector, { timeout: 7e3 });
          const sectionElements = await page.$$(sectionSelector);
          const tableRowElements = await page.$$("div#knowledge-finance-wholepage__entity-summary g-card-section table tbody tr");
          const stockData = { symbol };
          if (sectionElements.length >= 3) {
            stockData.companyName = await getTextContent(sectionElements[0]);
            stockData.ticker = (await getTextContent(sectionElements[1])).replace(" ", "");
            stockData.last = parseNumber((await getTextContent(sectionElements[2])).split(" ")[0]);
          }
          for (let row of tableRowElements) {
            const rowData = await row.$$("td");
            const field = await getTextContent(rowData[0]);
            const value = await getTextContent(rowData[1]);
            if (field === "Open") {
              stockData.open = parseNumber(value);
            } else if (field === "High") {
              stockData.high = parseNumber(value);
              ;
            } else if (field === "Low") {
              stockData.low = parseNumber(value);
              ;
            } else if (field === "Mkt cap") {
              stockData.marketCap = value;
            } else if (field === "P/E ratio") {
              stockData.peRatio = parseNumber(value);
            } else if (field === "Div yield") {
              stockData.yield = parseNumber(value.replace("%", ""));
            } else if (field === "Prev close") {
              stockData.prevClose = parseNumber(value);
            } else if (field === "52-wk high") {
              stockData.high52week = parseNumber(value);
            } else if (field === "52-wk low") {
              stockData.low52week = parseNumber(value);
            }
          }
          if (Object.keys(stockData).length !== 13) {
            continue;
          }
          browser.close();
          return stockData;
        } catch (err) {
          fetchError = err;
        }
      }
      browser.close();
      throw new NestedError(`unable to fetch data for ${symbol}`, fetchError);
    };
    exports.getSymbol = getSymbol;
  }
});

// functions/gfinance.ts
__export(exports, {
  handler: () => handler
});
var import_google_finance_data = __toModule(require_google_finance_data());
var handler = async (event, context, callback) => {
  if (event.httpMethod === "GET") {
    const gdata = await import_google_finance_data.default.getSymbol("MSFT");
    return {
      statusCode: 200,
      body: JSON.stringify(gdata)
    };
  } else {
    return {
      statusCode: 405,
      body: JSON.stringify("Error")
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  handler
});
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */
//# sourceMappingURL=gfinance.js.map
